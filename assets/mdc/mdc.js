/* alert('IMPORTANT: Remove this line from json2.js before deployment.'); */
/*
    http://www.JSON.org/json2.js
    2010-03-20

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, strict: false */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (!this.JSON) {
    this.JSON = {};
}

(function () {

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    var isBlackberry = (/blackberry/gi).test(window.navigator.appVersion);
    if (isBlackberry || typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                   this.getUTCFullYear()   + '-' +
                 f(this.getUTCMonth() + 1) + '-' +
                 f(this.getUTCDate())      + 'T' +
                 f(this.getUTCHours())     + ':' +
                 f(this.getUTCMinutes())   + ':' +
                 f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON =
        Number.prototype.toJSON =
        Boolean.prototype.toJSON = function (key) {
            return this.valueOf();
        };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ?
            '"' + string.replace(escapable, function (a) {
                var c = meta[a];
                return typeof c === 'string' ? c :
                    '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"' :
            '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' :
                    gap ? '[\n' + gap +
                            partial.join(',\n' + gap) + '\n' +
                                mind + ']' :
                          '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' :
                gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' +
                        mind + '}' : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                     typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/.
test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').
replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());/**
 * Version: 1.0 Alpha-1 
 * Build Date: 13-Nov-2007
 * Copyright (c) 2006-2007, Coolite Inc. (http://www.coolite.com/). All rights reserved.
 * License: Licensed under The MIT License. See license.txt and http://www.datejs.com/license/. 
 * Website: http://www.datejs.com/ or http://www.coolite.com/datejs/
 */
Date.CultureInfo={name:"en-GB",englishName:"English (United Kingdom)",nativeName:"English (United Kingdom)",dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],abbreviatedDayNames:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],shortestDayNames:["Su","Mo","Tu","We","Th","Fr","Sa"],firstLetterDayNames:["S","M","T","W","T","F","S"],monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],abbreviatedMonthNames:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],amDesignator:"AM",pmDesignator:"PM",firstDayOfWeek:1,twoDigitYearMax:2029,dateElementOrder:"dmy",formatPatterns:{shortDate:"dd/MM/yyyy",longDate:"dd MMMM yyyy",shortTime:"HH:mm",longTime:"HH:mm:ss",fullDateTime:"dd MMMM yyyy HH:mm:ss",sortableDateTime:"yyyy-MM-ddTHH:mm:ss",universalSortableDateTime:"yyyy-MM-dd HH:mm:ssZ",rfc1123:"ddd, dd MMM yyyy HH:mm:ss GMT",monthDay:"dd MMMM",yearMonth:"MMMM yyyy"},regexPatterns:{jan:/^jan(uary)?/i,feb:/^feb(ruary)?/i,mar:/^mar(ch)?/i,apr:/^apr(il)?/i,may:/^may/i,jun:/^jun(e)?/i,jul:/^jul(y)?/i,aug:/^aug(ust)?/i,sep:/^sep(t(ember)?)?/i,oct:/^oct(ober)?/i,nov:/^nov(ember)?/i,dec:/^dec(ember)?/i,sun:/^su(n(day)?)?/i,mon:/^mo(n(day)?)?/i,tue:/^tu(e(s(day)?)?)?/i,wed:/^we(d(nesday)?)?/i,thu:/^th(u(r(s(day)?)?)?)?/i,fri:/^fr(i(day)?)?/i,sat:/^sa(t(urday)?)?/i,future:/^next/i,past:/^last|past|prev(ious)?/i,add:/^(\+|after|from)/i,subtract:/^(\-|before|ago)/i,yesterday:/^yesterday/i,today:/^t(oday)?/i,tomorrow:/^tomorrow/i,now:/^n(ow)?/i,millisecond:/^ms|milli(second)?s?/i,second:/^sec(ond)?s?/i,minute:/^min(ute)?s?/i,hour:/^h(ou)?rs?/i,week:/^w(ee)?k/i,month:/^m(o(nth)?s?)?/i,day:/^d(ays?)?/i,year:/^y((ea)?rs?)?/i,shortMeridian:/^(a|p)/i,longMeridian:/^(a\.?m?\.?|p\.?m?\.?)/i,timezone:/^((e(s|d)t|c(s|d)t|m(s|d)t|p(s|d)t)|((gmt)?\s*(\+|\-)\s*\d\d\d\d?)|gmt)/i,ordinalSuffix:/^\s*(st|nd|rd|th)/i,timeContext:/^\s*(\:|a|p)/i},abbreviatedTimeZoneStandard:{GMT:"-000",EST:"-0400",CST:"-0500",MST:"-0600",PST:"-0700"},abbreviatedTimeZoneDST:{GMT:"-000",EDT:"-0500",CDT:"-0600",MDT:"-0700",PDT:"-0800"}};
Date.getMonthNumberFromName=function(name){var n=Date.CultureInfo.monthNames,m=Date.CultureInfo.abbreviatedMonthNames,s=name.toLowerCase();for(var i=0;i<n.length;i++){if(n[i].toLowerCase()==s||m[i].toLowerCase()==s){return i;}}
return-1;};Date.getDayNumberFromName=function(name){var n=Date.CultureInfo.dayNames,m=Date.CultureInfo.abbreviatedDayNames,o=Date.CultureInfo.shortestDayNames,s=name.toLowerCase();for(var i=0;i<n.length;i++){if(n[i].toLowerCase()==s||m[i].toLowerCase()==s){return i;}}
return-1;};Date.isLeapYear=function(year){return(((year%4===0)&&(year%100!==0))||(year%400===0));};Date.getDaysInMonth=function(year,month){return[31,(Date.isLeapYear(year)?29:28),31,30,31,30,31,31,30,31,30,31][month];};Date.getTimezoneOffset=function(s,dst){return(dst||false)?Date.CultureInfo.abbreviatedTimeZoneDST[s.toUpperCase()]:Date.CultureInfo.abbreviatedTimeZoneStandard[s.toUpperCase()];};Date.getTimezoneAbbreviation=function(offset,dst){var n=(dst||false)?Date.CultureInfo.abbreviatedTimeZoneDST:Date.CultureInfo.abbreviatedTimeZoneStandard,p;for(p in n){if(n[p]===offset){return p;}}
return null;};Date.prototype.clone=function(){return new Date(this.getTime());};Date.prototype.compareTo=function(date){if(isNaN(this)){throw new Error(this);}
if(date instanceof Date&&!isNaN(date)){return(this>date)?1:(this<date)?-1:0;}else{throw new TypeError(date);}};Date.prototype.equals=function(date){return(this.compareTo(date)===0);};Date.prototype.between=function(start,end){var t=this.getTime();return t>=start.getTime()&&t<=end.getTime();};Date.prototype.addMilliseconds=function(value){this.setMilliseconds(this.getMilliseconds()+value);return this;};Date.prototype.addSeconds=function(value){return this.addMilliseconds(value*1000);};Date.prototype.addMinutes=function(value){return this.addMilliseconds(value*60000);};Date.prototype.addHours=function(value){return this.addMilliseconds(value*3600000);};Date.prototype.addDays=function(value){return this.addMilliseconds(value*86400000);};Date.prototype.addWeeks=function(value){return this.addMilliseconds(value*604800000);};Date.prototype.addMonths=function(value){var n=this.getDate();this.setDate(1);this.setMonth(this.getMonth()+value);this.setDate(Math.min(n,this.getDaysInMonth()));return this;};Date.prototype.addYears=function(value){return this.addMonths(value*12);};Date.prototype.add=function(config){if(typeof config=="number"){this._orient=config;return this;}
var x=config;if(x.millisecond||x.milliseconds){this.addMilliseconds(x.millisecond||x.milliseconds);}
if(x.second||x.seconds){this.addSeconds(x.second||x.seconds);}
if(x.minute||x.minutes){this.addMinutes(x.minute||x.minutes);}
if(x.hour||x.hours){this.addHours(x.hour||x.hours);}
if(x.month||x.months){this.addMonths(x.month||x.months);}
if(x.year||x.years){this.addYears(x.year||x.years);}
if(x.day||x.days){this.addDays(x.day||x.days);}
return this;};Date._validate=function(value,min,max,name){if(typeof value!="number"){throw new TypeError(value+" is not a Number.");}else if(value<min||value>max){throw new RangeError(value+" is not a valid value for "+name+".");}
return true;};Date.validateMillisecond=function(n){return Date._validate(n,0,999,"milliseconds");};Date.validateSecond=function(n){return Date._validate(n,0,59,"seconds");};Date.validateMinute=function(n){return Date._validate(n,0,59,"minutes");};Date.validateHour=function(n){return Date._validate(n,0,23,"hours");};Date.validateDay=function(n,year,month){return Date._validate(n,1,Date.getDaysInMonth(year,month),"days");};Date.validateMonth=function(n){return Date._validate(n,0,11,"months");};Date.validateYear=function(n){return Date._validate(n,1,9999,"seconds");};Date.prototype.set=function(config){var x=config;if(!x.millisecond&&x.millisecond!==0){x.millisecond=-1;}
if(!x.second&&x.second!==0){x.second=-1;}
if(!x.minute&&x.minute!==0){x.minute=-1;}
if(!x.hour&&x.hour!==0){x.hour=-1;}
if(!x.day&&x.day!==0){x.day=-1;}
if(!x.month&&x.month!==0){x.month=-1;}
if(!x.year&&x.year!==0){x.year=-1;}
if(x.millisecond!=-1&&Date.validateMillisecond(x.millisecond)){this.addMilliseconds(x.millisecond-this.getMilliseconds());}
if(x.second!=-1&&Date.validateSecond(x.second)){this.addSeconds(x.second-this.getSeconds());}
if(x.minute!=-1&&Date.validateMinute(x.minute)){this.addMinutes(x.minute-this.getMinutes());}
if(x.hour!=-1&&Date.validateHour(x.hour)){this.addHours(x.hour-this.getHours());}
if(x.month!==-1&&Date.validateMonth(x.month)){this.addMonths(x.month-this.getMonth());}
if(x.year!=-1&&Date.validateYear(x.year)){this.addYears(x.year-this.getFullYear());}
if(x.day!=-1&&Date.validateDay(x.day,this.getFullYear(),this.getMonth())){this.addDays(x.day-this.getDate());}
if(x.timezone){this.setTimezone(x.timezone);}
if(x.timezoneOffset){this.setTimezoneOffset(x.timezoneOffset);}
return this;};Date.prototype.clearTime=function(){this.setHours(0);this.setMinutes(0);this.setSeconds(0);this.setMilliseconds(0);return this;};Date.prototype.isLeapYear=function(){var y=this.getFullYear();return(((y%4===0)&&(y%100!==0))||(y%400===0));};Date.prototype.isWeekday=function(){return!(this.is().sat()||this.is().sun());};Date.prototype.getDaysInMonth=function(){return Date.getDaysInMonth(this.getFullYear(),this.getMonth());};Date.prototype.moveToFirstDayOfMonth=function(){return this.set({day:1});};Date.prototype.moveToLastDayOfMonth=function(){return this.set({day:this.getDaysInMonth()});};Date.prototype.moveToDayOfWeek=function(day,orient){var diff=(day-this.getDay()+7*(orient||+1))%7;return this.addDays((diff===0)?diff+=7*(orient||+1):diff);};Date.prototype.moveToMonth=function(month,orient){var diff=(month-this.getMonth()+12*(orient||+1))%12;return this.addMonths((diff===0)?diff+=12*(orient||+1):diff);};Date.prototype.getDayOfYear=function(){return Math.floor((this-new Date(this.getFullYear(),0,1))/86400000);};Date.prototype.getWeekOfYear=function(firstDayOfWeek){var y=this.getFullYear(),m=this.getMonth(),d=this.getDate();var dow=firstDayOfWeek||Date.CultureInfo.firstDayOfWeek;var offset=7+1-new Date(y,0,1).getDay();if(offset==8){offset=1;}
var daynum=((Date.UTC(y,m,d,0,0,0)-Date.UTC(y,0,1,0,0,0))/86400000)+1;var w=Math.floor((daynum-offset+7)/7);if(w===dow){y--;var prevOffset=7+1-new Date(y,0,1).getDay();if(prevOffset==2||prevOffset==8){w=53;}else{w=52;}}
return w;};Date.prototype.isDST=function(){console.log('isDST');return this.toString().match(/(E|C|M|P)(S|D)T/)[2]=="D";};Date.prototype.getTimezone=function(){return Date.getTimezoneAbbreviation(this.getUTCOffset,this.isDST());};Date.prototype.setTimezoneOffset=function(s){var here=this.getTimezoneOffset(),there=Number(s)*-6/10;this.addMinutes(there-here);return this;};Date.prototype.setTimezone=function(s){return this.setTimezoneOffset(Date.getTimezoneOffset(s));};Date.prototype.getUTCOffset=function(){var n=this.getTimezoneOffset()*-10/6,r;if(n<0){r=(n-10000).toString();return r[0]+r.substr(2);}else{r=(n+10000).toString();return"+"+r.substr(1);}};Date.prototype.getDayName=function(abbrev){return abbrev?Date.CultureInfo.abbreviatedDayNames[this.getDay()]:Date.CultureInfo.dayNames[this.getDay()];};Date.prototype.getMonthName=function(abbrev){return abbrev?Date.CultureInfo.abbreviatedMonthNames[this.getMonth()]:Date.CultureInfo.monthNames[this.getMonth()];};Date.prototype._toString=Date.prototype.toString;Date.prototype.toString=function(format){var self=this;var p=function p(s){return(s.toString().length==1)?"0"+s:s;};return format?format.replace(/dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?/g,function(format){switch(format){case"hh":return p(self.getHours()<13?self.getHours():(self.getHours()-12));case"h":return self.getHours()<13?self.getHours():(self.getHours()-12);case"HH":return p(self.getHours());case"H":return self.getHours();case"mm":return p(self.getMinutes());case"m":return self.getMinutes();case"ss":return p(self.getSeconds());case"s":return self.getSeconds();case"yyyy":return self.getFullYear();case"yy":return self.getFullYear().toString().substring(2,4);case"dddd":return self.getDayName();case"ddd":return self.getDayName(true);case"dd":return p(self.getDate());case"d":return self.getDate().toString();case"MMMM":return self.getMonthName();case"MMM":return self.getMonthName(true);case"MM":return p((self.getMonth()+1));case"M":return self.getMonth()+1;case"t":return self.getHours()<12?Date.CultureInfo.amDesignator.substring(0,1):Date.CultureInfo.pmDesignator.substring(0,1);case"tt":return self.getHours()<12?Date.CultureInfo.amDesignator:Date.CultureInfo.pmDesignator;case"zzz":case"zz":case"z":return"";}}):this._toString();};
Date.now=function(){return new Date();};Date.today=function(){return Date.now().clearTime();};Date.prototype._orient=+1;Date.prototype.next=function(){this._orient=+1;return this;};Date.prototype.last=Date.prototype.prev=Date.prototype.previous=function(){this._orient=-1;return this;};Date.prototype._is=false;Date.prototype.is=function(){this._is=true;return this;};Number.prototype._dateElement="day";Number.prototype.fromNow=function(){var c={};c[this._dateElement]=this;return Date.now().add(c);};Number.prototype.ago=function(){var c={};c[this._dateElement]=this*-1;return Date.now().add(c);};(function(){var $D=Date.prototype,$N=Number.prototype;var dx=("sunday monday tuesday wednesday thursday friday saturday").split(/\s/),mx=("january february march april may june july august september october november december").split(/\s/),px=("Millisecond Second Minute Hour Day Week Month Year").split(/\s/),de;var df=function(n){return function(){if(this._is){this._is=false;return this.getDay()==n;}
return this.moveToDayOfWeek(n,this._orient);};};for(var i=0;i<dx.length;i++){$D[dx[i]]=$D[dx[i].substring(0,3)]=df(i);}
var mf=function(n){return function(){if(this._is){this._is=false;return this.getMonth()===n;}
return this.moveToMonth(n,this._orient);};};for(var j=0;j<mx.length;j++){$D[mx[j]]=$D[mx[j].substring(0,3)]=mf(j);}
var ef=function(j){return function(){if(j.substring(j.length-1)!="s"){j+="s";}
return this["add"+j](this._orient);};};var nf=function(n){return function(){this._dateElement=n;return this;};};for(var k=0;k<px.length;k++){de=px[k].toLowerCase();$D[de]=$D[de+"s"]=ef(px[k]);$N[de]=$N[de+"s"]=nf(de);}}());Date.prototype.toJSONString=function(){return this.toString("yyyy-MM-ddThh:mm:ssZ");};Date.prototype.toShortDateString=function(){return this.toString(Date.CultureInfo.formatPatterns.shortDatePattern);};Date.prototype.toLongDateString=function(){return this.toString(Date.CultureInfo.formatPatterns.longDatePattern);};Date.prototype.toShortTimeString=function(){return this.toString(Date.CultureInfo.formatPatterns.shortTimePattern);};Date.prototype.toLongTimeString=function(){return this.toString(Date.CultureInfo.formatPatterns.longTimePattern);};Date.prototype.getOrdinal=function(){switch(this.getDate()){case 1:case 21:case 31:return"st";case 2:case 22:return"nd";case 3:case 23:return"rd";default:return"th";}};
(function(){Date.Parsing={Exception:function(s){this.message="Parse error at '"+s.substring(0,10)+" ...'";}};var $P=Date.Parsing;var _=$P.Operators={rtoken:function(r){return function(s){var mx=s.match(r);if(mx){return([mx[0],s.substring(mx[0].length)]);}else{throw new $P.Exception(s);}};},token:function(s){return function(s){return _.rtoken(new RegExp("^\s*"+s+"\s*"))(s);};},stoken:function(s){return _.rtoken(new RegExp("^"+s));},until:function(p){return function(s){var qx=[],rx=null;while(s.length){try{rx=p.call(this,s);}catch(e){qx.push(rx[0]);s=rx[1];continue;}
break;}
return[qx,s];};},many:function(p){return function(s){var rx=[],r=null;while(s.length){try{r=p.call(this,s);}catch(e){return[rx,s];}
rx.push(r[0]);s=r[1];}
return[rx,s];};},optional:function(p){return function(s){var r=null;try{r=p.call(this,s);}catch(e){return[null,s];}
return[r[0],r[1]];};},not:function(p){return function(s){try{p.call(this,s);}catch(e){return[null,s];}
throw new $P.Exception(s);};},ignore:function(p){return p?function(s){var r=null;r=p.call(this,s);return[null,r[1]];}:null;},product:function(){var px=arguments[0],qx=Array.prototype.slice.call(arguments,1),rx=[];for(var i=0;i<px.length;i++){rx.push(_.each(px[i],qx));}
return rx;},cache:function(rule){var cache={},r=null;return function(s){try{r=cache[s]=(cache[s]||rule.call(this,s));}catch(e){r=cache[s]=e;}
if(r instanceof $P.Exception){throw r;}else{return r;}};},any:function(){var px=arguments;return function(s){var r=null;for(var i=0;i<px.length;i++){if(px[i]==null){continue;}
try{r=(px[i].call(this,s));}catch(e){r=null;}
if(r){return r;}}
throw new $P.Exception(s);};},each:function(){var px=arguments;return function(s){var rx=[],r=null;for(var i=0;i<px.length;i++){if(px[i]==null){continue;}
try{r=(px[i].call(this,s));}catch(e){throw new $P.Exception(s);}
rx.push(r[0]);s=r[1];}
return[rx,s];};},all:function(){var px=arguments,_=_;return _.each(_.optional(px));},sequence:function(px,d,c){d=d||_.rtoken(/^\s*/);c=c||null;if(px.length==1){return px[0];}
return function(s){var r=null,q=null;var rx=[];for(var i=0;i<px.length;i++){try{r=px[i].call(this,s);}catch(e){break;}
rx.push(r[0]);try{q=d.call(this,r[1]);}catch(ex){q=null;break;}
s=q[1];}
if(!r){throw new $P.Exception(s);}
if(q){throw new $P.Exception(q[1]);}
if(c){try{r=c.call(this,r[1]);}catch(ey){throw new $P.Exception(r[1]);}}
return[rx,(r?r[1]:s)];};},between:function(d1,p,d2){d2=d2||d1;var _fn=_.each(_.ignore(d1),p,_.ignore(d2));return function(s){var rx=_fn.call(this,s);return[[rx[0][0],r[0][2]],rx[1]];};},list:function(p,d,c){d=d||_.rtoken(/^\s*/);c=c||null;return(p instanceof Array?_.each(_.product(p.slice(0,-1),_.ignore(d)),p.slice(-1),_.ignore(c)):_.each(_.many(_.each(p,_.ignore(d))),px,_.ignore(c)));},set:function(px,d,c){d=d||_.rtoken(/^\s*/);c=c||null;return function(s){var r=null,p=null,q=null,rx=null,best=[[],s],last=false;for(var i=0;i<px.length;i++){q=null;p=null;r=null;last=(px.length==1);try{r=px[i].call(this,s);}catch(e){continue;}
rx=[[r[0]],r[1]];if(r[1].length>0&&!last){try{q=d.call(this,r[1]);}catch(ex){last=true;}}else{last=true;}
if(!last&&q[1].length===0){last=true;}
if(!last){var qx=[];for(var j=0;j<px.length;j++){if(i!=j){qx.push(px[j]);}}
p=_.set(qx,d).call(this,q[1]);if(p[0].length>0){rx[0]=rx[0].concat(p[0]);rx[1]=p[1];}}
if(rx[1].length<best[1].length){best=rx;}
if(best[1].length===0){break;}}
if(best[0].length===0){return best;}
if(c){try{q=c.call(this,best[1]);}catch(ey){throw new $P.Exception(best[1]);}
best[1]=q[1];}
return best;};},forward:function(gr,fname){return function(s){return gr[fname].call(this,s);};},replace:function(rule,repl){return function(s){var r=rule.call(this,s);return[repl,r[1]];};},process:function(rule,fn){return function(s){var r=rule.call(this,s);return[fn.call(this,r[0]),r[1]];};},min:function(min,rule){return function(s){var rx=rule.call(this,s);if(rx[0].length<min){throw new $P.Exception(s);}
return rx;};}};var _generator=function(op){return function(){var args=null,rx=[];if(arguments.length>1){args=Array.prototype.slice.call(arguments);}else if(arguments[0]instanceof Array){args=arguments[0];}
if(args){for(var i=0,px=args.shift();i<px.length;i++){args.unshift(px[i]);rx.push(op.apply(null,args));args.shift();return rx;}}else{return op.apply(null,arguments);}};};var gx="optional not ignore cache".split(/\s/);for(var i=0;i<gx.length;i++){_[gx[i]]=_generator(_[gx[i]]);}
var _vector=function(op){return function(){if(arguments[0]instanceof Array){return op.apply(null,arguments[0]);}else{return op.apply(null,arguments);}};};var vx="each any all".split(/\s/);for(var j=0;j<vx.length;j++){_[vx[j]]=_vector(_[vx[j]]);}}());(function(){var flattenAndCompact=function(ax){var rx=[];for(var i=0;i<ax.length;i++){if(ax[i]instanceof Array){rx=rx.concat(flattenAndCompact(ax[i]));}else{if(ax[i]){rx.push(ax[i]);}}}
return rx;};Date.Grammar={};Date.Translator={hour:function(s){return function(){this.hour=Number(s);};},minute:function(s){return function(){this.minute=Number(s);};},second:function(s){return function(){this.second=Number(s);};},meridian:function(s){return function(){this.meridian=s.slice(0,1).toLowerCase();};},timezone:function(s){return function(){var n=s.replace(/[^\d\+\-]/g,"");if(n.length){this.timezoneOffset=Number(n);}else{this.timezone=s.toLowerCase();}};},day:function(x){var s=x[0];return function(){this.day=Number(s.match(/\d+/)[0]);};},month:function(s){return function(){this.month=((s.length==3)?Date.getMonthNumberFromName(s):(Number(s)-1));};},year:function(s){return function(){var n=Number(s);this.year=((s.length>2)?n:(n+(((n+2000)<Date.CultureInfo.twoDigitYearMax)?2000:1900)));};},rday:function(s){return function(){switch(s){case"yesterday":this.days=-1;break;case"tomorrow":this.days=1;break;case"today":this.days=0;break;case"now":this.days=0;this.now=true;break;}};},finishExact:function(x){x=(x instanceof Array)?x:[x];var now=new Date();this.year=now.getFullYear();this.month=now.getMonth();this.day=1;this.hour=0;this.minute=0;this.second=0;for(var i=0;i<x.length;i++){if(x[i]){x[i].call(this);}}
this.hour=(this.meridian=="p"&&this.hour<13)?this.hour+12:this.hour;if(this.day>Date.getDaysInMonth(this.year,this.month)){throw new RangeError(this.day+" is not a valid value for days.");}
var r=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second);if(this.timezone){r.set({timezone:this.timezone});}else if(this.timezoneOffset){r.set({timezoneOffset:this.timezoneOffset});}
return r;},finish:function(x){x=(x instanceof Array)?flattenAndCompact(x):[x];if(x.length===0){return null;}
for(var i=0;i<x.length;i++){if(typeof x[i]=="function"){x[i].call(this);}}
if(this.now){return new Date();}
var today=Date.today();var method=null;var expression=!!(this.days!=null||this.orient||this.operator);if(expression){var gap,mod,orient;orient=((this.orient=="past"||this.operator=="subtract")?-1:1);if(this.weekday){this.unit="day";gap=(Date.getDayNumberFromName(this.weekday)-today.getDay());mod=7;this.days=gap?((gap+(orient*mod))%mod):(orient*mod);}
if(this.month){this.unit="month";gap=(this.month-today.getMonth());mod=12;this.months=gap?((gap+(orient*mod))%mod):(orient*mod);this.month=null;}
if(!this.unit){this.unit="day";}
if(this[this.unit+"s"]==null||this.operator!=null){if(!this.value){this.value=1;}
if(this.unit=="week"){this.unit="day";this.value=this.value*7;}
this[this.unit+"s"]=this.value*orient;}
return today.add(this);}else{if(this.meridian&&this.hour){this.hour=(this.hour<13&&this.meridian=="p")?this.hour+12:this.hour;}
if(this.weekday&&!this.day){this.day=(today.addDays((Date.getDayNumberFromName(this.weekday)-today.getDay()))).getDate();}
if(this.month&&!this.day){this.day=1;}
return today.set(this);}}};var _=Date.Parsing.Operators,g=Date.Grammar,t=Date.Translator,_fn;g.datePartDelimiter=_.rtoken(/^([\s\-\.\,\/\x27]+)/);g.timePartDelimiter=_.stoken(":");g.whiteSpace=_.rtoken(/^\s*/);g.generalDelimiter=_.rtoken(/^(([\s\,]|at|on)+)/);var _C={};g.ctoken=function(keys){var fn=_C[keys];if(!fn){var c=Date.CultureInfo.regexPatterns;var kx=keys.split(/\s+/),px=[];for(var i=0;i<kx.length;i++){px.push(_.replace(_.rtoken(c[kx[i]]),kx[i]));}
fn=_C[keys]=_.any.apply(null,px);}
return fn;};g.ctoken2=function(key){return _.rtoken(Date.CultureInfo.regexPatterns[key]);};g.h=_.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2]|[1-9])/),t.hour));g.hh=_.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2])/),t.hour));g.H=_.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3]|[0-9])/),t.hour));g.HH=_.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3])/),t.hour));g.m=_.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/),t.minute));g.mm=_.cache(_.process(_.rtoken(/^[0-5][0-9]/),t.minute));g.s=_.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/),t.second));g.ss=_.cache(_.process(_.rtoken(/^[0-5][0-9]/),t.second));g.hms=_.cache(_.sequence([g.H,g.mm,g.ss],g.timePartDelimiter));g.t=_.cache(_.process(g.ctoken2("shortMeridian"),t.meridian));g.tt=_.cache(_.process(g.ctoken2("longMeridian"),t.meridian));g.z=_.cache(_.process(_.rtoken(/^(\+|\-)?\s*\d\d\d\d?/),t.timezone));g.zz=_.cache(_.process(_.rtoken(/^(\+|\-)\s*\d\d\d\d/),t.timezone));g.zzz=_.cache(_.process(g.ctoken2("timezone"),t.timezone));g.timeSuffix=_.each(_.ignore(g.whiteSpace),_.set([g.tt,g.zzz]));g.time=_.each(_.optional(_.ignore(_.stoken("T"))),g.hms,g.timeSuffix);g.d=_.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1]|\d)/),_.optional(g.ctoken2("ordinalSuffix"))),t.day));g.dd=_.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1])/),_.optional(g.ctoken2("ordinalSuffix"))),t.day));g.ddd=g.dddd=_.cache(_.process(g.ctoken("sun mon tue wed thu fri sat"),function(s){return function(){this.weekday=s;};}));g.M=_.cache(_.process(_.rtoken(/^(1[0-2]|0\d|\d)/),t.month));g.MM=_.cache(_.process(_.rtoken(/^(1[0-2]|0\d)/),t.month));g.MMM=g.MMMM=_.cache(_.process(g.ctoken("jan feb mar apr may jun jul aug sep oct nov dec"),t.month));g.y=_.cache(_.process(_.rtoken(/^(\d\d?)/),t.year));g.yy=_.cache(_.process(_.rtoken(/^(\d\d)/),t.year));g.yyy=_.cache(_.process(_.rtoken(/^(\d\d?\d?\d?)/),t.year));g.yyyy=_.cache(_.process(_.rtoken(/^(\d\d\d\d)/),t.year));_fn=function(){return _.each(_.any.apply(null,arguments),_.not(g.ctoken2("timeContext")));};g.day=_fn(g.d,g.dd);g.month=_fn(g.M,g.MMM);g.year=_fn(g.yyyy,g.yy);g.orientation=_.process(g.ctoken("past future"),function(s){return function(){this.orient=s;};});g.operator=_.process(g.ctoken("add subtract"),function(s){return function(){this.operator=s;};});g.rday=_.process(g.ctoken("yesterday tomorrow today now"),t.rday);g.unit=_.process(g.ctoken("minute hour day week month year"),function(s){return function(){this.unit=s;};});g.value=_.process(_.rtoken(/^\d\d?(st|nd|rd|th)?/),function(s){return function(){this.value=s.replace(/\D/g,"");};});g.expression=_.set([g.rday,g.operator,g.value,g.unit,g.orientation,g.ddd,g.MMM]);_fn=function(){return _.set(arguments,g.datePartDelimiter);};g.mdy=_fn(g.ddd,g.month,g.day,g.year);g.ymd=_fn(g.ddd,g.year,g.month,g.day);g.dmy=_fn(g.ddd,g.day,g.month,g.year);g.date=function(s){return((g[Date.CultureInfo.dateElementOrder]||g.mdy).call(this,s));};g.format=_.process(_.many(_.any(_.process(_.rtoken(/^(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?)/),function(fmt){if(g[fmt]){return g[fmt];}else{throw Date.Parsing.Exception(fmt);}}),_.process(_.rtoken(/^[^dMyhHmstz]+/),function(s){return _.ignore(_.stoken(s));}))),function(rules){return _.process(_.each.apply(null,rules),t.finishExact);});var _F={};var _get=function(f){return _F[f]=(_F[f]||g.format(f)[0]);};g.formats=function(fx){if(fx instanceof Array){var rx=[];for(var i=0;i<fx.length;i++){rx.push(_get(fx[i]));}
return _.any.apply(null,rx);}else{return _get(fx);}};g._formats=g.formats(["yyyy-MM-ddTHH:mm:ss","ddd, MMM dd, yyyy H:mm:ss tt","ddd MMM d yyyy HH:mm:ss zzz","d"]);g._start=_.process(_.set([g.date,g.time,g.expression],g.generalDelimiter,g.whiteSpace),t.finish);g.start=function(s){try{var r=g._formats.call({},s);if(r[1].length===0){return r;}}catch(e){}
return g._start.call({},s);};}());Date._parse=Date.parse;Date.parse=function(s){var r=null;if(!s){return null;}
try{r=Date.Grammar.start.call({},s);}catch(e){return null;}
return((r[1].length===0)?r[0]:null);};Date.getParseFunction=function(fx){var fn=Date.Grammar.formats(fx);return function(s){var r=null;try{r=fn.call({},s);}catch(e){return null;}
return((r[1].length===0)?r[0]:null);};};Date.parseExact=function(s,fx){return Date.getParseFunction(fx)(s);};
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else if (typeof self !== "undefined") {
        self.Q = definition();

    } else {
        throw new Error("This environment was not anticiapted by Q. Please file a bug.");
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;

    function flush() {
        /* jshint loopfunc: true */

        while (head.next) {
            head = head.next;
            var task = head.task;
            head.task = void 0;
            var domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }

            try {
                task();

            } catch (e) {
                if (isNodeJS) {
                    // In node, uncaught exceptions are considered fatal errors.
                    // Re-throw them synchronously to interrupt flushing!

                    // Ensure continuation if the uncaught exception is suppressed
                    // listening "uncaughtException" events (as domains does).
                    // Continue in next event to avoid tick recursion.
                    if (domain) {
                        domain.exit();
                    }
                    setTimeout(flush, 0);
                    if (domain) {
                        domain.enter();
                    }

                    throw e;

                } else {
                    // In browsers, uncaught exceptions are not fatal.
                    // Re-throw them asynchronously to avoid slow-downs.
                    setTimeout(function() {
                       throw e;
                    }, 0);
                }
            }

            if (domain) {
                domain.exit();
            }
        }

        flushing = false;
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process !== "undefined" && process.nextTick) {
        // Node.js before 0.9. Note that some fake-Node environments, like the
        // Mocha test runner, introduce a `process` global without a `nextTick`.
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }

    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you don’t need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Miller’s explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function(resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function(answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it’s a fulfilled promise, the fulfillment value is nearer.
 * If it’s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var countDown = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++countDown;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--countDown === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (countDown === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});
﻿//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

/*global window, require, define */
(function (_window) {
  'use strict';

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng, _mathRNG, _nodeRNG, _whatwgRNG, _previousRoot;

  function setupBrowser() {
    // Allow for MSIE11 msCrypto
    var _crypto = _window.crypto || _window.msCrypto;

    if (!_rng && _crypto && _crypto.getRandomValues) {
      // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
      //
      // Moderately fast, high quality
      try {
        var _rnds8 = new Uint8Array(16);
        _whatwgRNG = _rng = function whatwgRNG() {
          _crypto.getRandomValues(_rnds8);
          return _rnds8;
        };
        _rng();
      } catch (e) { }
    }

    if (!_rng) {
      // Math.random()-based (RNG)
      //
      // If all else fails, use Math.random().  It's fast, but is of unspecified
      // quality.
      var _rnds = new Array(16);
      _mathRNG = _rng = function () {
        for (var i = 0, r; i < 16; i++) {
          if ((i & 0x03) === 0) { r = Math.random() * 0x100000000; }
          _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
        }

        return _rnds;
      };
      if ('undefined' !== typeof console && console.warn) {
        console.warn("[SECURITY] node-uuid: crypto not usable, falling back to insecure Math.random()");
      }
    }
  }

  function setupNode() {
    // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
    //
    // Moderately fast, high quality
    if ('function' === typeof require) {
      try {
        var _rb = require('crypto').randomBytes;
        _nodeRNG = _rng = _rb && function () { return _rb(16); };
        _rng();
      } catch (e) { }
    }
  }

  if (_window) {
    setupBrowser();
  } else {
    setupNode();
  }

  // Buffer class to use
  var BufferClass = ('function' === typeof Buffer) ? Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function (oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = (options.clockseq != null) ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = (options.msecs != null) ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = (options.nsecs != null) ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs) / 10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof (options) === 'string') {
      buf = (options === 'binary') ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;
  uuid._rng = _rng;
  uuid._mathRNG = _mathRNG;
  uuid._nodeRNG = _nodeRNG;
  uuid._whatwgRNG = _whatwgRNG;

  if (('undefined' !== typeof module) && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else if (typeof define === 'function' && define.amd) {
    // Publish as AMD module
    define(function () { return uuid; });


  } else {
    // Publish as global (in browsers)
    _previousRoot = _window.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function () {
      _window.uuid = _previousRoot;
      return uuid;
    };

    _window.uuid = uuid;
  }
})('undefined' !== typeof window ? window : null);/*jslint browser: true, devel: true, bitwise: true, continue: true, evil: true, eqeq: true, forin: true, nomen: true, plusplus: true, regexp: true, sloppy: true, white: true */
/**
 * 
 * Find more about the scrolling function at
 * http://cubiq.org/iscroll
 *
 * Copyright (c) 2010 Matteo Spinelli, http://cubiq.org/
 * Released under MIT license
 * http://cubiq.org/dropbox/mit-license.txt
 * 
 * Version 3.7.1 - Last updated: 2010.10.08
 * 
 */
(function(){
	var has3d, isAndroid, isIthing, isTouch, START_EVENT, MOVE_EVENT, END_EVENT, translateOpen, translateClose, uid;
function iScroll (el, options) {
		var i, that;
		that = this;
	that.element = typeof el == 'object' ? el : document.getElementById(el);
	that.wrapper = that.element.parentNode;
	that.element.style.webkitTransitionProperty = '-webkit-transform';
	that.element.style.webkitTransitionTimingFunction = 'cubic-bezier(0,0,0.25,1)';
	that.element.style.webkitTransitionDuration = '0';
		that.element.style.webkitTransform = translateOpen + '0,0' + translateClose; // Default options
	that.options = {
		bounce: has3d,
		momentum: has3d,
		checkDOMChanges: true,
		topOnDOMChanges: false,
		hScrollbar: has3d,
		vScrollbar: has3d,
		fadeScrollbar: isIthing || !isTouch,
		shrinkScrollbar: isIthing || !isTouch,
		desktopCompatibility: false,
		overflow: 'auto',
		snap: false,
		bounceLock: false,
		scrollbarColor: 'rgba(0,0,0,0.5)',
		onScrollEnd: function () {}
		}; // User defined options
	if (typeof options == 'object') {
		for (i in options) {
			that.options[i] = options[i];
		}
	}
	if (that.options.desktopCompatibility) {
		that.options.overflow = 'hidden';
	}
	that.onScrollEnd = that.options.onScrollEnd;
	delete that.options.onScrollEnd;
	that.wrapper.style.overflow = that.options.overflow;
	that.refresh();
		window.addEventListener(window.hasOwnProperty('onorientationchange') ? 'orientationchange' : 'resize', that, false);
	if (isTouch || that.options.desktopCompatibility) {
		that.element.addEventListener(START_EVENT, that, false);
		that.element.addEventListener(MOVE_EVENT, that, false);
		that.element.addEventListener(END_EVENT, that, false);
	}
	if (that.options.checkDOMChanges) {
		that.element.addEventListener('DOMSubtreeModified', that, false);
	}
}
	function Scrollbar(dir, wrapper, fade, shrink, color) {
		var doc, that;
		that = this;
		doc = document;
		that.dir = dir;
		that.fade = fade;
		that.shrink = shrink;
		that.uid = ++uid; // Create main scrollbar
		that.bar = doc.createElement('div');
		that.bar.style.cssText = 'position:absolute;top:0;left:0;-webkit-transition-timing-function:cubic-bezier(0,0,0.25,1);pointer-events:none;-webkit-transition-duration:0;-webkit-transition-delay:0;-webkit-transition-property:-webkit-transform;z-index:10;background:' + color + ';' + '-webkit-transform:' + translateOpen + '0,0' + translateClose + ';' + (dir == 'horizontal' ? '-webkit-border-radius:3px 2px;min-width:6px;min-height:5px' : '-webkit-border-radius:2px 3px;min-width:5px;min-height:6px'); // Create scrollbar wrapper
		that.wrapper = doc.createElement('div');
		that.wrapper.style.cssText = '-webkit-mask:-webkit-canvas(scrollbar' + that.uid + that.dir + ');position:absolute;z-index:10;pointer-events:none;overflow:hidden;opacity:0;-webkit-transition-duration:' + (fade ? '300ms' : '0') + ';-webkit-transition-delay:0;-webkit-transition-property:opacity;' + (that.dir == 'horizontal' ? 'bottom:2px;left:2px;right:7px;height:5px' : 'top:2px;right:2px;bottom:7px;width:5px;'); // Add scrollbar to the DOM
		that.wrapper.appendChild(that.bar);
		wrapper.appendChild(that.wrapper);
	}

iScroll.prototype = {
	x: 0,
	y: 0,
	enabled: true,
	handleEvent: function (e) {
		var that = this;
		switch (e.type) {
			case START_EVENT:
				that.touchStart(e);
				break;
			case MOVE_EVENT:
				that.touchMove(e);
				break;
			case END_EVENT:
				that.touchEnd(e);
				break;
			case 'webkitTransitionEnd':
				that.transitionEnd();
				break;
			case 'orientationchange':
			case 'resize':
				if (isAndroid) {																					// JOOLS
					window.setTimeout(function() {
						that.refresh();
					}, 200); // Android workaround
				} else {
					that.refresh();
				}
				break;
			case 'DOMSubtreeModified':
				that.onDOMModified(e);
				break;
		}
	},
	onDOMModified: function (e) {
			var that = this; // (Hopefully) execute onDOMModified only once
		if (e.target.parentNode != that.element) {
			return;
		}
			setTimeout(function() {
				that.refresh();
			}, 0);
		if (that.options.topOnDOMChanges && (that.x!=0 || that.y!=0)) {
			that.scrollTo(0,0,'0');
		}
	},
	refresh: function () {
			var resetX, resetY, snap, that;
			that = this;
			resetX = that.x;
			resetY = that.y;
		that.scrollWidth = that.wrapper.clientWidth;
		that.scrollHeight = that.wrapper.clientHeight;
		that.scrollerWidth = that.element.offsetWidth;
		that.scrollerHeight = that.element.offsetHeight;
		that.maxScrollX = that.scrollWidth - that.scrollerWidth;
		that.maxScrollY = that.scrollHeight - that.scrollerHeight;
		that.directionX = 0;
		that.directionY = 0;
		if (that.scrollX) {
			if (that.maxScrollX >= 0) {
				resetX = 0;
			} else if (that.x < that.maxScrollX) {
				resetX = that.maxScrollX;
			}
		}
		if (that.scrollY) {
			if (that.maxScrollY >= 0) {
				resetY = 0;
			} else if (that.y < that.maxScrollY) {
				resetY = that.maxScrollY;
			}
			} // Snap
		if (that.options.snap) {
			that.maxPageX = -Math.floor(that.maxScrollX/that.scrollWidth);
			that.maxPageY = -Math.floor(that.maxScrollY/that.scrollHeight);
			snap = that.snap(resetX, resetY);
			resetX = snap.x;
			resetY = snap.y;
		}
		if (resetX!=that.x || resetY!=that.y) {
			that.setTransitionTime('0');
			that.setPosition(resetX, resetY, true);
		}
		that.scrollX = that.scrollerWidth > that.scrollWidth;
			that.scrollY = (!that.options.bounceLock && !that.scrollX) || that.scrollerHeight > that.scrollHeight; // Update horizontal scrollbar
		if (that.options.hScrollbar && that.scrollX) {
				that.scrollBarX = that.scrollBarX || new Scrollbar('horizontal', that.wrapper, that.options.fadeScrollbar, that.options.shrinkScrollbar, that.options.scrollbarColor);
			that.scrollBarX.init(that.scrollWidth, that.scrollerWidth);
		} else if (that.scrollBarX) {
			that.scrollBarX = that.scrollBarX.remove();
			} // Update vertical scrollbar
		if (that.options.vScrollbar && that.scrollY && that.scrollerHeight > that.scrollHeight) {
				that.scrollBarY = that.scrollBarY || new Scrollbar('vertical', that.wrapper, that.options.fadeScrollbar, that.options.shrinkScrollbar, that.options.scrollbarColor);
			that.scrollBarY.init(that.scrollHeight, that.scrollerHeight);
		} else if (that.scrollBarY) {
			that.scrollBarY = that.scrollBarY.remove();
		}
	},
	setPosition: function (x, y, hideScrollBars) {
		var that = this;
		that.x = x;
		that.y = y;
			that.element.style.webkitTransform = translateOpen + that.x + 'px,' + that.y + 'px' + translateClose; // Move the scrollbars
		if (!hideScrollBars) {
			if (that.scrollBarX) {
				that.scrollBarX.setPosition(that.x);
			}
			if (that.scrollBarY) {
				that.scrollBarY.setPosition(that.y);
			}
		}
	},
	setTransitionTime: function(time) {
		var that = this;
		time = time || '0';
		that.element.style.webkitTransitionDuration = time;
		if (that.scrollBarX) {
			that.scrollBarX.bar.style.webkitTransitionDuration = time;
			that.scrollBarX.wrapper.style.webkitTransitionDuration = has3d && that.options.fadeScrollbar ? '300ms' : '0';
		}
		if (that.scrollBarY) {
			that.scrollBarY.bar.style.webkitTransitionDuration = time;
			that.scrollBarY.wrapper.style.webkitTransitionDuration = has3d && that.options.fadeScrollbar ? '300ms' : '0';
		}
	},
	touchStart: function(e) {
			var matrix, that;
			that = this;
		if (!that.enabled) {
			return;
			} //e.preventDefault();	JOOLS COMMENTED OUT
		e.stopPropagation();
		that.scrolling = true;		// This is probably not needed, but may be useful if iScroll is used in conjuction with other frameworks
		that.moved = false;
		that.distX = 0;
		that.distY = 0;
			that.setTransitionTime('0'); // Check if the scroller is really where it should be
		if (that.options.momentum || that.options.snap) {
				matrix = new window.WebKitCSSMatrix(window.getComputedStyle(that.element).webkitTransform);
			if (matrix.e != that.x || matrix.f != that.y) {
				document.removeEventListener('webkitTransitionEnd', that, false);
				that.setPosition(matrix.e, matrix.f);
				that.moved = true;
			}
		}
		that.touchStartX = isTouch ? e.changedTouches[0].pageX : e.pageX;
		that.scrollStartX = that.x;
		that.touchStartY = isTouch ? e.changedTouches[0].pageY : e.pageY;
		that.scrollStartY = that.y;
		that.scrollStartTime = e.timeStamp;
		that.directionX = 0;
		that.directionY = 0;
	},
	touchMove: function(e) {
			var leftDelta, newX, newY, pageX, pageY, that, topDelta;
		if (!this.scrolling) {
			return;
		}
			that = this;
			pageX = isTouch ? e.changedTouches[0].pageX : e.pageX;
			pageY = isTouch ? e.changedTouches[0].pageY : e.pageY;
			leftDelta = that.scrollX ? pageX - that.touchStartX : 0;
			topDelta = that.scrollY ? pageY - that.touchStartY : 0;
			newX = that.x + leftDelta;
			newY = that.y + topDelta;
		e.preventDefault();	// JOOLS UNCOMMENTED OUT
		e.stopPropagation();	// Stopping propagation just saves some cpu cycles (I presume)
		that.touchStartX = pageX;
			that.touchStartY = pageY; // Slow down if outside of the boundaries
		if (newX >= 0 || newX < that.maxScrollX) {
			newX = that.options.bounce ? Math.round(that.x + leftDelta / 3) : (newX >= 0 || that.maxScrollX>=0) ? 0 : that.maxScrollX;
		}
		if (newY >= 0 || newY < that.maxScrollY) { 
			newY = that.options.bounce ? Math.round(that.y + topDelta / 3) : (newY >= 0 || that.maxScrollY>=0) ? 0 : that.maxScrollY;
		}
		if (that.distX + that.distY > 5) {			// 5 pixels threshold
			// Lock scroll direction
			if (that.distX-3 > that.distY) {
				newY = that.y;
				topDelta = 0;
			} else if (that.distY-3 > that.distX) {
				newX = that.x;
				leftDelta = 0;
			}
			that.setPosition(newX, newY);
			that.moved = true;
			that.directionX = leftDelta > 0 ? -1 : 1;
			that.directionY = topDelta > 0 ? -1 : 1;
		} else {
			that.distX+= Math.abs(leftDelta);
				that.distY += Math.abs(topDelta); //			that.dist+= Math.abs(leftDelta) + Math.abs(topDelta);
		}
	},
	touchEnd: function(e) {
			var momentumX, momentumY, newDuration, newPositionX, newPositionY, point, snap, that, time;
		if (!this.scrolling) {
			return;
		}
			that = this;
			time = e.timeStamp - that.scrollStartTime;
			point = isTouch ? e.changedTouches[0] : e;
			newDuration = 0;
			newPositionX = that.x;
			newPositionY = that.y;
		that.scrolling = false;
		if (!that.moved) {
			that.resetPosition();
			return;
		}
		if (!that.options.snap && time > 250) {			// Prevent slingshot effect
			that.resetPosition();
			return;
		}
		if (that.options.momentum) {
				momentumX = that.scrollX === true ? that.momentum(that.x - that.scrollStartX, time, that.options.bounce ? -that.x + that.scrollWidth / 5 : -that.x, that.options.bounce ? that.x + that.scrollerWidth - that.scrollWidth + that.scrollWidth / 5 : that.x + that.scrollerWidth - that.scrollWidth) : {
					dist: 0,
					time: 0
				};
				momentumY = that.scrollY === true ? that.momentum(that.y - that.scrollStartY, time, that.options.bounce ? -that.y + that.scrollHeight / 5 : -that.y, that.options.bounce ? (that.maxScrollY < 0 ? that.y + that.scrollerHeight - that.scrollHeight : 0) + that.scrollHeight / 5 : that.y + that.scrollerHeight - that.scrollHeight) : {
					dist: 0,
					time: 0
				};
			newDuration = Math.max(Math.max(momentumX.time, momentumY.time), 1);		// The minimum animation length must be 1ms
			newPositionX = that.x + momentumX.dist;
			newPositionY = that.y + momentumY.dist;
		}
		if (that.options.snap) {
			snap = that.snap(newPositionX, newPositionY);
			newPositionX = snap.x;
			newPositionY = snap.y;
			newDuration = Math.max(snap.time, newDuration);
		}
		that.scrollTo(newPositionX, newPositionY, newDuration + 'ms');
	},
	transitionEnd: function () {
		var that = this;
		document.removeEventListener('webkitTransitionEnd', that, false);
		that.resetPosition();
	},
	resetPosition: function () {
			var resetX, resetY, that;
			that = this;
			resetX = that.x;
		 	resetY = that.y;
		if (that.x >= 0) {
			resetX = 0;
		} else if (that.x < that.maxScrollX) {
			resetX = that.maxScrollX;
		}
		if (that.y >= 0 || that.maxScrollY > 0) {
			resetY = 0;
		} else if (that.y < that.maxScrollY) {
			resetY = that.maxScrollY;
		}
		if (resetX != that.x || resetY != that.y) {
			that.scrollTo(resetX, resetY);
		} else {
			if (that.moved) {
				that.onScrollEnd();		// Execute custom code on scroll end
				that.moved = false;
				} // Hide the scrollbars
			if (that.scrollBarX) {
				that.scrollBarX.hide();
			}
			if (that.scrollBarY) {
				that.scrollBarY.hide();
			}
		}
	},
	snap: function (x, y) {
			var that, time;
			that = this;
		if (that.directionX > 0) {
			x = Math.floor(x/that.scrollWidth);
		} else if (that.directionX < 0) {
			x = Math.ceil(x/that.scrollWidth);
		} else {
			x = Math.round(x/that.scrollWidth);
		}
		that.pageX = -x;
		x = x * that.scrollWidth;
		if (x > 0) {
			x = that.pageX = 0;
		} else if (x < that.maxScrollX) {
			that.pageX = that.maxPageX;
			x = that.maxScrollX;
		}
		if (that.directionY > 0) {
			y = Math.floor(y/that.scrollHeight);
		} else if (that.directionY < 0) {
			y = Math.ceil(y/that.scrollHeight);
		} else {
			y = Math.round(y/that.scrollHeight);
		}
		that.pageY = -y;
		y = y * that.scrollHeight;
		if (y > 0) {
			y = that.pageY = 0;
		} else if (y < that.maxScrollY) {
			that.pageY = that.maxPageY;
			y = that.maxScrollY;
			} // Snap with constant speed (proportional duration)
			time = Math.round(Math.max(Math.abs(that.x - x) / that.scrollWidth * 500, Math.abs(that.y - y) / that.scrollHeight * 500));
			return {
				x: x,
				y: y,
				time: time
			};
	},
	scrollTo: function (destX, destY, runtime) {
		var that = this;
		if (that.x == destX && that.y == destY) {
			that.resetPosition();
			return;
		}
		that.moved = true;
		that.setTransitionTime(runtime || '350ms');
		that.setPosition(destX, destY);
		if (runtime==='0' || runtime=='0s' || runtime=='0ms') {
			that.resetPosition();
		} else {
			document.addEventListener('webkitTransitionEnd', that, false);	// At the end of the transition check if we are still inside of the boundaries
		}
	},
	scrollToPage: function (pageX, pageY, runtime) {
			var snap, that;
			that = this;
		if (!that.options.snap) {
			that.pageX = -Math.round(that.x / that.scrollWidth);
			that.pageY = -Math.round(that.y / that.scrollHeight);
		}
		if (pageX == 'next') {
			pageX = ++that.pageX;
		} else if (pageX == 'prev') {
			pageX = --that.pageX;
		}
		if (pageY == 'next') {
			pageY = ++that.pageY;
		} else if (pageY == 'prev') {
			pageY = --that.pageY;
		}
		pageX = -pageX*that.scrollWidth;
		pageY = -pageY*that.scrollHeight;
		snap = that.snap(pageX, pageY);
		pageX = snap.x;
		pageY = snap.y;
		that.scrollTo(pageX, pageY, runtime || '500ms');
	},
	scrollToElement: function (el, runtime) {
			var that, x, y;
		el = typeof el == 'object' ? el : this.element.querySelector(el);
		if (!el) {
			return;
		}
			that = this;
			x = that.scrollX ? -el.offsetLeft : 0;
			y = that.scrollY ? -el.offsetTop : 0;
		if (x >= 0) {
			x = 0;
		} else if (x < that.maxScrollX) {
			x = that.maxScrollX;
		}
		if (y >= 0) {
			y = 0;
		} else if (y < that.maxScrollY) {
			y = that.maxScrollY;
		}
		that.scrollTo(x, y, runtime);
	},
	momentum: function (dist, time, maxDistUpper, maxDistLower) {
			var deceleration, friction, newDist, newTime, speed;
			friction = 2.5;
			deceleration = 1.2;
			speed = Math.abs(dist) / time * 1000;
			newDist = speed * speed / friction / 1000;
			newTime = 0; // Proportinally reduce speed if we are outside of the boundaries 
		if (dist > 0 && newDist > maxDistUpper) {
			speed = speed * maxDistUpper / newDist / friction;
			newDist = maxDistUpper;
		} else if (dist < 0 && newDist > maxDistLower) {
			speed = speed * maxDistLower / newDist / friction;
			newDist = maxDistLower;
		}
		newDist = newDist * (dist < 0 ? -1 : 1);
		newTime = speed / deceleration;
			return {
				dist: Math.round(newDist),
				time: Math.round(newTime)
			};
	},
	destroy: function (full) {
		var that = this;
			window.removeEventListener(window.hasOwnProperty('onorientationchange') ? 'orientationchange' : 'resize', that, false);
		that.element.removeEventListener(START_EVENT, that, false);
		that.element.removeEventListener(MOVE_EVENT, that, false);
		that.element.removeEventListener(END_EVENT, that, false);
		document.removeEventListener('webkitTransitionEnd', that, false);
		if (that.options.checkDOMChanges) {
			that.element.removeEventListener('DOMSubtreeModified', that, false);
		}
		if (that.scrollBarX) {
			that.scrollBarX = that.scrollBarX.remove();
		}
		if (that.scrollBarY) {
			that.scrollBarY = that.scrollBarY.remove();
		}
		if (full) {
			that.wrapper.parentNode.removeChild(that.wrapper);
		}
		return null;
	}
};

	Scrollbar.prototype = {
	init: function (scroll, size) {
			var ctx, doc, pi, that;
			that = this;
			doc = document;
			pi = Math.PI;
		if (that.dir == 'horizontal') {
			if (that.maxSize != that.wrapper.offsetWidth) {
				that.maxSize = that.wrapper.offsetWidth;
				ctx = doc.getCSSCanvasContext("2d", "scrollbar" + that.uid + that.dir, that.maxSize, 5);
				ctx.fillStyle = "rgb(0,0,0)";
				ctx.beginPath();
				ctx.arc(2.5, 2.5, 2.5, pi/2, -pi/2, false);
				ctx.lineTo(that.maxSize-2.5, 0);
				ctx.arc(that.maxSize-2.5, 2.5, 2.5, -pi/2, pi/2, false);
				ctx.closePath();
				ctx.fill();
			}
		} else {
			if (that.maxSize != that.wrapper.offsetHeight) {
				that.maxSize = that.wrapper.offsetHeight;
				ctx = doc.getCSSCanvasContext("2d", "scrollbar" + that.uid + that.dir, 5, that.maxSize);
				ctx.fillStyle = "rgb(0,0,0)";
				ctx.beginPath();
				ctx.arc(2.5, 2.5, 2.5, pi, 0, false);
				ctx.lineTo(5, that.maxSize-2.5);
				ctx.arc(2.5, that.maxSize-2.5, 2.5, 0, pi, false);
				ctx.closePath();
				ctx.fill();
			}
		}
		that.size = Math.max(Math.round(that.maxSize * that.maxSize / size), 6);
		that.maxScroll = that.maxSize - that.size;
		that.toWrapperProp = that.maxScroll / (scroll - size);
		that.bar.style[that.dir == 'horizontal' ? 'width' : 'height'] = that.size + 'px';
	},
	setPosition: function (pos) {
		var that = this;
		if (that.wrapper.style.opacity != '1') {
			that.show();
		}
		pos = Math.round(that.toWrapperProp * pos);
		if (pos < 0) {
			pos = that.shrink ? pos + pos*3 : 0;
			if (that.size + pos < 7) {
				pos = -that.size + 6;
			}
		} else if (pos > that.maxScroll) {
			pos = that.shrink ? pos + (pos-that.maxScroll)*3 : that.maxScroll;
			if (that.size + that.maxScroll - pos < 7) {
				pos = that.size + that.maxScroll - 6;
			}
		}
			pos = that.dir == 'horizontal' ? translateOpen + pos + 'px,0' + translateClose : translateOpen + '0,' + pos + 'px' + translateClose;
		that.bar.style.webkitTransform = pos;
	},
	show: function () {
		if (has3d) {
			this.wrapper.style.webkitTransitionDelay = '0';
		}
		this.wrapper.style.opacity = '1';
	},
	hide: function () {
		if (has3d) {
			this.wrapper.style.webkitTransitionDelay = '350ms';
		}
		this.wrapper.style.opacity = '0';
	},
	remove: function () {
		this.wrapper.parentNode.removeChild(this.wrapper);
		return null;
	}
};

// Is translate3d compatible?
	has3d = (window.hasOwnProperty('WebKitCSSMatrix') && (new window.WebKitCSSMatrix()).hasOwnProperty('m11'));
	// Device sniffing
	isAndroid = (/android/gi).test(window.navigator.appVersion) && !(/msie/gi).test(window.navigator.appVersion) && !(/windows/gi).test(window.navigator.appVersion);
	// JOOLS
	isIthing = (/iphone|ipad/gi).test(navigator.appVersion);
	isWp8 = (/msie/gi).test(window.navigator.appVersion);
	isTouch = 'ontouchstart' in document.documentElement;
	// Event sniffing
	START_EVENT = isTouch ? 'touchstart' : 'mousedown';
	MOVE_EVENT = isTouch ? 'touchmove' : 'mousemove';
	END_EVENT = isTouch ? 'touchend' : 'mouseup';
	// Translate3d helper
	translateOpen = 'translate' + (has3d ? '3d(' : '(');
	translateClose = has3d ? ',0)' : ')';
	// Unique ID
	uid = 0; // Expose iScroll to the world
window.iScroll = iScroll;
}());
/*jslint browser: true, devel: true, bitwise: true, continue: true, evil: true, eqeq: true, forin: true, nomen: true, plusplus: true, regexp: true, sloppy: true, white: true */
/**
 * 
 * Find more about the Spinning Wheel function at
 * http://cubiq.org/spinning-wheel-on-webkit-for-iphone-ipod-touch/11
 *
 * Copyright (c) 2009 Matteo Spinelli, http://cubiq.org/
 * Released under MIT license
 * http://cubiq.org/dropbox/mit-license.txt
 * 
 * Version 1.4 - Last updated: 2009.07.09
 *
 * Update by Jools - 2010.10.27
 *	Added 'click' support for Cancel & Done buttons for non-touch browsers
 *
 * Update by Jools - 2010.12.08
 *  Added mouse event support to spinning wheels
 */

var SpinningWheel = {
	cellHeight: 44,
	friction: 0.003,
	slotData: [],
	evtStart: window.hasOwnProperty('ontouchstart') ? 'touchstart' : 'mousedown',
	evtMove: window.hasOwnProperty('ontouchstart') ? 'touchmove' : 'mousemove',
	evtEnd: window.hasOwnProperty('ontouchstart') ? 'touchend' : 'mouseup',

	mouseToTouch: function (e) {
		if (!e.targetTouches) {
			e.targetTouches = [{
				clientX: e.clientX,
				clientY: e.clientY
			}];
		}
	},

	/**
	 *
	 * Event handler
	 *
	 */

	handleEvent: function (e) {
		var target;
		if (e.type === this.evtStart && e.currentTarget === document) {
			target = e.target.nodeType === 1 ? e.target : e.target.parentElement;
			if (!target.id || target.id.slice(0, 3) !== 'sw-') {
				this.done();	// Execute the done action when tapped away from spinning wheel
			}
		}
		if (e.type == this.evtStart) {
			this.lockScreen(e);
			if (e.currentTarget.id == 'sw-cancel' || e.currentTarget.id == 'sw-done') {
				this.tapDown(e);
			} else if (e.currentTarget.id == 'sw-frame') {
				this.scrollStart(e);
			}
		} else if (e.type == this.evtMove) {
			this.lockScreen(e);
			
			if (e.currentTarget.id == 'sw-cancel' || e.currentTarget.id == 'sw-done') {
				this.tapCancel(e);
			} else if (e.currentTarget.id == 'sw-frame') {
				this.scrollMove(e);
			}
		} else if (e.type == this.evtEnd || e.type == 'click') {
			if (e.currentTarget.id == 'sw-cancel' || e.currentTarget.id == 'sw-done') {
				this.tapUp(e);
			} else if (e.currentTarget.id == 'sw-frame') {
				this.scrollEnd(e);
			}
		} else if (e.type == 'webkitTransitionEnd') {
			if (e.target.id == 'sw-wrapper') {
				this.destroy();
			} else {
				this.backWithinBoundaries(e);
			}
		} else if (e.type == 'orientationchange') {
			this.onOrientationChange(e);
		} else if (e.type == 'scroll') {
			this.onScroll(e);
		}
	},


	/**
	 *
	 * Global events
	 *
	 */

	onOrientationChange: function () {
		window.scrollTo(0, 0);
		this.swWrapper.style.top = window.innerHeight + window.pageYOffset + 'px';
		this.calculateSlotsWidth();
	},
	
	onScroll: function () {
		this.swWrapper.style.top = window.innerHeight + window.pageYOffset + 'px';
	},

	lockScreen: function () {
/*
		e.preventDefault();
		e.stopPropagation();
*/
	},


	/**
	 *
	 * Initialization
	 *
	 */

	reset: function () {
		this.slotEl = [];

		this.activeSlot = null;
		
		this.swWrapper = undefined;
		this.swSlotWrapper = undefined;
		this.swSlots = undefined;
		this.swFrame = undefined;
	},

	calculateSlotsWidth: function () {
		var div, i;
		div = this.swSlots.getElementsByTagName('div');
		for (i = 0; i < div.length; i += 1) {
			this.slotEl[i].slotWidth = div[i].offsetWidth;
		}
	},

	create: function () {
		var i, l, out, ul, div;

		this.reset();	// Initialize object variables

		// Create the Spinning Wheel main wrapper
		div = document.createElement('div');
		div.id = 'sw-wrapper';
		div.style.top = window.innerHeight + window.pageYOffset + 'px';		// Place the SW down the actual viewing screen
		div.style.webkitTransitionProperty = '-webkit-transform';
		div.innerHTML = '<div id="sw-header"><div id="sw-cancel">Cancel</' + 'div><div id="sw-done">Done</' + 'div></' + 'div><div id="sw-slots-wrapper"><div id="sw-slots"></' + 'div></' + 'div><div id="sw-frame"></' + 'div>';

		document.body.appendChild(div);

		this.swWrapper = div;													// The SW wrapper
		this.swSlotWrapper = document.getElementById('sw-slots-wrapper');		// Slots visible area
		this.swSlots = document.getElementById('sw-slots');						// Pseudo table element (inner wrapper)
		this.swFrame = document.getElementById('sw-frame');						// The scrolling controller

		// Create HTML slot elements
		for (l = 0; l < this.slotData.length; l += 1) {
			// Create the slot
			ul = document.createElement('ul');
			out = '';
			for (i in this.slotData[l].values) {
				out += '<li>' + this.slotData[l].values[i] + '<' + '/li>';
			}
			ul.innerHTML = out;

			div = document.createElement('div');		// Create slot container
			div.className = this.slotData[l].style;		// Add styles to the container
			div.appendChild(ul);
	
			// Append the slot to the wrapper
			this.swSlots.appendChild(div);
			
			ul.slotPosition = l;			// Save the slot position inside the wrapper
			ul.slotYPosition = 0;
			ul.slotWidth = 0;
			ul.slotMaxScroll = this.swSlotWrapper.clientHeight - ul.clientHeight - 86;
			ul.style.webkitTransitionTimingFunction = 'cubic-bezier(0, 0, 0.2, 1)';		// Add default transition
			
			this.slotEl.push(ul);			// Save the slot for later use
			
			// Place the slot to its default position (if other than 0)
			if (this.slotData[l].defaultValue) {
				this.scrollToValue(l, this.slotData[l].defaultValue);	
			}
		}
		
		this.calculateSlotsWidth();
		
		// Global events
		document.addEventListener(this.evtStart, this, true);			// Prevent page scrolling
		document.addEventListener(this.evtMove, this, false);			// Prevent page scrolling
		window.addEventListener('orientationchange', this, true);		// Optimize SW on orientation change
		window.addEventListener('scroll', this, true);				// Reposition SW on page scroll

		// Cancel/Done buttons events
		if (window.hasOwnProperty('ontouchstart')) {
			document.getElementById('sw-cancel').addEventListener(this.evtStart, this, false);
			document.getElementById('sw-done').addEventListener(this.evtStart, this, false);
		} else {
			document.getElementById('sw-cancel').addEventListener('click', this, false);
			document.getElementById('sw-done').addEventListener('click', this, false);
		}

		// Add scrolling to the slots
		this.swFrame.addEventListener(this.evtStart, this, false);
	},

	open: function () {
		this.create();

		this.swWrapper.style.webkitTransitionTimingFunction = 'ease-out';
		this.swWrapper.style.webkitTransitionDuration = '400ms';
		this.swWrapper.style.webkitTransform = 'translate3d(0, -260px, 0)';
	},
	
	
	/**
	 *
	 * Unload
	 *
	 */

	destroy: function () {
		this.swWrapper.removeEventListener('webkitTransitionEnd', this, false);

		this.swFrame.removeEventListener(this.evtStart, this, false);

		document.getElementById('sw-cancel').removeEventListener(this.evtStart, this, false);
		document.getElementById('sw-done').removeEventListener(this.evtStart, this, false);
		if (!(window.hasOwnProperty('ontouchstart'))) {
			document.getElementById('sw-cancel').removeEventListener('click', this, false);
			document.getElementById('sw-done').removeEventListener('click', this, false);
		}

		document.removeEventListener(this.evtStart, this, true);
		document.removeEventListener(this.evtMove, this, false);
		window.removeEventListener('orientationchange', this, true);
		window.removeEventListener('scroll', this, true);
		
		this.slotData = [];
		this.cancelAction = function () {
			return false;
		};
		
		this.cancelDone = function () {
			return true;
		};
		
		this.reset();
		
		document.body.removeChild(document.getElementById('sw-wrapper'));
	},
	
	close: function () {
		this.swWrapper.style.webkitTransitionTimingFunction = 'ease-in';
		this.swWrapper.style.webkitTransitionDuration = '400ms';
		this.swWrapper.style.webkitTransform = 'translate3d(0, 0, 0)';
		
		this.swWrapper.addEventListener('webkitTransitionEnd', this, false);
	},


	/**
	 *
	 * Generic methods
	 *
	 */

	addSlot: function (values, style, defaultValue) {
		var i, obj;
		if (!style) {
			style = '';
		}
		
		style = style.split(' ');

		for (i = 0; i < style.length; i += 1) {
			style[i] = 'sw-' + style[i];
		}
		
		style = style.join(' ');

		obj = { 'values': values, 'style': style, 'defaultValue': defaultValue };
		this.slotData.push(obj);
	},

	getSelectedValues: function () {
		var index, count,
		    i, l,
			keys = [], values = [];

		for (i in this.slotEl) {
			// Remove any residual animation
			this.slotEl[i].removeEventListener('webkitTransitionEnd', this, false);
			this.slotEl[i].style.webkitTransitionDuration = '0';

			if (this.slotEl[i].slotYPosition > 0) {
				this.setPosition(i, 0);
			} else if (this.slotEl[i].slotYPosition < this.slotEl[i].slotMaxScroll) {
				this.setPosition(i, this.slotEl[i].slotMaxScroll);
			}

			index = -Math.round(this.slotEl[i].slotYPosition / this.cellHeight);

			count = 0;
			for (l in this.slotData[i].values) {
				if (count == index) {
					keys.push(l);
					values.push(this.slotData[i].values[l]);
					break;
				}
				
				count += 1;
			}
		}

		return { 'keys': keys, 'values': values };
	},


	/**
	 *
	 * Rolling slots
	 *
	 */

	setPosition: function (slot, pos) {
		this.slotEl[slot].slotYPosition = pos;
		this.slotEl[slot].style.webkitTransform = 'translate3d(0, ' + pos + 'px, 0)';
	},
	
	scrollStart: function (e) {
		var i, slot, theTransform, xPos;
		this.mouseToTouch(e);
	
		// Find the clicked slot
		xPos = e.targetTouches[0].clientX - this.swSlots.offsetLeft;	// Clicked position minus left offset (should be 11px)

		// Find tapped slot
		slot = 0;
		for (i = 0; i < this.slotEl.length; i += 1) {
			slot += this.slotEl[i].slotWidth;
			
			if (xPos < slot) {
				this.activeSlot = i;
				break;
			}
		}

		// If slot is readonly do nothing
		if (this.slotData[this.activeSlot].style.match('readonly')) {
			this.swFrame.removeEventListener(this.evtMove, this, false);
			this.swFrame.removeEventListener(this.evtEnd, this, false);
			return false;
		}

		this.slotEl[this.activeSlot].removeEventListener('webkitTransitionEnd', this, false);	// Remove transition event (if any)
		this.slotEl[this.activeSlot].style.webkitTransitionDuration = '0';		// Remove any residual transition
		
		// Stop and hold slot position
		theTransform = window.getComputedStyle(this.slotEl[this.activeSlot]).webkitTransform;
		theTransform = new window.WebKitCSSMatrix(theTransform).m42;
		if (theTransform != this.slotEl[this.activeSlot].slotYPosition) {
			this.setPosition(this.activeSlot, theTransform);
		}
		
		this.startY = e.targetTouches[0].clientY;
		this.scrollStartY = this.slotEl[this.activeSlot].slotYPosition;
		this.scrollStartTime = e.timeStamp;

		this.swFrame.addEventListener(this.evtMove, this, false);
		this.swFrame.addEventListener(this.evtEnd, this, false);
		
		return true;
	},

	scrollMove: function (e) {
		this.mouseToTouch(e);
		var topDelta = e.targetTouches[0].clientY - this.startY;

		if (this.slotEl[this.activeSlot].slotYPosition > 0 || this.slotEl[this.activeSlot].slotYPosition < this.slotEl[this.activeSlot].slotMaxScroll) {
			topDelta /= 2;
		}
		
		this.setPosition(this.activeSlot, this.slotEl[this.activeSlot].slotYPosition + topDelta);
		this.startY = e.targetTouches[0].clientY;

		// Prevent slingshot effect
		if (e.timeStamp - this.scrollStartTime > 80) {
			this.scrollStartY = this.slotEl[this.activeSlot].slotYPosition;
			this.scrollStartTime = e.timeStamp;
		}
	},
	
	scrollEnd: function (e) {
		var newDuration, newPosition, newScrollDistance, scrollDistance, scrollDuration;
		this.swFrame.removeEventListener(this.evtMove, this, false);
		this.swFrame.removeEventListener(this.evtEnd, this, false);

		// If we are outside of the boundaries, let's go back to the sheepfold
		if (this.slotEl[this.activeSlot].slotYPosition > 0 || this.slotEl[this.activeSlot].slotYPosition < this.slotEl[this.activeSlot].slotMaxScroll) {
			this.scrollTo(this.activeSlot, this.slotEl[this.activeSlot].slotYPosition > 0 ? 0 : this.slotEl[this.activeSlot].slotMaxScroll);
			return false;
		}

		// Lame formula to calculate a fake deceleration
		scrollDistance = this.slotEl[this.activeSlot].slotYPosition - this.scrollStartY;

		// The drag session was too short
		if (scrollDistance < this.cellHeight / 1.5 && scrollDistance > -this.cellHeight / 1.5) {
			if (this.slotEl[this.activeSlot].slotYPosition % this.cellHeight) {
				this.scrollTo(this.activeSlot, Math.round(this.slotEl[this.activeSlot].slotYPosition / this.cellHeight) * this.cellHeight, '100ms');
			}

			return false;
		}

		scrollDuration = e.timeStamp - this.scrollStartTime;

		newDuration = (2 * scrollDistance / scrollDuration) / this.friction;
		newScrollDistance = (this.friction / 2) * (newDuration * newDuration);
		
		if (newDuration < 0) {
			newDuration = -newDuration;
			newScrollDistance = -newScrollDistance;
		}

		newPosition = this.slotEl[this.activeSlot].slotYPosition + newScrollDistance;

		if (newPosition > 0) {
			// Prevent the slot to be dragged outside the visible area (top margin)
			newPosition /= 2;
			newDuration /= 3;

			if (newPosition > this.swSlotWrapper.clientHeight / 4) {
				newPosition = this.swSlotWrapper.clientHeight / 4;
			}
		} else if (newPosition < this.slotEl[this.activeSlot].slotMaxScroll) {
			// Prevent the slot to be dragged outside the visible area (bottom margin)
			newPosition = (newPosition - this.slotEl[this.activeSlot].slotMaxScroll) / 2 + this.slotEl[this.activeSlot].slotMaxScroll;
			newDuration /= 3;
			
			if (newPosition < this.slotEl[this.activeSlot].slotMaxScroll - this.swSlotWrapper.clientHeight / 4) {
				newPosition = this.slotEl[this.activeSlot].slotMaxScroll - this.swSlotWrapper.clientHeight / 4;
			}
		} else {
			newPosition = Math.round(newPosition / this.cellHeight) * this.cellHeight;
		}

		this.scrollTo(this.activeSlot, Math.round(newPosition), Math.round(newDuration) + 'ms');
 
		return true;
	},

	scrollTo: function (slotNum, dest, runtime) {
		this.slotEl[slotNum].style.webkitTransitionDuration = runtime || '100ms';
		this.setPosition(slotNum, dest || 0);

		// If we are outside of the boundaries go back to the sheepfold
		if (this.slotEl[slotNum].slotYPosition > 0 || this.slotEl[slotNum].slotYPosition < this.slotEl[slotNum].slotMaxScroll) {
			this.slotEl[slotNum].addEventListener('webkitTransitionEnd', this, false);
		}
	},
	
	scrollToValue: function (slot, value) {
		var yPos, count, i;

		this.slotEl[slot].removeEventListener('webkitTransitionEnd', this, false);
		this.slotEl[slot].style.webkitTransitionDuration = '0';
		
		count = 0;
		for (i in this.slotData[slot].values) {
			if (i == value) {
				yPos = count * this.cellHeight;
				this.setPosition(slot, yPos);
				break;
			}
			
			count -= 1;
		}
	},
	
	backWithinBoundaries: function (e) {
		e.target.removeEventListener('webkitTransitionEnd', this, false);

		this.scrollTo(e.target.slotPosition, e.target.slotYPosition > 0 ? 0 : e.target.slotMaxScroll, '150ms');
		return false;
	},


	/**
	 *
	 * Buttons
	 *
	 */

	tapDown: function (e) {
		e.currentTarget.addEventListener(this.evtMove, this, false);
		e.currentTarget.addEventListener(this.evtEnd, this, false);
		e.currentTarget.className = 'sw-pressed';
	},

	tapCancel: function (e) {
		e.currentTarget.removeEventListener(this.evtMove, this, false);
		e.currentTarget.removeEventListener(this.evtEnd, this, false);
		e.currentTarget.className = '';
	},
	
	tapUp: function (e) {
		this.done(e);
	},

	setCancelAction: function (action) {
		this.cancelAction = action;
	},

	setDoneAction: function (action) {
		this.doneAction = action;
	},
	
	cancelAction: function () {
		return false;
	},

	cancelDone: function () {
		return true;
	},
	
	done: function (e) {
		if (this.swWrapper) {
			if (!e) {
				e = {
					currentTarget: document.getElementById('sw-done')
				};
				}
			this.tapCancel(e);
			if (e.currentTarget.id == 'sw-cancel') {
				this.cancelAction();
			} else {
				this.doneAction();
			}
			this.close();
		}
	}
	
};/*jslint browser: true, devel: true, bitwise: true, continue: true, evil: true, forin: true, nomen: true, plusplus: true, regexp: true, sloppy: true, white: true */
(function() {
	var $, readyFn;
	function nlx(el, query) {
		var that;
		function style(attrib, value) {
			var attribName;
			if (typeof attrib === 'string' && value === undefined) {
				if (that.length > 0) {
					return window.getComputedStyle(that[0], null).getPropertyValue(attrib);
				}
			}
			if (typeof attrib !== 'object') {
				attribName = attrib;
				attrib = {};
				attrib[attribName] = value;
			}
			return that.each(function() {
				var prop;
				for (prop in attrib) {
					if (attrib.hasOwnProperty(prop)) {
						this.style[prop] = attrib[prop];
					}
				}
			});
		}
		function show(display) {
			if (!display) {
				display = 'block';
			}
			return style('display', display);
		}
		function addClass() {
			var classNames;
			classNames = arguments;
			$(classNames).each(function() {
				var className = this;
				that.each(function() {
					if (!$.hasClass(this, className)) {
						this.className = this.className ? this.className + ' ' + className : className;
					}
				});
			});
			return that;
		}
		function attr(name, value) {
			if (value === undefined) {
				if (that.length > 0) {
					return that[0].getAttribute(name);
				}
			} else {
				that.each(function() {
					this.setAttribute(name, value);
				});
			}
		}
		function bind(type, fn, capture) {
			return that.each(function() {
				this.removeEventListener(type, fn, capture ? true : false); // prevent potential double binding
				this.addEventListener(type, fn, capture ? true : false);
			});
		}
		function blur() {
			return that.each(function() {
				this.blur();
			});
		}
		function each(callback) {
			return $.each(that, callback);
		}
		function empty() {
			return that.each(function() {
				while (this.firstChild) {
					this.removeChild(this.firstChild);
				}
			});
		}
		function find(query) {
			var found, result;
			found = [];
			result = [];
			that.each(function() {
				found.push(nlx(this, query));
			});
			$(found).each(function() {
				this.each(function() {
					if (!this.jmfwCounted) {
						this.jmfwCounted = true;
						result.push(this);
					}
				});
			});
			return $(result).each(function() {
				delete this.jmfwCounted;
			});
		}
		function focus() {
			if (that.length > 0) {
				that[0].focus();
			}
			return that;
		}
		function hasClass(className) {
			if (that.length > 0) {
				return $.hasClass(that[0], className);
			}
		}
		function height(value) {
			if (value === undefined) {
				if (that.length > 0) {
					return that[0].clientHeight;
				}
			}
			return that.each(function() {
				this.style.height = value === '' ? '' : value + 'px';
			});
		}
		function hide() {
			return show('none');
		}
		function html(value) {
			if (value === undefined) {
				if (that.length > 0) {
					return that[0].innerHTML;
				}
			}
			return that.each(function() {
				if( window['WinJS'] != undefined )
			        WinJS.Utilities.setInnerHTMLUnsafe(this, value);
                else 
			        this.innerHTML = value;
			});
		}
		function item(n) {
			if (that.length > n) {
				return $(that[n]);
			}
		}
		function offset() {
			var o, parent;
			o = {
				left: 0,
				top: 0
			};
			if (that.length > 0) {
				for (parent = that[0]; parent; parent = parent.offsetParent) {
					o.left += parent.offsetLeft;
					o.top += parent.offsetTop;
				}
			}
			return o;
		}
		function parent() {
			var result;
			result = [];
			that.each(function() {
				var parentNode;
				parentNode = this.parentNode;
				if (!parentNode.jmfwCounted) {
					result.push(parentNode);
					parentNode.jmfwCounted = true;
				}
			});
			return $(result).each(function() {
				delete this.jmfwCounted;
			});
		}
		function remove(query) {
			if (query === undefined) {
				return that.each(function() {
					this.parentNode.removeChild(this);
				});
			}
			return that.find(query).remove();
		}
		function removeAttr(name) {
			return that.each(function() {
				this.removeAttribute(name);
			});
		}
		function removeClass() {
			var classNames;
			classNames = arguments;
			$(classNames).each(function() {
				var className = this;
				that.each(function() {
					this.className = this.className.replace(new RegExp('(^|\\s+)' + className + '(\\s+|$)'), ' ');
				});
			});
			return that;
		}
		function text(value) {
			if (value === undefined) {
				if (that.length > 0) {
					return that[0].textContent || that[0].innerText;
				}
			}
			return that.each(function() {
				this.textContent = value;
			});
		}
		function toggleClass() {
			var classNames;
			classNames = arguments;
			$(classNames).each(function() {
				var className = this;
				that.each(function() {
					var o = $(this);
					if (o.hasClass(className)) {
						o.removeClass(className);
					} else {
						o.addClass(className);
					}
				});
			});
			return that;
		}
		function trigger(type, extra) {
			var evt, name;
			evt = window.document.createEvent('Events');
			evt.initEvent(type, true, true);
			if (extra && typeof extra === 'object') {
				for (name in extra) {
					if (extra.hasOwnProperty(name)) {
						evt[name] = extra[name];
					}
				}
			}
			return that.each(function() {
				this.dispatchEvent(evt);
			});
		}
		function unbind(type, fn, capture) {
			return that.each(function() {
				this.removeEventListener(type, fn, capture ? true : false);
			});
		}
		function val(value) {
			if (value === undefined) {
				if (that.length > 0) {
					return that[0].value;
				}
			} else {
				that.each(function() {
					this.value = value;
				});
			}
		}
		function width(value) {
			if (value === undefined) {
				if (that.length > 0) {
					return that[0].clientWidth;
				}
			}
			return that.each(function() {
				this.style.width = value + 'px';
			});
		}
		if (!query) {
			return null;
		}
		if (query.nodeType || query === window) {
			query = [query];
		} else if (typeof query === 'string') {
			query = el.querySelectorAll(query); //Copying values into an array as .querySelectorAll on Android was exposing .xxx where xxx was the element's id (This did not happen in desktop Chrome). This was breaking when the id was a reserved javascript word or a function. example query.trigger.
			var temp_arr = [];
			for (var i = 0; i < query.length; ++i) {
				temp_arr.push( query[i]);
			}
			query = temp_arr;
		} else if (!(query instanceof Array) && query.length === undefined) {
			return null;
		}
		that = query;
		that.addClass = addClass;
		that.attr = attr;
		that.bind = bind;
		that.blur = blur;
		that.each = each;
		that.empty = empty;
		that.find = find;
		that.focus = focus;
		that.hasClass = hasClass;
		that.height = height;
		that.hide = hide;
		that.html = html;
		that.item = item;
		that.offset = offset;
		that.parent = parent;
		that.remove = remove;
		that.removeAttr = removeAttr;
		that.removeClass = removeClass;
		that.show = show;
		that.style = style;
		that.text = text;
		that.toggleClass = toggleClass;
		that.trigger = trigger;
		that.unbind = unbind;
		that.val = val;
		that.width = width;
		return that;


		/*
		that = {
		addClass: addClass,
		attr: attr,
		bind: bind,
		blur: blur,
		each: each,
		empty: empty,
		find: find,
		focus: focus,
		hasClass: hasClass,
		height: height,
		hide: hide,
		html: html,
		item: item,
		offset: offset,
		parent: parent,
		remove: remove,
		removeAttr: removeAttr,
		removeClass: removeClass,
		show: show,
		style: style,
		text: text,
		toggleClass: toggleClass,
		trigger: trigger,
		unbind: unbind,
		val: val,
		width: width
		};
		that.length = query.length;
		for (i = 0; i < that.length; i += 1) {
		that[i] = query[i];
		}
		return that;
		*/
	}
	function documentQuery(query) {
		return nlx(window.document, query);
	}
	function domReady() {
		setTimeout(function() {
			var i, n;
			n = readyFn.length;
			for (i = 0; i < n; i += 1) {
				readyFn[i]();
			}
			readyFn = null;
		}, 100);
		window.document.removeEventListener('DOMContentLoaded', domReady, false);
	}
	function each(collection, callback) {
		var i;
		if (collection.length !== undefined) {
			for (i = 0; i < collection.length; i += 1) {
				if (callback.call(collection[i], i, collection[i]) === false) {
					break;
				}
			}
		} else {
			for (i in collection) {
				if (collection.hasOwnProperty(i)) {
					if (callback.call(collection[i], i, collection[i]) === false) {
						break;
					}
				}
			}
		}
		return collection;
	}
	function hasClass(el, className) {
		return new RegExp('(^|\\s)' + className + '(\\s|$)').test(el.className);
	}
	function jsonParse(s) {
		var o;
		if (s !== undefined && s !== null && typeof s === 'string') {
			o = JSON.parse(s, function(key, value) {
				var a;
				key = undefined;
				if (typeof value === 'string') {
					a = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
					if (a) {
						return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4], +a[5], +a[6]));
					}
				}
				return value;
			});
		}
		return o || undefined;
	}
	function jsonStringify(o) {
		return JSON.stringify(o);
	}
	function jsonCopy(o) {
		return jsonParse(jsonStringify(o));
	}
	function members(o, deep) {
		var a, p;
		a = [];
		if (o) {
			for (p in o) {
				if (deep || o.hasOwnProperty(p)) {
					a.push(p);
				}
			}
			a.sort(function(lhs, rhs) {
				var l, r;
				l = lhs.toLowerCase();
				r = rhs.toLowerCase();
				return (l === r) ? 0 : (l < r) ? -1 : 1;
			});
		}
		return a;
	}
	function ready(fn) {
		if (readyFn.length === 0) {
			window.document.addEventListener('DOMContentLoaded', domReady, false);
		}
		readyFn.push(fn);
	}
	function oldTmpl(s, data) {
	    var fn = new Function("$", "data",
			"var p=[];p.push('" +
			s.replace(/[\r\t\n]/g, " ")
				.split("<%").join("\t")
				.replace(/((^|%>)[^\t]*)'/g, "$1\r")
				.replace(/\t=(.*?)%>/g, "',$1,'")
				.split("\t").join("');")
				.split("%>").join("p.push('")
				.split("\r").join("\\'") +
			"');return p.join('');");
	    return data ? fn($, data) : fn;
	}
	function oldTmplString(s) {
	    var ts = s.replace(/[\r\t\n]/g, " ")
				.split("<%").join("\t")
				.replace(/((^|%>)[^\t]*)'/g, "$1\r")
				.replace(/\t=(.*?)%>/g, "',$1,'")
				.split("\t").join("');")
				.split("%>").join("p.push('")
				.split("\r").join("\\'");
	    return ts.split("<").join("&lt;").split(">").join("&gt;");
	}
	function tmpl(s, data) {
	    // bitwise inverse of -1 = 0
	    // if index != -1, use the old implementation
	    if (~s.indexOf("<%")) {
	        return oldTmpl(s, data);
	    }

	    var content = s.replace(/[\r\t\n]/g, " ")
	    content = content.split("<templatejs>");
	    content = content.join("\t");
	    content = content.replace(/((^|<\/templatejs>)[^\t]*)'/g, "$1\r");
	    content = content.replace(/\t=(.*?)<\/templatejs>/g, "',$1,'");
	    content = content.split("\t");
	    content = content.join("');");
	    content = content.split("</templatejs>");
	    content = content.join("p.push('");
	    content = content.split("\r");
	    content = content.join("\\'");


	    var fn = new Function("$", "data",
            "var p=[];p.push('" +
            content +
            "');return p.join('');");
	    return data ? fn($, data) : fn;
	    
	}
	function tmplString(s) {
	    // bitwise inverse of -1 = 0
	    // if index != -1, use the old implementation
	    if (~s.indexOf("<%")) {
	        return oldTmplString(s);
	    }
		var ts = s.replace(/[\r\t\n]/g, " ")
				.split("<templatejs>").join("\t")
				.replace(/((^|<\/templatejs>)[^\t]*)'/g, "$1\r")
				.replace(/\t=(.*?)<\/templatejs>/g, "',$1,'")
				.split("\t").join("');")
				.split("</templatejs>").join("p.push('")
				.split("\r").join("\\'");
		return ts.split("<").join("&lt;").split(">").join("&gt;");		
	}
	readyFn = [];
	$ = documentQuery;
	$.isAndroid = (/android/gi).test(window.navigator.appVersion) && !(/msie/gi).test(window.navigator.appVersion) && !(/windows/gi).test(window.navigator.appVersion);
	$.isBlackberry = (/blackberry/gi).test(window.navigator.appVersion);
	$.isHashChangeAware = (window.onhashchange !== undefined);
	$.isIE = (/msie/gi).test(window.navigator.appVersion) || (/trident/gi).test(window.navigator.appVersion) || (/windows/gi).test(window.navigator.appVersion);
	$.isWindows8 = (/msapphost/gi).test(window.navigator.appVersion);
	$.isIpad = (/ipad/gi).test(window.navigator.appVersion);
	$.isIphone = (/iphone/gi).test(window.navigator.appVersion);
	$.isOrientationAware = (window.onorientationchange !== undefined);
	$.isStandalone = window.navigator.standalone;
	$.isTouch = (window.ontouchstart !== undefined);
	$.isZetakey = (/zetakey/gi).test(window.navigator.userAgent);
	$.isCTTesting = (/cttesting/gi).test(window.navigator.userAgent);
	$.has3d = (window.WebKitCSSMatrix !== undefined && new window.WebKitCSSMatrix().m11 !== undefined);
	$.hasAnimation = (window.WebKitAnimationEvent !== undefined || window.AnimationEvent !== undefined);
	$.hasClass = hasClass;
	$.each = each;
	$.jsonParse = jsonParse;
	$.jsonStringify = jsonStringify;
	$.jsonCopy = jsonCopy;
	$.members = members;
	$.ready = ready;
	$.tmpl = tmpl;
	$.tmplString = tmplString;
	window.jmfw = $;
} ());/*jslint browser: true, devel: true, bitwise: true, continue: true, evil: true, forin: true, nomen: true, plusplus: true, regexp: true, sloppy: true, white: true */
(function ($) {
	var animationEnd, ignoreHashChange, passwordMask, transitionEnd;

	function defaultPrevented(e) {
		if (e.hasOwnProperty('returnValue')) {
			return !e.returnValue;
		}
		return !!e.defaultPrevented;
	}

	/**
	* Prevent default and propagation on the supplied event
	*
	* @param	e
	*					event object to cancel
	*/
	function cancelEvent(e) {
		e.preventDefault();
		e.stopPropagation();
	}
	/**
	* Get the title text for the supplied composite element
	*
	* @param	el
	*					DOM element with a class of jmuiCompositeXxx
	*
	* @return	String containing the title text
	*/

	function getCompositeTitle(el) {
		var label, title;
		try {
			label = el.parentElement.parentElement.previousElementSibling;
			if (label && label.nodeName === 'H2') {
				title = label.innerText;
			} else {
				title = '';
			}
		} catch (ex) {
			title = '';
		}
		return title;
	}
	/**
	* Retrieve the parent element of the supplied element which has the supplied
	* class
	*
	* @param	el
	*					dom element object
	* @param	c
	*					string containing class of parent element to search for
	*
	* @return	dom parent element
	*/

	function parentElement(el, c) {
		var parent;
		parent = el;
		while (parent && !$.hasClass(parent, c)) {
			parent = parent.parentElement;
		}
		return parent;
	}
	/**
	* Set scrolling area height
	*
	* @param	page
	*					jmfw object containing page div containing scroll area
	*/

	function setScrollerHeight(page) {
  
    if(jmfw.isIE) {
      jQuery('.jmuiFooter').css({
        position: "fixed",
        left: "0px",
        bottom: "0px",
      });
      return;
    }
  
		var footer, footerHeight, header, headerHeight, wrapper, wrapperHeight;
		wrapper = page.find('.jmuiScroller, .jmuiNativeScroller');
		if (wrapper.length) {
			header 		 	= page.find('.jmuiHeader');
			segmentHeader	= page.find('.jmuiSegmentHeader');
			segmentPanel 	= page.find('.jmuiSegmentPanel');
			footer 			= page.find('.jmuiFooter');
			headerHeight 	= header.length > 0 ? header[0].offsetHeight : 0;
			segmentHHeight	= segmentHeader.length > 0 ? segmentHeader[0].offsetHeight : 0;
			segmentHOffset  = segmentHeader.length > 0 ? segmentHeader[0].offsetTop : 0;
			footerHeight = footer.length > 0 ? footer[0].offsetHeight : 0;
			
			wrapperHeight = window.innerHeight - headerHeight - footerHeight;
			if(jmfw.isIE) {
				// wrapperHeight -= 4;
				if( $('.jmuiCurrent > .jmuiHeader').length < 1 ) {
					$('div.jmuiPage.jmuiCurrent').style('padding-top', 0);
				}
				if( $('.jmuiCurrent > .jmuiFooter').length < 1 ) {
					$('div.jmuiPage.jmuiCurrent').style('padding-bottom', 0);
				}
			}
			
			wrapper.height(wrapperHeight);
			
			/* Page Group Detected */
			if(segmentHHeight > 0){
				segmentPanel.height(window.innerHeight - (segmentHOffset + segmentHHeight) - footerHeight);
			}			
		}
		/* Final check to bring an input element into focus */
		if(jQuery("input:focus, textarea:focus").length>0){
			jmfw.ui.scrollToElement(jQuery("input:focus, textarea:focus")[0]);
		}
	}
	/**
	* Calculate the scroll origin
	*
	* @param	el
	*					dom element object inside scroller
	*
	* @return object containing x,y coordinates of scroll origin
	*/

	function scrollOrigin(el) {
		var origin, scroller;
		scroller = parentElement(el, 'jmuiScroller');
		if (scroller) {
			if (scroller && scroller.firstElementChild && scroller.firstElementChild.jmuiScroller) {
				origin = scrollOrigin(scroller.parentElement);
				origin.x += scroller.firstElementChild.jmuiScroller.x;
				origin.y += scroller.firstElementChild.jmuiScroller.y;
			} else {
				origin = {
					x: 0,
					y: 0
				};
			}
			origin.iScroll = true;
		} else {
			scroller = $('body');
			if (scroller && scroller.length) {
				origin = {
					x: scroller[0].scrollLeft,
					y: scroller[0].scrollTop
				};
			} else {
				origin = {
					x: 0,
					y: 0
				};
			}
			origin.pageScroll = !!parentElement(el, 'jmuiPageScroller');
		}
		return origin;
	}
	/**
	* Initialize function called when DOM is ready
	*/
	function resize(e) {
		var layout;
		e = undefined;
		function updateScroller(page) {
			setTimeout(setScrollerHeight(page), 500);
		}
		if ($.isAndroid) {
			$('div').each(function () {
				if (this.hasOwnProperty('scrollLeft') && this.scrollLeft !== 0) {
					this.scrollLeft = 0;
				}
				if (this.hasOwnProperty('scrollTop') && this.scrollTop !== 0) {
					this.scrollTop = 0;
				}
			});
			layout = $('.jmuiLayout.jmuiCurrent');
			layout.find('.jmuiPage.jmuiCurrent').each(function () {
				updateScroller($(this));
			});
		} else {
			layout = $('.jmuiLayout.jmuiCurrent');
			layout.find('.jmuiPage.jmuiCurrent').each(function () {
				updateScroller($(this));
			});
		}
	}
	/**
	* Generate jmuiTap events and toggle jmuiPressed class at appropriate times
	*
	* @param	elements
	*					jmfw object containing elements to generate taps for
	* @param	degenerate
	*					optional boolean indicating whether to generate or degenerate the taps
	*/

	function generateTaps(elements, degenerate) {
		return elements.each(function () {
			var editor, evtEnd, evtMove, evtOut, evtStart, holdTmo, me, mouseOut, startOrigin, startPressed, inScroll, iScroll;
			var isMoving = false;
			function isTouchInside(e) {
				var offset, origin, pos, tolerance;
				// Check if we are on a native scrolling page - don't need this test if we are
                if( typeof jQuery !== 'undefined' && jQuery(me).parents(".jmuiNativeScroller").length > 0 )
                    return true;
				tolerance = 50;

				if (e.changedTouches && e.changedTouches.length === 1) {
					e = e.changedTouches[0];
				}
				offset = me.offset();
				origin = scrollOrigin(me[0]);				
				
				if( $.isAndroid ) {
					return true;
				}
				
				if( $.isIE ) {
					return true;
				}
				
				pos = {
					x: e.pageX + origin.x,
					y: e.pageY - origin.y
				};				
				return pos.x >= (offset.left - tolerance) && pos.x < (me[0].offsetWidth + offset.left + tolerance) && pos.y >= (offset.top - tolerance) && pos.y < (me[0].offsetHeight + offset.top + tolerance);
			}
			function stopHoldTimer() {
				if (holdTmo !== undefined) {
					window.clearTimeout(holdTmo);
					holdTmo = undefined;
				}
			}
			function touchMove(e) {
				var origin;
				stopHoldTimer();
				origin = scrollOrigin(me[0]);
				
				if (startPressed) {
				    // This used to be iOS only, then changed to every platform
				    // but that broke Window 8, which generates touch move events
				    // event before the pointer has moved.
				    if (!$.isWindows8 && !$.isIE) {
                        isMoving = true;
					}
				}
				
				if (startOrigin.x === origin.x && startOrigin.y === origin.y && isTouchInside(e) === true) {
					if (startPressed) {
						editor.addClass('jmuiPressed');
						if(isMoving){
                            if (!me.hasClass("md_toolbarButton")){
                                me.unbind(evtEnd, touchEnd, true);
                                editor.removeClass('jmuiPressed');
                            }
                        }
					}
				} else {
					editor.removeClass('jmuiPressed');
				}
			}
			function touchEnd(e) {
				var endOrigin, extra;
				stopHoldTimer();
				endOrigin = scrollOrigin(me[0]);
				me.unbind(evtMove, touchMove, true);
				me.unbind(evtEnd, touchEnd, true);
				me.unbind(evtOut, mouseOut, false);
				setTimeout(function () {
					editor.removeClass('jmuiPressed');
				}, 600);
				//editor.removeClass('jmuiPressed');
				if (startOrigin.x === endOrigin.x && startOrigin.y === endOrigin.y && isTouchInside(e) === true) {
					extra = {};
					extra.jmuiTarget = e.target;
					if (e.changedTouches && e.changedTouches.length === 1) {
						extra.pageX = e.changedTouches[0].pageX;
						extra.pageY = e.changedTouches[0].pageY;
					} else {
						extra.pageX = e.pageX;
						extra.pageY = e.pageY;
					}
					if (!me.hasClass('jmuiClicked')) {
						me.addClass('jmuiClicked');
						me.trigger('jmuiTap', extra);
						setTimeout(function () {
							me.removeClass('jmuiClicked');
						}, 600);
					}
				}
			}
			function tapAndHold() {
				var extra;
				holdTmo = undefined;
				extra = {};
				extra.jmuiTarget = me[0];
				me.unbind(evtMove, touchMove, true);
				me.unbind(evtEnd, touchEnd, true);
				me.unbind(evtOut, mouseOut, false);
				editor.removeClass('jmuiPressed');
				me.trigger('jmuiTapAndHold');
			}
			function touchStart() {
				startPressed = false;
				startOrigin = scrollOrigin(me[0]);
				/*
				setTimeout(function() {
				var origin;
				startPressed = true;
				origin = scrollOrigin(me[0]);
				if (origin.x === startOrigin.x && origin.y === startOrigin.y) {
				editor.addClass('jmuiPressed');
				}
				}, 100);
				*/
				editor.addClass('jmuiPressed');
				startPressed = true;
				me.bind(evtMove, touchMove, true);
				me.bind(evtEnd, touchEnd, true);
				me.bind(evtOut, mouseOut, false);
				holdTmo = window.setTimeout(tapAndHold, 1000);
			}
			mouseOut = function (e) {
				e = undefined;
				me.unbind(evtMove, touchMove, true);
				me.unbind(evtEnd, touchEnd, true);
				me.unbind(evtOut, mouseOut, false);
				editor.removeClass('jmuiPressed');
			};
			//if (!$.isBlackberry) {
			if (degenerate) {
				if (this.jmuiTap) {
					$(this).unbind(this.jmuiTap.event, this.jmuiTap.handler, false);
				}
			} else {
				if (!this.jmuiTap) { // Prevent multiple generations
				    if( window.jQuery )
						inScroll = jQuery(this).parents(".jmuiHeader,.jmuiFooter").length < 1;
					me = $(this);
					editor = me.hasClass('jmuiMask') ? me.parent() : me;
					if ($.isTouch) {
						evtStart = 'touchstart';
						evtMove = 'touchmove';
						evtEnd = 'touchend';
						evtOut = 'mouseout';
					} else {
						evtStart = 'mousedown';
						evtMove = 'mousemove';
						evtEnd = 'mouseup';
						evtOut = 'mouseout';
					}
					me.bind(evtStart, touchStart, false);
					this.jmuiTap = {
						event: evtStart,
						handler: touchStart
					}; // For unbind when degenerate is set
				}
			}
			//}
		});
	}
	/**
	* Recalculate scroll parameters
	*
	* @param	page
	*					jmfw object containing page div containing scroller to refresh
	*/
	function refreshScroller(page) {
		function refresh() {
			var scroller;
			scroller = page.find('.jmuiScroller > div');
			if (scroller.length && scroller[0].jmuiScroller) {
				scroller[0].jmuiScroller.refresh();
			}
		}
		if ($.isAndroid) {
			setTimeout(refresh, 500);	// New bug in Android 4 browser requires a delay here
		} else {
			refresh();
		}
	}

	/**
	* Initialize scroller element inside the supplied page
	*
	* @param	page
	*					jmfw object containing page element
	*/

	function bindScroller(page) {
		var body, scroller;
		function blur(e) {
			e = undefined;
			setTimeout(function () {
				if ($(':focus').length === 0) {
					var left, parent, top;
					parent = scroller[0].parentElement;
					if (parent) {
						left = parent.scrollLeft;
						top = parent.scrollTop;
						parent.scrollLeft = 0;
						parent.scrollTop = 0;
						scroller[0].jmuiScroller.scrollTo(-left, -top, '0');
					}
					resize();
				}
			}, 0); // Has to be in a setTimeout otherwise $(':focus').length always returns 0
		}
		function refreshScroller() {
			setScrollerHeight(page);
			if (scroller.length && scroller[0].jmuiScroller) {
				scroller[0].jmuiScroller.refresh(); // required to set some scroll parameters. not needed during resize though ???
			}
		}
		scroller = page.find('.jmuiScroller > div');
		if (scroller.length) {
			scroller[0].jmuiScroller = new $.iScroll(scroller[0], {
				desktopCompatibility: true,
				bounce: !$.isAndroid
			});
			scroller.find('img').bind('load', refreshScroller);
			if ($.isAndroid || $.isIpad || $.isIphone) {
				scroller.find('input,textarea,select').bind('blur', blur);
			}
		} else {
			scroller = undefined;
		}
		page.bind('jmuiPageAnimationStart', function (e) {
			if (scroller && scroller.length && e.direction === 'in') {
				refreshScroller();
				//body.style('overflow-y', 'hidden');
			} else {
				//body.style('overflow-y', 'inherit');
			}
		});
		body = $('body');
	}

	/**
	* Navigate to the supplied page using the supplied animation. Ensure that
	* the toPage's layout is the only visible layout
	*
	* @param toPage
	*					jmcore object containing the div element to navigate to
	* @param animation
	*					optional string containing the name of the animation class to use
	* @param backwards
	*					optional boolean indicating then direction of the animation
	* @param silent
	*					optional boolean indicating whether jmuiAnimation events should trigger
	*
	* @return	true if toPage is now (or will be) the currently visible page,
	*					false otherwise
	*/

	function gotoPage(toPage, animation, backwards, silent) {
		var animateLayouts, animatePages, fromLayout, fromPage, toColumn, toLayout;
		function pageAnimationEnd() {
			ignoreHashChange = true;
			window.location.hash = toPage[0].id;
			if (animatePages) {
				fromPage.unbind(transitionEnd, pageAnimationEnd);
				fromPage.unbind(animationEnd, pageAnimationEnd);
				toPage.removeClass('jmuiStart', 'jmuiIn', animation);
				fromPage.removeClass('jmuiStart', 'jmuiOut', 'jmuiCurrent', animation);
				if (backwards) {
					toPage.toggleClass('jmuiReverse');
					fromPage.toggleClass('jmuiReverse');
				}
			} else {
				fromPage.removeClass('jmuiCurrent');
			}
			if (!silent && !fromLayout) {
				toPage.trigger('jmuiPageAnimationEnd', {
					direction: 'in',
					reverse: backwards
				});
				fromPage.trigger('jmuiPageAnimationEnd', {
					direction: 'out',
					reverse: backwards
				});
			}
		}
		function layoutAnimationEnd() {
			if (animateLayouts) {
				fromLayout.unbind(transitionEnd, layoutAnimationEnd);
				fromLayout.unbind(animationEnd, layoutAnimationEnd);
				toLayout.removeClass('jmuiStart', 'jmuiIn', animation);
				fromLayout.removeClass('jmuiStart', 'jmuiOut', 'jmuiCurrent', animation);
				if (backwards) {
					toLayout.toggleClass('jmuiReverse');
					fromLayout.toggleClass('jmuiReverse');
				}
			} else {
				fromLayout.removeClass('jmuiCurrent');
			}
			if (!silent) {
				toLayout.trigger('jmuiLayoutAnimationEnd', {
					direction: 'in',
					reverse: backwards
				});
				fromLayout.trigger('jmuiLayoutAnimationEnd', {
					direction: 'out',
					reverse: backwards
				});
			}
		}
		if (!toPage || toPage.length === 0) {
			log.error('Target page to animate to is missing.');
			return false;
		}
		if (toPage.length > 1) {
			toPage = toPage.item(0);
		}
		toColumn = toPage.parent();
		toLayout = toColumn.parent();
		if (!toLayout.hasClass('jmuiCurrent')) {
			fromLayout = $('.jmuiLayout.jmuiCurrent');
		}
		if (!toPage.hasClass('jmuiCurrent')) {
			fromPage = toColumn.find('.jmuiCurrent');
		}
		if (fromLayout || fromPage) {
			$(':focus').blur(); // Collapse the keyboard
			if (fromPage) {
				animatePages = $.hasAnimation && animation && !fromLayout;
				if (animatePages && fromPage.attr('id') != 'Start') {
					if (backwards) {
						toPage.toggleClass('jmuiReverse');
						fromPage.toggleClass('jmuiReverse');
					}
					fromPage.bind(transitionEnd, pageAnimationEnd);
					fromPage.bind(animationEnd, pageAnimationEnd);
					toPage.addClass(animation, 'jmuiIn', 'jmuiCurrent');
					fromPage.addClass(animation, 'jmuiOut');
					window.setTimeout(function () {
						toPage.trigger('jmuiPageBind');
						if (!silent && !fromLayout) {
							fromPage.trigger('jmuiPageAnimationStart', {
								direction: 'out'
							});
							toPage.trigger('jmuiPageAnimationStart', {
								direction: 'in'
							});
						}
						toPage.addClass('jmuiStart');
						fromPage.addClass('jmuiStart');
					}, 100); // 100ms fixes iOS 4.2 sticky animation bug, otherwise 0ms
				} else {
					toPage.trigger('jmuiPageBind');
					toPage.addClass('jmuiCurrent');
					if (!silent && !fromLayout) {
						fromPage.trigger('jmuiPageAnimationStart', {
							direction: 'out'
						});
						toPage.trigger('jmuiPageAnimationStart', {
							direction: 'in'
						});
					}
					pageAnimationEnd();
				}
			}
			if (fromLayout) {
				animateLayouts = $.hasAnimation && animation;
				if (animateLayouts) {
					if (backwards) {
						toLayout.toggleClass('jmuiReverse');
						fromLayout.toggleClass('jmuiReverse');
					}
					fromLayout.bind(transitionEnd, layoutAnimationEnd);
					fromLayout.bind(animationEnd, layoutAnimationEnd);
					toLayout.addClass(animation, 'jmuiIn', 'jmuiCurrent');
					fromLayout.addClass(animation, 'jmuiOut');
					window.setTimeout(function () {
						if (!silent) {
							fromLayout.trigger('jmuiLayoutAnimationStart', {
								direction: 'out'
							});
							toLayout.trigger('jmuiLayoutAnimationStart', {
								direction: 'in'
							});
						}
						toLayout.addClass('jmuiStart');
						fromLayout.addClass('jmuiStart');
					}, 0);
				} else {
					toLayout.addClass('jmuiCurrent');
					if (!silent) {
						fromLayout.trigger('jmuiLayoutAnimationStart', {
							direction: 'out'
						});
						toLayout.trigger('jmuiLayoutAnimationStart', {
							direction: 'in'
						});
					}
					layoutAnimationEnd();
				}
			}
		}
	}
	/**
	* Retrieve the parent column in which the supplied element resides
	*
	* @param	el
	*					dom element object
	*
	* @return	dom element of parent column
	*/

	function parentColumn(el) {
		return parentElement(el, 'jmuiColumn');
	}
	/**
	* Retrieve the parent layout in which the supplied element resides
	*
	* @param	el
	*					dom element object
	*
	* @return	dom element of parent layout
	*/

	function parentLayout(el) {
		return parentElement(el, 'jmuiLayout');
	}
	/**
	* Retrieve the parent page in which the supplied element resides
	*
	* @param	el
	*					dom element object
	*
	* @return	dom element of parent page
	*/

	function parentPage(el) {
		return parentElement(el, 'jmuiPage');
	}
	/**
	* Scroll the page so that the supplied element is visible
	*
	* @param el
	*					dom element object to scroll to
	*/

	function scrollToElement(el) {
		var scroller;
		scroller = $(parentPage(el)).find('.jmuiScroller > div');
		nscroller = $(parentPage(el)).find('.jmuiNativeScroller > div');
		if (scroller.length) {
			scroller[0].jmuiScroller.scrollToElement(el);
		} else if( nscroller.length ) {
			
			if( $.isIE ) {
				var topPos = el.offsetTop;	
				if( $('.jmuiPage.jmuiCurrent .jmuiHeader').length > 0 ) {
					topPos -= $('.jmuiPage.jmuiCurrent .jmuiHeader').height();
				}			
				nscroller.parent()[0].scrollTop = topPos;			
			} else {			
				if( el.scrollIntoViewIfNeeded )
					el.scrollIntoViewIfNeeded(true);
				else
					el.scrollIntoView(true);
			}
		}		
	}
	/**
	* Show the segment panel corresponding to the supplied id and select the 
	* tab/accordion/swipe dot. Hide all other segments in the same group.
	*
	* @param	id
	*					String containing the id of the segment to show
	*/

	function showSegment(id) {
		var button, group, panel;
		panel = $('#' + id);
		if (panel && panel.length) {
			group = $(parentElement(panel[0], 'jmuiSegmentGroup'));
			if (group && group.length) {
				button = group.find('[jmuiSegmentId=' + id + ']');
				if (button && button.length && !button.hasClass('jmuiSelected')) {
					group.find('.jmuiSegmentButton.jmuiSelected').removeClass('jmuiSelected');
					button.addClass('jmuiSelected');
				}
				group.find('.jmuiSegmentPanel.jmuiSelected').removeClass('jmuiSelected');
				group.find('#' + id).addClass('jmuiSelected');
				refreshScroller($(parentPage(group[0])));
				group.trigger('jmuiChange', {
					segmentId: id
				});
			}
		}
	}
	/**
	* Get the event coordinates
	*
	* @param e
	*					Object containing parameter passed to event handler
	*/

	function eventPosition(e) {
		var offset, pos, scroller;
		pos = {
			x: 0,
			y: 0
		};
		if (e.offsetX !== undefined) {
			pos.x = e.offsetX;
			pos.y = e.offsetY;
		} else {
			offset = $(e.target).offset();
			pos.x = e.pageX - offset.left;
			pos.y = e.pageY - offset.top;
			scroller = $(parentPage(e.target)).find('.jmuiScroller > div');
			if (scroller.length) {
				if (scroller[0].jmuiScroller.x) {
					pos.x += scroller[0].jmuiScroller.x;
				}
				if (scroller[0].jmuiScroller.y) {
					pos.y -= scroller[0].jmuiScroller.y;
				}
			}
		}
		return pos;
	}
	/**
	* Display drop list page and update callers result when applicable
	*
	* @param	column
	*					jmfw object containing column element to display listPage
	* @param choices
	*					array of objects, each containing text & value of choice
	* @param selected
	*					String containing value of selected item
	* @param title
	*					String containing text to display in the title bar
	* @param backText
	*					String containing text to display in the back button
	* @param callback
	*					Function to call when back button is tapped
	*/

	function showListPage(column, choices, selected, title, backText, callback) {
		var backButton, listPage, ul;
		function backButtonTap() {
			var choice, index, ticked;
			backButton.unbind($.ui.tapEvent, backButtonTap);
			ticked = ul.find('.jmuiTick');
			if (ticked.length === 1) {
				choice = {
					label: ticked.text(),
					value: ticked[0].jmuiValue
				};
				index = ticked[0].jmuiIndex;
			}
			callback(index, choice);
		}
		function liClick() {
			var ticked;
			ticked = ul.find('.jmuiTick');
			ticked.each(function () {
				$(this).removeClass('jmuiTick');
			});
			$(this).addClass('jmuiTick');
			if (ticked.length === 0 || ticked[0] !== this) {
				backButtonTap();
			}
		}
		function appendLi(index, choice) {
			var li;
			li = $(window.document.createElement('li'));
			li.text(choice.label);
			li[0].jmuiValue = choice.value;
			li[0].jmuiIndex = index;
			if (choice.value === selected) {
				li.addClass('jmuiTick');
			}
			ul[0].appendChild(li[0]);
			generateTaps(li);
			li.bind($.ui.tapEvent, liClick);
		}
		if (!title || title.constructor !== String) {
			title = '';
		}
		if (!backText || backText.constructor !== String) {
			backText = 'Back';
		}
		listPage = column.find('.jmuiListPage');
		if (!listPage || listPage.length <= 0) {
			listPage = $(window.document.createElement('div'));
			listPage.addClass('jmuiPage', 'jmuiListPage');
			if ($.ui.isScrollable) {
				if ($.isIE) {
					listPage.addClass('jmuiPageScroller');
				}
				if ($.isIE || $.isBlackberry) {
					listPage.html('<div class="jmuiHeader"><div class="jmuiToolbar"><h1>List</h1><div class="jmuiGoBack jmuiBackButton">Back</div></div></div><div class="jmuiNativeScroller"><div><div class="md_listPageContainer"><ul></ul></div></div></div>');
				} else {
					listPage.html('<div class="jmuiHeader"><div class="jmuiToolbar"><h1>List</h1><div class="jmuiGoBack jmuiBackButton">Back</div></div></div><div class="jmuiScroller"><div><div class="md_listPageContainer"><ul></ul></div></div></div>');
				}
				bindScroller(listPage);
			} else {
				listPage.html('<div class="jmuiHeader"><div class="jmuiToolbar"><h1>List</h1><div class="jmuiGoBack jmuiBackButton">Back</div></div></div><ul></ul>');
			}
			column[0].appendChild(listPage[0]);
		}
		ul = listPage.find('ul');
		ul.empty();
		backButton = listPage.find('.jmuiBackButton');
		backButton.text(backText);
		generateTaps(backButton);
		backButton.bind($.ui.tapEvent, backButtonTap);
		listPage.find('.jmuiToolbar > h1').text(title);
		$(choices).each(appendLi);
		gotoPage(listPage, 'jmuiSlide', false, false);
		listPage.trigger('jmuiPageAnimationStart', {
			direction: 'in',
			reverse: false
		});
	}
	/**
	* Display spinning wheel and call callback when done
	*
	* @param choices
	*					array of objects, each containing text & value of choice
	* @param selected
	*					String containing value of selected item
	* @param callback
	*					Function to call when back button is tapped
	*/

	function showListTumblers(choices, selected, callback) {
		var values;
		if ($('#sw-wrapper').length === 0) {
			values = {};
			$(choices).each(function (index, choice) {
				index = undefined;
				values[choice.value] = choice.label;
			});
			$.spinningWheel.addSlot(values, '', selected);
			$.spinningWheel.setCancelAction(function () {
				$(window.document).unbind('touchmove', cancelEvent);
			});
			$.spinningWheel.setDoneAction(function () {
				var choice, i, results;
				$(window.document).unbind('touchmove', cancelEvent);
				results = $.spinningWheel.getSelectedValues();
				choice = {
					value: results.keys[0],
					label: results.values[0]
				};
				for (i = 0; i < choices.length; i += 1) {
					if (choices[i].value === choice.value) {
						break;
					}
				}
				callback(i >= choices.length ? 0 : i, choice);
			});
			$(window.document).bind('touchmove', cancelEvent);
			$.spinningWheel.open();
		}
	}
	/**
	* Display slot page and callback with result
	*
	* @param	column
	*					jmfw object containing column element to display listPage
	* @param slots
	*					Array of objects - 1 for each slot. Each slot contains an array of
	*					choices. Each choice contains a label & value string. Each slot also 
	*					contains an index number for the default selection. For a static slot,
	*					then the slot contains a static member containing the text to display.
	* @param title
	*					String containing text to display in the title bar
	* @param back
	*					String containing text to display in the back button
	* @param callback
	*					Function to call when back button is tapped. Parameter is an array of 
	*					result values. 1 value for each slot. The value corresponds to the value
	*					of the selected index inside the supplied choices array.
	*/

	function showSlotPage(column, slots, title, back, callback) {
		var backButton, li, slotPage;
		function updateLi() {
			var label;
			label = '';
			slotPage.find('.jmuiSlot div:nth-child(2)').each(function () {
				label += $(this).text() + ' ';
			});
			li.text(label);
		}
		function addSlot(slotMachine, slot) {
			var decDiv, incDiv, index, interval, isStatic, slotDiv, timeout, valDiv;
			function calcWidth() {
				var i, width;
				width = 0;
				if (isStatic) {
					width = slot.staticSlot.length;
				} else {
					for (i = 0; i < slot.choices.length; i += 1) {
						if (slot.choices[i].label.length > width) {
							width = slot.choices[i].label.length;
						}
					}
				}
				width = (width * 0.75).toString() + 'em';
				return width;
			}
			function increment(inc) {
				index += inc;
				if (index >= slot.choices.length) {
					index = 0;
				} else if (index < 0) {
					index = slot.choices.length - 1;
				}
				valDiv.val(slot.choices[index].value);
				valDiv.text(slot.choices[index].label);
				updateLi();
			}
			function stopTimers() {
				if (timeout) {
					clearTimeout(timeout);
					timeout = undefined;
				}
				if (interval) {
					clearInterval(interval);
					interval = undefined;
				}
			}
			function touchStart(e) {
				var inc;
				if (!$.ui.defaultPrevented(e)) {
					stopTimers();
					cancelEvent(e); // Needs cancelEvent to prevent bogus select/copy UI
					inc = this === incDiv[0] ? 1 : -1;
					$(this).addClass('jmuiPressed');
					timeout = setTimeout(function () { // Needs to be in a timer otherwise 1st inc is not displayed properly ???
						increment(inc);
						timeout = setTimeout(function () {
							timeout = undefined;
							interval = setInterval(function () {
								increment(inc);
							}, 100);
						}, 400);
					}, 1);
				}
			}
			function touchEnd(e) {
				cancelEvent(e);
				stopTimers();
				$(this).removeClass('jmuiPressed');
			}
			isStatic = !!slot.staticSlot;
			index = slot.index || 0;
			slotDiv = $(window.document.createElement('div'));
			slotDiv.addClass('jmuiSlot');
			if (isStatic) {
				slotDiv.addClass('jmuiStatic');
			}
			slotDiv.style('width', calcWidth());
			incDiv = $(window.document.createElement('div'));
			incDiv.html(isStatic ? '&nbsp;' : '+');
			slotDiv[0].appendChild(incDiv[0]);
			valDiv = $(window.document.createElement('div'));
			if (isStatic) {
				valDiv.text(slot.staticSlot);
			} else if (slot.choices.length > 0) {
				valDiv.val(slot.choices[index].value);
				valDiv.text(slot.choices[index].label);
			}
			slotDiv[0].appendChild(valDiv[0]);
			decDiv = $(window.document.createElement('div'));
			decDiv.html(isStatic ? '&nbsp;' : '-');
			slotDiv[0].appendChild(decDiv[0]);
			slotMachine[0].appendChild(slotDiv[0]);
			if (isStatic || slot.choices.length > 0) {
				if ($.isTouch) {
					incDiv.bind('touchstart', isStatic ? cancelEvent : touchStart);
					incDiv.bind('touchend', isStatic ? cancelEvent : touchEnd);
					decDiv.bind('touchstart', isStatic ? cancelEvent : touchStart);
					decDiv.bind('touchend', isStatic ? cancelEvent : touchEnd);
				} else {
					incDiv.bind('mousedown', isStatic ? cancelEvent : touchStart);
					incDiv.bind('mouseup', isStatic ? cancelEvent : touchEnd);
					incDiv.bind('mouseout', isStatic ? cancelEvent : touchEnd);
					decDiv.bind('mousedown', isStatic ? cancelEvent : touchStart);
					decDiv.bind('mouseup', isStatic ? cancelEvent : touchEnd);
					decDiv.bind('mouseout', isStatic ? cancelEvent : touchEnd);
				}
			}
			if ($.isTouch) {
				valDiv.bind('touchstart', cancelEvent);
				valDiv.bind('touchend', cancelEvent);
			} else {
				valDiv.bind('mousedown', cancelEvent);
				valDiv.bind('mouseup', cancelEvent);
			}
		}
		function addSlots() {
			var i, slotMachine;
			slotMachine = slotPage.find('.jmuiSlotMachine');
			slotMachine.empty();
			for (i = 0; i < slots.length; i += 1) {
				addSlot(slotMachine, slots[i]);
			}
		}
		function backButtonTap() {
			var values;
			values = [];
			slotPage.find('.jmuiSlot div:nth-child(2)').each(function () {
				values.push($(this).val());
			});
			if(parseInt(values[0]) > Date.getDaysInMonth(values[2],values[1]))  {
				window.mCapture.msgBox(function(){},"Invalid Date","Please enter a valid day for the selected month","OK");
				return;
			}else{
				backButton.unbind($.ui.tapEvent, backButtonTap);
				callback(values);
			}
		}
		if (!title || title.constructor !== String) {
			title = '';
		}
		if (!back || back.constructor !== String) {
			back = 'Back';
		}
		slotPage = column.find('.jmuiSlotPage');
		if (!slotPage || slotPage.length <= 0) {
			slotPage = $(window.document.createElement('div'));
			slotPage.addClass('jmuiPage', 'jmuiSlotPage');
			slotPage.html('<div class="jmuiHeader"><div class="jmuiToolbar"><h1>List</h1><div class="jmuiGoBack jmuiBackButton">Back</div></div></div><div class="jmuiNativeScroller"><div><div class="md_slotContainer"><h2></h2><ul><li class="jmuiColorPress"></li></ul></div><div class="jmuiSlotMachine"></div></div></div>');
			bindScroller(slotPage);
			column[0].appendChild(slotPage[0]);
		}
		li = slotPage.find('li');
		slotPage.find('h2').text(title);
		backButton = slotPage.find('.jmuiBackButton');
		backButton.text(back);
		generateTaps(backButton);
		backButton.bind($.ui.tapEvent, backButtonTap);
		slotPage.find('.jmuiToolbar > h1').text(title);
		addSlots();
		updateLi();
		gotoPage(slotPage, 'jmuiSlide', false, true);
	}
	/**
	* Display drop date page and update callers result when applicable
	*
	* @param	column
	*					jmfw object containing column element to display listPage
	* @param date
	*					Date object containing value of selected item
	* @param title
	*					String containing text to display in the title bar
	* @param backText
	*					String containing text to display in the back button
	* @param callback
	*					Function to call when back button is tapped
	*/

	function showDatePage(column, date, title, backText, callback) {
		var dateIndex, i, monthIndex, now, s, slot, slots, yearIndex;
		function slotPageCallback(values) {
			date = new Date(values[yearIndex], values[monthIndex], values[dateIndex]);
			callback(date);
		}
		now = new Date();
		dateIndex = Date.CultureInfo.dateElementOrder.indexOf('d');
		monthIndex = Date.CultureInfo.dateElementOrder.indexOf('m');
		yearIndex = Date.CultureInfo.dateElementOrder.indexOf('y');
		slots = [{
			choices: [],
			index: 0
		},
		{
			choices: [],
			index: 0
		},
		{
			choices: [],
			index: 0
		}];
		slot = slots[dateIndex];
		for (i = 1; i <= 31; i += 1) {
			s = (i < 10) ? '0' + i.toString() : i.toString();
			slot.choices.push({
				label: s,
				value: s
			});
		}
		slot.index = date.getDate() - 1;
		slot = slots[monthIndex];
		for (i = 0; i < 12; i += 1) {
			slot.choices.push({
				label: Date.CultureInfo.monthNames[i],
				value: i.toString()
			});
		}
		slot.index = date.getMonth();
		slot = slots[yearIndex];
		for (i = now.getFullYear() - 100; i <= now.getFullYear() + 100; i += 1) {
			slot.choices.push({
				label: i.toString(),
				value: i.toString()
			});
		}
		slot.index = 100 + date.getFullYear() - now.getFullYear();
		showSlotPage(column, slots, title, backText, slotPageCallback);
	}
	/**
	* Display drop range page and update callers result when applicable
	*
	* @param	column
	*					jmfw object containing column element to display listPage
	* @param value
	*					Number object containing value of selected item
	* @param min
	*					Number object containing the minimum value of the range
	* @param max
	*					Number object containing the maximum value of the range
	* @param increment
	*					Number object containing the increment step for the range
	* @param title
	*					String containing text to display in the title bar
	* @param backText
	*					String containing text to display in the back button
	* @param callback
	*					Function to call when back button is tapped
	*/

	function showRangePage(column, value, min, max, increment, title, backText, callback) {
		var i, slot;
		function slotPageCallback(values) {
			callback(values[0]);
		}
		slot = {
			choices: [],
			index: 0
		};
		for (i = min; i <= max; i += increment) {
			slot.choices.push({
				label: i.toString(),
				value: i.toString()
			});
			if (i === value) {
				slot.index = slot.choices.length - 1;
			}
		}
		showSlotPage(column, [slot], title, backText, slotPageCallback);
	}
	/**
	* Display drop time page and update callers result when applicable
	*
	* @param	column
	*					jmfw object containing column element to display listPage
	* @param time
	*					Date object containing value of selected item
	* @param title
	*					String containing text to display in the title bar
	* @param backText
	*					String containing text to display in the back button
	* @param callback
	*					Function to call when back button is tapped
	*/

	function showTimePage(column, time, increment, title, backText, callback) {
		var i, s, slot, slots;
		function slotPageCallback(values) {
			var time;
			time = new Date();
			time.setHours(values[0]);
			time.setMinutes(values[2]);
			callback(time);
		}
		slots = [{
			choices: [],
			index: 0
		},
		{
			staticSlot: ':'
		},
		{
			choices: [],
			index: 0
		}];
		slot = slots[0];
		for (i = 0; i < 24; i += 1) {
			s = (i < 10) ? '0' + i.toString() : i.toString();
			slot.choices.push({
				label: s,
				value: s
			});
		}
		slot.index = time.getHours();
		slot = slots[2];
		for (i = 0; i < 60; i += increment) {
			s = (i < 10) ? '0' + i.toString() : i.toString();
			slot.choices.push({
				label: s,
				value: s
			});
			if (i === time.getMinutes()) {
				slot.index = slot.choices.length - 1;
			}
		}
		showSlotPage(column, slots, title, backText, slotPageCallback);
	}
	/*
	* Fixup functions for page footer
	*/
	function fixupPageFooter() {
		var footer, currentStyle;
		footer = $('.jmuiPage.jmuiCurrent .jmuiFooter');
		if (footer[0]) {
			currentStyle = footer[0].style.cssText;
			footer.addClass('jmuiReturn');
			footer.hide();
		}
		//$('.jmuiPage.jmuiCurrent .jmuiFooter').hide();
		return currentStyle;
	}
	function fixupReturnPage(fromPage, storedStyle) {
		footer = $('.jmuiFooter.jmuiReturn ');
		if (footer[0]) {
			footer[0].style.cssText = storedStyle;
			footer = footer.removeClass('jmuiReturn');
		}
		//jmfw.ui.setScrollerHeight( jmfw('div.jmuiCurrent.jmuiPage') );
		function onReturnToPage(evt) {
			if (evt.direction === 'in') {
				fromPage.unbind('jmuiPageAnimationEnd', onReturnToPage);
				/* Hack for Android devices which are older than 4.4 */
				if ($.isAndroid && parseFloat(navigator.userAgent.match(/Android\s+([\d\.]+)/)[1]) < 4.4) {
					jQuery(el.parent().parent()[0]).focus();
				} else {
					$.ui.scrollToElement(el.parent().parent()[0]);
				}
			}
		}
		fromPage.bind('jmuiPageAnimationEnd', onReturnToPage);
	}
	/**
	* Display drop list page and update callers result when applicable
	*
	* @param	el
	*					jmfw object containing select or input[text] element
	* @param title
	*					String containing text to display in the title bar
	* @param backText
	*					String containing text to display in the back button
	*/

	function dropList(el, title, backText) {
		var choices, column, fromPage, storedStyle, footer;
		function addChoice(index, option) {
			var choice;
			index = undefined;
			choice = {
				label: option.innerText,
				value: el[0].nodeName === 'SELECT' ? option.value : option.innerText
			};
			choices.push(choice);
		}
		function callback(index, choice) {
			if (el[0].nodeName === 'SELECT') {
				if (index !== null && index !== undefined) {
					el[0].selectedIndex = index;
					el.trigger('change');
				}
			} else {
				if (choice !== null && choice !== undefined) {
					el[0].value = choice.label;
					el.trigger('change');
				}
			}
			fixupReturnPage(fromPage, storedStyle);
			gotoPage(fromPage, 'jmuiSlide', true, false);
		}
		storedStyle = fixupPageFooter();
		if (!title || title.constructor !== String) {
			title = '';
		}
		if (!backText || backText.constructor !== String) {
			backText = 'Back';
		}
		fromPage = $(parentPage(el[0]));
		column = $(fromPage[0].parentElement);
		choices = [];
		if (el[0].nodeName === 'SELECT') {
			el.find('option').each(addChoice);
		} else {
			$(el[0].previousElementSibling).find('option').each(addChoice);
		}
		if (el.hasClass('jmuiTumblers')) {
			showListTumblers(choices, el[0].value, callback);
		} else {
			showListPage(column, choices, el[0].value, title, backText, callback);
		}
	}
	/**
	* Display drop date page and update callers result when applicable
	*
	* @param	el
	*					jmfw object containing select or input[text] element
	* @param title
	*					String containing text to display in the title bar
	* @param backText
	*					String containing text to display in the back button
	*/

	function dropDate(el, title, backText) {
		var column, d, fromPage, storedStyle, footer;
		function callback(date) {
			el.text(date.toString(Date.CultureInfo.formatPatterns.longDate));
			el.trigger('change');
			fixupReturnPage(fromPage, storedStyle);
			gotoPage(fromPage, 'jmuiSlide', true, false);
		}
		storedStyle = fixupPageFooter();
		if (!title || title.constructor !== String) {
			title = '';
		}
		if (!backText || backText.constructor !== String) {
			backText = 'Back';
		}
		fromPage = $(parentPage(el[0]));
		column = $(fromPage[0].parentElement);
		d = new Date(el.text());
		d = isNaN(d.getTime()) ? new Date() : d;
		showDatePage(column, d, title, backText, callback);
	}
	/**
	* Display drop time page and update callers result when applicable
	*
	* @param	el
	*					jmfw object containing select or input[text] element
	* @param title
	*					String containing text to display in the title bar
	* @param backText
	*					String containing text to display in the back button
	*/

	function dropTime(el, title, backText) {
		var a, column, d, fromPage, increment, storedStyle, footer;
		function callback(date) {
			el.text(date.toString(Date.CultureInfo.formatPatterns.shortTime));
			el.trigger('change');
			fixupReturnPage(fromPage, storedStyle);
			gotoPage(fromPage, 'jmuiSlide', true, false);
		}
		storedStyle = fixupPageFooter();
		if (!title || title.constructor !== String) {
			title = '';
		}
		if (!backText || backText.constructor !== String) {
			backText = 'Back';
		}
		fromPage = $(parentPage(el[0]));
		column = $(fromPage[0].parentElement);
		increment = parseInt(el.attr('increment'), 10) % 60 || 5;
		d = new Date();
		a = el.text().split(':', 2);
		if (a.length === 2) {
			d = new Date(d.getYear(), d.getMonth(), d.getDate(), a[0], a[1], 0, 0);
			d = isNaN(d.getTime()) ? new Date() : d;
		}
		d.setMinutes(d.getMinutes() - d.getMinutes() % increment);
		showTimePage(column, d, increment, title, backText, callback);
	}
	/**
	* Display drop range page and update callers result when applicable
	*
	* @param	el
	*					jmfw object containing select or input[text] element
	* @param title
	*					String containing text to display in the title bar
	* @param backText
	*					String containing text to display in the back button
	*/

	function dropRange(el, title, backText) {
		var column, fromPage, increment, min, max, value, storedStyle, footer;
		function callback(value) {
			el.text(value.toString());
			el.trigger('change');

			fixupReturnPage(fromPage, storedStyle);
			gotoPage(fromPage, 'jmuiSlide', true, false);
		}
		storedStyle = fixupPageFooter();
		if (!title || title.constructor !== String) {
			title = '';
		}
		if (!backText || backText.constructor !== String) {
			backText = 'Back';
		}
		fromPage = $(parentPage(el[0]));
		column = $(fromPage[0].parentElement);
		increment = parseInt(el.attr('increment'), 10) || 1;
		min = parseInt(el.attr('min'), 10) || 0;
		max = parseInt(el.attr('max'), 10) || min + increment * 100;
		if (max < min) {
			max = min;
		}
		value = parseInt(el.text(), 10);
		showRangePage(column, value, min, max, increment, title, backText, callback);

	}
	/**
	* Bind all child button divs of the supplied parent. 
	*
	* @param parent
	*					optional jmfw object containing parent element for which child button
	*					div elements are to be bound.
	*/

	function bindButtons(parent) {
		parent = !parent ? $(window.document) : parent;
		generateTaps(parent.find('.jmuiToolButton, .jmuiDeleteButton, .jmuiCancelButton, .jmuiBackButton, .jmuiAddButton, .jmuiActionButton'));
	}
	/**
	* Bind all child checkbox elements of the supplied parent. 
	*
	* @param parent
	*					optional jmfw object containing parent element for which child checkbox
	*					elements are to be bound.
	*/

	function bindCheckboxes(parent) {
		parent = !parent ? $(window.document) : parent;
		//chromium on android 4.1 doesnt find this with the .jmuiLayout
		//parent.find('.jmuiLayout input[type="checkbox"]').each(function () {
		//I can't see why the .jmuiLayout necessary
		//However, we only want to bind for inline questions
		//because popup checkboxes are only updated into the answer when the editor
		//page is saved
		
		// Graham: I've taken out this test, since it seems to break the Nexus7 2013 on popups
		// and I think it works better when you can tap on the whole li, rather than 
		// on the tiny checkbox:
		// if (parent.hasClass('checkboxInline')) {
			parent.find('input[type="checkbox"]').each(function () {
				var li, me;
				// If it's not an <li> tag, then it's going to be a toggle. We don't want toggles.
				if (this.parentElement.tagName === 'LI') {
				    me = $(this);
				    me.bind('click', cancelEvent);
				    li = $(this.parentElement);
				    generateTaps(li);
				    li.bind($.ui.tapEvent, function (e) {
					    if (!$.ui.defaultPrevented(e)) {
						    e.preventDefault();
						    me[0].checked = !me[0].checked;
						    // me.trigger('change');
						    me.trigger('jmuiChange');
					    }
				    });
				}
			});
		//}
	}
	/**
	* Bind column element. Setup auto-linking and maintain page history.
	*
	* @param column
	*					jmfw object containing column element to be bound.
	*/

	function bindColumn(column) {
		var history;
		function navTap(e) {
			var back, cause, o, target;
			if (!$.ui.defaultPrevented(e)) {
				o = $(e.target);
				target = o.attr('jmuiTarget');
				back = o.hasClass('jmuiGoBack');
				if (!target && back === true && history.length > 0) {
					cause = history.pop();
					target = cause.selector;
				}
				if (target) {
					if (back === false) {
						cause = {
							animation: o.hasClass('jmuiAddButton') ? 'jmuiSlideup' : 'jmuiSlide',
							selector: '#' + column.find('.jmuiCurrent')[0].id
						};
						history.push(cause);
					}
					gotoPage($(target), cause.animation, back);
				}
			}
		}
		history = [];
		column.find('.jmuiGoTo, .jmuiGoBack').each(function () {
			var me;
			me = $(this);
			me.unbind($.ui.tapEvent, navTap);
			me.bind($.ui.tapEvent, navTap);
		});
	}
	/**
	* Bind all child column elements of the supplied parent. Setup auto-linking
	* and maintain page history for each column.
	*
	* @param parent
	*					optional jmfw object containing parent element for which child columns
	*					are to be bound.
	*/

	function bindColumns(parent) {
		parent = !parent ? $(window.document) : parent;
		parent.find('.jmuiColumn').each(function () {
			bindColumn($(this));
		});
	}
	/**
	* Bind all child date elements of the supplied parent. 
	*
	* @param parent
	*					optional jmfw object containing parent element for which child date
	*					elements are to be bound.
	*/

	function bindDates(parent) {
		var days, i, maxDays, months;
		if (Date.hasOwnProperty('CultureInfo')) {
			parent = !parent ? $(window.document) : parent;
			months = {};
			for (i = 0; i < 12; i += 1) {
				months[i] = Date.CultureInfo.monthNames[i];
			}
			maxDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
			days = {};
			for (i = 1; i <= 31; i += 1) {
				days[i] = i;
			}
			parent.find('.jmuiCompositeDate').each(function () {
				var clear, editor, li, page;
				editor = $(this);
				li = $(this.parentElement);
				li.addClass('jmuiColorPress');
				page = $($.ui.parentPage(li[0]));
				generateTaps(li);
				li.bind($.ui.tapEvent, function (e) {
					var title;
					if ($(e.jmuiTarget).hasClass('jmuiCompositeClear') !== true) {
						title = getCompositeTitle(editor[0]);
						dropDate(editor, title, page.find('.jmuiToolbar > h1').text());
					}
				});
				if (editor[0].previousElementSibling) {
					clear = $(editor[0].previousElementSibling);
					if (clear && clear.hasClass('jmuiCompositeClear')) {
						generateTaps(clear);
						clear.bind($.ui.tapEvent, function () {
							if (editor.html() !== '&nbsp;') {
								editor.html('&nbsp;');
								editor.trigger('change');
							}
						});
					}
				}
			});
		}
	}
	/**
	* Bind all child mask elements of the supplied parent. 
	*
	* @param parent
	*					optional jmfw object containing parent element for which child mask
	*					elements are to be bound.
	*/
	function bindMasks(parent) {
		parent = !parent ? $(window.document) : parent;
		parent.find('.jmuiMask').each(function () {
			var arrow, editor, mask, page, title;
			function arrowClick() {
				if (arrow.hasClass('jmuiCompositeClear')) {
					editor[0].value = '';
				} else if (arrow.hasClass('jmuiCompositeArrow')) {
					title = getCompositeTitle(mask[0]);
					dropList(editor, title, page.find('.jmuiToolbar > h1').text());
				}
			}
			mask = $(this);
			page = $(parentPage(this));
			generateTaps(mask);
			editor = $(mask[0].previousElementSibling);
			if (editor && editor.hasClass('jmuiCompositeInput')) {
				arrow = $(editor[0].previousElementSibling);
				if (arrow && arrow.length) {
					page.bind('jmuiPageAnimationStart', function () {
						mask.style('right', arrow[0].offsetWidth + 'px'); // Don't let the mask cover the arrow
					});
					mask.style('right', arrow[0].offsetWidth + 'px'); // Don't let the mask cover the arrow
					generateTaps(arrow);
					arrow.bind($.ui.tapEvent, arrowClick);
				}
				editor = $(editor[0].firstElementChild);
				while (editor && editor.length === 1 && editor.style('display') === 'none') {
					editor = $(editor[0].nextElementSibling);
				}
			}
			mask.bind($.ui.tapEvent, function () {
				var title;
				if (editor[0].nodeName === 'SELECT') {
					title = getCompositeTitle(mask[0]);
					dropList(editor, title, page.find('.jmuiToolbar > h1').text());
				} else {
					editor[0].focus(); // device keyboard pops up in 300ms during next click which we ignore for text fields
				}
			});
			mask.bind('click', function (e) {
				if (editor[0].nodeName === 'SELECT') {
					cancelEvent(e); // Prevent browser default selection UI
				} else {
					editor[0].focus(); // device keyboard pops up in 300ms during next click which we ignore for text fields
				}
			});
			if ($.isIE && editor[0].nodeName === 'SELECT') {
				editor.removeAttr('disabled');
				mask.remove();
/*
				$.ui.generateTaps(editor);
				editor.bind($.ui.tapEvent, function (e) {
					var title;
					cancelEvent(e);
					title = getCompositeTitle(mask[0]);
					dropList(editor, title, page.find('.jmuiToolbar > h1').text());
				});
*/
			}
		});
		// Handle edit focus & mask visiblity
		$('.jmuiLayout textarea, .jmuiLayout input[type="text"], .jmuiLayout input[type="password"]').each(function () {
			var mask, me;
			function enableKeyboardEditors(page, enable, focusedEditor) {
				page.find('textarea, input[type="text"], input[type="password"], select').each(function () {
					if (!focusedEditor || !focusedEditor.length || this !== focusedEditor[0]) {
						if (enable) {
							if (this.hasOwnProperty('jmuiDisabled')) {
								this.disabled = this.jmuiDisabled;
								delete this.jmuiDisabled;
							} else {
								this.disabled = false;
							}
						} else {
							this.jmuiDisabled = this.disabled;
							this.disabled = true;
						}
					}
				});
			}
			if (parentElement(this, 'jmuiScroller')) {
				me = $(this);
				if ($(this.parentElement).hasClass('jmuiCompositeInput')) {
					mask = this.parentElement.nextElementSibling;
				} else {
					mask = this.nextElementSibling;
				}
				if (mask) {
					me.bind('focus', function () {
						mask.style.left = me.width() + me[0].offsetLeft + 'px';
						enableKeyboardEditors($($.ui.parentPage(this)), false, me);
					});
					me.bind('blur', function () {
						mask.style.left = '0px';
						enableKeyboardEditors($($.ui.parentPage(this)), true, me);
					});
				}
			}
		});
	}
	/**
	* Bind all child number elements of the supplied parent. 
	*
	* @param parent
	*					optional jmfw object containing parent element for which child number
	*					elements are to be bound.
	*/
	function bindNumbers(parent) {
		var numbers;
		parent = !parent ? $(window.document) : parent;
		numbers = {
			0: 0,
			1: 1,
			2: 2,
			3: 3,
			4: 4,
			5: 5,
			6: 6,
			7: 7,
			8: 8,
			9: 9
		};
		parent.find('.jmuiCompositeNumber').each(function () {
			var clear, editor, li, page;
			editor = $(this);
			li = $(this.parentElement);
			li.addClass('jmuiColorPress');
			page = $($.ui.parentPage(li[0]));
			generateTaps(li);
			li.bind($.ui.tapEvent, function (e) {
				var title;
				if ($(e.jmuiTarget).hasClass('jmuiCompositeClear') !== true) {
					title = getCompositeTitle(editor[0]);
					dropRange(editor, title, page.find('.jmuiToolbar > h1').text());
				}
			});
			if (editor[0].previousElementSibling) {
				clear = $(editor[0].previousElementSibling);
				if (clear && clear.hasClass('jmuiCompositeClear')) {
					generateTaps(clear);
					clear.bind($.ui.tapEvent, function () {
						if (editor.html() !== '&nbsp;') {
							editor.html('&nbsp;');
							editor.trigger('change');
						}
					});
				}
			}
		});
	}
	/**
	* Bind all child radio elements of the supplied parent. 
	*
	* @param parent
	*					optional jmfw object containing parent element for which child radio
	*					elements are to be bound.
	*/
	function bindRadios(parent) {
		var context = '';
		if(!parent){
			parent = $(window.document);
			context = '.jmuiLayout';
		}
		parent.find(context + ' input[type="radio"]').each(function () {
			var li, me;
			me = $(this);
			me.bind('click', cancelEvent);
			li = $(this.parentElement);
			generateTaps(li);
			li.bind($.ui.tapEvent, function () {
				if (!me[0].checked) {
					me[0].checked = true;
					me.trigger('change');
				}
			});
		});
	}
	/**
	* Bind all child scroller elements of the supplied parent. 
	*
	* @param parent
	*					optional jmfw object containing parent element for which child scroller
	*					elements are to be bound.
	*/
	function bindScrollers(parent) {
		parent = !parent ? $(window.document) : parent;
		if (parent.hasClass('jmuiPage')) {
			bindScroller(parent);
		} else {
			parent.find('.jmuiPage').each(function () {
				bindScroller($(this));
			});
		}
	}
	/**
	* Bind all child segment groups of the supplied parent. 
	*
	* @param parent
	*					optional jmfw object containing parent element for which child segment
	*					group elements are to be bound.
	*/
	function bindSegments(parent) {
		parent = !parent ? $(window.document) : parent;
		function segmentButtonClick() {
			var button, segmentId;
			button = $(this);
			if (!button.hasClass('jmuiSelected')) {
				segmentId = button.attr('jmuiSegmentId');
				showSegment(segmentId);
			}
		}
		generateTaps(parent.find('.jmuiSegmentButton').bind($.ui.tapEvent, segmentButtonClick));
	}
	/**
	* Bind all child time elements of the supplied parent. 
	*
	* @param parent
	*					optional jmfw object containing parent element for which child time
	*					elements are to be bound.
	*/

	function bindTimes(parent) {
		var hours, minutes;
		parent = !parent ? $(window.document) : parent;
		hours = {
			0: '00',
			1: '01',
			2: '02',
			3: '03',
			4: '04',
			5: '05',
			6: '06',
			7: '07',
			8: '08',
			9: '09',
			10: '10',
			11: '11',
			12: '12',
			13: '13',
			14: '14',
			15: '15',
			16: '16',
			17: '17',
			18: '18',
			19: '19',
			20: '20',
			21: '21',
			22: '22',
			23: '23'
		};
		minutes = {
			0: '00',
			5: '05',
			10: '10',
			15: '15',
			20: '20',
			25: '25',
			30: '30',
			35: '35',
			40: '40',
			45: '45',
			50: '50',
			55: '55'
		};
		parent.find('.jmuiCompositeTime').each(function () {
			var clear, editor, li, page;
			editor = $(this);
			li = $(this.parentElement);
			li.addClass('jmuiColorPress');
			page = $($.ui.parentPage(li[0]));
			generateTaps(li);
			li.bind($.ui.tapEvent, function (e) {
				var title;
				if ($(e.jmuiTarget).hasClass('jmuiCompositeClear') !== true) {
					title = getCompositeTitle(editor[0]);
					dropTime(editor, title, page.find('.jmuiToolbar > h1').text());
				}
			});
			if (editor[0].previousElementSibling) {
				clear = $(editor[0].previousElementSibling);
				if (clear && clear.hasClass('jmuiCompositeClear')) {
					generateTaps(clear);
					clear.bind($.ui.tapEvent, function () {
						if (editor.html() !== '&nbsp;') {
							editor.html('&nbsp;');
							editor.trigger('change');
						}
					});
				}
			}
		});
	}
	/**
	* Bind all jmui parts of a dynamically created page to the relevant functions.
	* Call bindPage only for dynamically created pages which do not exist at 
	* $.ready time
	*
	* @param	page
	*					jmfw object containing page div to bind to
	*/
	function bindPage(page) {
		var bound;

		function bind() {
			bound = true;
			bindButtons(page);
			bindScrollers(page);
			bindMasks(page);
			bindCheckboxes(page);
			bindRadios(page);
			bindDates(page);
			bindTimes(page);
			bindNumbers(page);
			bindSegments(page);
		}

		function onPageBind(e) {
			e = undefined;
			if (!bound) {
				bind();
				page.unbind('jmuiPageBind', onPageBind);
			}
		}
		bound = false;
		if (page.hasClass('jmuiCurrent')) {
			bind();
		} else {
			page.bind('jmuiPageBind', onPageBind);
		}
	}
	/**
	* Bind all child pages of the supplied parent.
	*
	* @param	parent
	*					jmfw object containing child pages to bind
	*/
	function bindPages(parent) {
		parent.find('.jmuiPage').each(function () {
			bindPage($(this));
		});
	}
	/**
	* Bind layout element
	*
	* @param layout
	*					jmfw object containing layout element to be bound
	*/
	function bindLayout(layout) {
		// Forward layout animation events to current pages
		layout.bind('jmuiLayoutAnimationStart', function (e) {
			if (!$.ui.defaultPrevented(e)) {
				e.preventDefault();
				layout.find('.jmuiPage.jmuiCurrent').trigger('jmuiPageAnimationStart', {
					direction: e.direction,
					reverse: e.reverse
				});
			}
		});
		layout.bind('jmuiLayoutAnimationEnd', function (e) {
			if (!$.ui.defaultPrevented(e)) {
				e.preventDefault();
				layout.find('.jmuiPage.jmuiCurrent').trigger('jmuiPageAnimationEnd', {
					direction: e.direction,
					reverse: e.reverse
				});
			}
		});
		bindPages(layout);
	}
	/**
	* Bind all child layout elements of the supplied parent. 
	*
	* @param parent
	*					optional jmfw object containing parent element for which child layout
	*					elements are to be bound.
	*/
	function bindLayouts(parent) {
		parent = !parent ? $(window.document) : parent;
		parent.find('.jmuiLayout').each(function () {
			bindLayout($(this));
		});
	}
	function ready() {
		function hashChange(e) {
			var id;
			e = undefined;
			if (ignoreHashChange) {
				ignoreHashChange = false;
			} else {
				id = $('.jmuiLayout.jmuiCurrent .jmuiPage.jmuiCurrent')[0].id;
				location.hash = id;
			}
		}
		$(window).bind('resize', resize);
		$(window).bind('hashchange', hashChange);
		ignoreHashChange = true;
		resize(); // Ensure elements are initially sized correctly
		bindLayouts();
		bindColumns();
		/*
		bindButtons();
		bindScrollers();
		bindColumns();
		bindMasks();
		bindCheckboxes();
		bindRadios();
		bindDates();
		bindTimes();
		bindNumbers();
		bindSegments();
		*/
	}
	if ($.isIE) {
		$('body').addClass('jmuiWp8');
	}

	if (window.AnimationEvent !== undefined) {
		animationEnd = 'animationend';
	} else if (window.WebKitAnimationEvent !== undefined) {
		animationEnd = 'webkitAnimationEvent';
	}
	if (window.TransitionEvent !== undefined) {
		transitionEnd = 'transitionend';
	} else if (window.WebKitTransitionEvent !== undefined) {
		transitionEnd = 'webkitTransitionEnd';
	}
	// Prevent all default touch behaviour in scrollable pages
	$(window.document).bind('touchmove', function (e) {
		var page, scroller;
		if (!$.ui.defaultPrevented(e)) {
			page = parentPage(e.srcElement);
			if (page) {
				scroller = $(page).find('.jmuiScroller');
				if (scroller.length > 0) {
					e.preventDefault();
				}
			}
		}
	});
	// Setup initialization function to be called when DOM is ready
	$.ready(ready);
	// Cleanup iScroll global variable
	if (window.iScroll) {
		$.iScroll = window.iScroll;
		delete window.iScroll;
	}
	// Cleanup SpinningWheel global variable
	if (window.SpinningWheel) {
		$.spinningWheel = window.SpinningWheel;
		delete window.SpinningWheel;
	}
	// Setup the password mask text
	passwordMask = '&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;';
	// Expose ourself to the world
	$.ui = {
		bindCheckboxes: bindCheckboxes,
		bindColumn: bindColumn,
		bindColumns: bindColumns,
		bindDates: bindDates,
		bindLayout: bindLayout,
		bindLayouts: bindLayouts,
		bindMasks: bindMasks,
		bindNumbers: bindNumbers,
		bindPage: bindPage,
		bindRadios: bindRadios,
		bindScrollers: bindScrollers,
		bindSegments: bindSegments,
		bindTimes: bindTimes,
		cancelEvent: cancelEvent,
		defaultPrevented: defaultPrevented,
		eventPosition: eventPosition,
		generateTaps: generateTaps,
		gotoPage: gotoPage,
		isScrollable: true,
		parentColumn: parentColumn,
		parentElement: parentElement,
		parentLayout: parentLayout,
		parentPage: parentPage,
		passwordMask: passwordMask,
		refreshScroller: refreshScroller,
		scrollOrigin: scrollOrigin,
		scrollToElement: scrollToElement,
		setScrollerHeight: setScrollerHeight,
		showListPage: showListPage,
		showSlotPage: showSlotPage,
		showSegment: showSegment,
		tapAndHoldEvent: 'jmuiTapAndHold',
		//tapEvent: $.isBlackberry ? 'click' : 'jmuiTap'
		tapEvent: 'jmuiTap'
		//tapEvent: ($.isBlackberry || !$.isTouch) ? 'click' : 'jmuiTap'
	};
} (window.jmfw));
/*jslint browser: true, devel: true, bitwise: true, continue: true, evil: true, forin: true, nomen: true, plusplus: true, regexp: true, sloppy: true, white: true */
var mCapture;
if (typeof Object.create !== 'function') {
	Object.create = function(o) {
		function F() {}
		F.prototype = o;
		return new F();
	};
}
/* patch window.alert for platforms without */
if (typeof window.alert !== 'function') {
    window.alert = function (message) {
        if (window.navigator.notification && window.navigator.notification.alert) {
            window.navigator.notification.alert(message);
        } else {
            window.console.warn('Cannot display alert - dialogs plugin not loaded. Message: ' + message);
        }
    }
};
/* global error handler - log error and prevent Windows8 shell crashes */
window.onerror = function (message, url, line, column, error) {
    var logger = log || console;
    if (logger) {
        logger.error('Unhandled script exception: ' + message);
        logger.error('Unhandled script exception url: ' + url);
        logger.error('Unhandled script exception line: ' + line + ' column: ' + column);
        logger.error(error);
    }
    return true;
};
mCapture = (function($) {
    var activityBusy, activityBusyTmo, activityCount, dateFormat, mc, oldActivityCount, preNotifyCount, testingInBrowser, cordovaready = false, rootPath, counterName = 'MCAPTURE_ProcessProvisioning_cacheCheckingEvents', displayingMsgBox = false;
    // Listen for phonegap ready
    function phonegapReady() {
        // Use the "phonegapReady" function to detect that phonegap is present
        //debugger;
        cordovaready = true;
		
		var split = device.version.split('.');
		
		var version = 'version_';
		if( split.length >= 1 ) {
			version += split[0];
			if( split.length >= 2 ) {
				version += '_' + split[1];
			}
		}
		//if( split.length >= 3 )
		//	version += '_' + split[2];
		
		if( split.length >= 2 && device.platform.toLowerCase() === 'android' ) {
			if( split[0] == '4' && split[1] >= 1 && split[1] <= 3 ) {
				$('body').addClass('version_4_1_to_4_3');
			}
		}
				
		$('body').addClass('platform_'+device.platform.toLowerCase());
		$('body').addClass(version);
		if (device.model) {
		    $('body').addClass('model_'+device.model.replace(/\s+/g, '_').toLowerCase());
		}
    }
    window.document.addEventListener("deviceready", phonegapReady, false);

    // If phonegap was detected in loader.html or index.html, then this will have been set.
    function phonegapPresent() {
        return !!window.localStorage.phonegapPresent;
    }
    
    // Reports the value passed in by ppautil, or the default for the server ('mdesign')
    function getShellType() {
        return window.localStorage.shellType;
    }

    function profiler() {
        var active, results;

        function clear(isActive) {
            active = !!isActive;
            results = {};
        }

        function getResults() {
            return results;
        }

        function profileSync(name, callback) {
            var d, r;
            if (active) {
                d = new Date();
            }
            r = callback();
            if (active) {
                d = (new Date() - d) / 1000;
                results[name] = d;
            }
            return r;
        }

        function profileAsync(name, callback) {
            var d;

            function complete() {
                if (active) {
                    d = (new Date() - d) / 1000;
                    results[name] = d;
                }
            }
            if (active) {
                d = new Date();
            }
            return callback(complete);
        }
        clear(false);
        return {
            clear: clear,
            getResults: getResults,
            profileAsync: profileAsync,
            profileSync: profileSync
        };
    }

    function getObjectClass(o) {
			var type;
			if (o === null) {
				return 'null';
			}
			type = typeof o;
			if (type !== 'object') {
				if (type === 'number' && isNaN(o)) {
					return 'nan';
				}
				return type.toLowerCase();
			}
			if (o.constructor) {
				if (o.constructor.name) {
					/*
					*  for browsers which have name property in the constructor
					*  of the object,such as chrome but not IE
					*/
					return o.constructor.name.toLowerCase();
				}
			}
			switch (o.constructor) {
				case Array:
					return 'array';
				case String:
					return 'string';
				case Function:
					return 'function';
				case Number:
					return 'number';
				case Boolean:
					return 'boolean';
				case Date:
					return 'date';
				default:
					if (o.constructor.toString()) {
						var str = o.constructor.toString();
						var arr;
						if(str.charAt(0) == '[') {
							/*
							* executed if the return of object.constructor.toString() is 
							* "[object objectClass]"
							*/
							arr  = str.match(/\[\w+\s*(\w+)\]/);
						} else {
							/*
							 * executed if the return of object.constructor.toString() is 
							 * "function objectClass () {}"
							 * for IE Firefox
							 */
							arr = str.match(/function\s*(\w+)/);
						}
						if (arr && arr.length == 2) {
							return arr[1];
						}
						return o.constructor.toString();
					}
			}
			return '???';
    }

    function currentPage(currentPageId) {
        if (currentPageId === undefined) {
            return mc.db.getMetaValue('currentPageId');
        }
        mc.db.setMetaValue('currentPageId', currentPageId);
    }

    function notificationAreaTap(e) {
        function postNotifyError(e) {
            log.warn(e);
            showNotificationIndicator(false);
        }
        function postNotifySuccess(r) {
            if (r) {
                showNotificationIndicator(false);
            } else {
                refreshNotificationIndicator();
            }
        }
        if (!e.defaultPrevented && e.jmuiTarget && (e.jmuiTarget.nodeName === 'H1' || $(e.jmuiTarget).hasClass('jmuiToolbar'))) {
            e.preventDefault();
            if (mc.fl.postNotification) {
                mc.fl.execFormula('postNotification', postNotifySuccess, postNotifyError, true);
            } else {
                postNotifyError('No notification tap handler installed');
            }
        }
    }

    function showNotificationIndicator(show) {
        if (show) {
            $('body').addClass('mdcUnreadNotifications');
            $.ui.generateTaps($('.jmuiCurrent h1')).bind($.ui.tapEvent, notificationAreaTap);
        } else {
            $('body').removeClass('mdcUnreadNotifications');
            $('.jmuiCurrent h1').unbind($.ui.tapEvent, notificationAreaTap);
        }
    }

    function refreshNotificationIndicator() {
        var user;
        user = mc.db.getUserInfo();
        mc.notify.service.getUnreadMessages(user.mSuiteUserName, user.mSuiteUserName, undefined, function(e, messages) {
            showNotificationIndicator(messages && messages.length);
        });
    }

    function showActivity() {
		if (activityCount <= 0) {
			activityCount = 1;
			doShowActivity();
		} else {
			activityCount += 1;
			oldActivityCount += 1;
		}
    }
    
    function doShowActivity() {
		if (displayingMsgBox)
			return;
		var mask;
		$(':focus').blur(); // Force save of focused field
		mask = $(document.createElement('div'));
		mask.addClass('activity');
		if (!jmfw.isIE) {
			activityBusyTmo = setTimeout(function() {
				activityBusyTmo = undefined;
				activityBusy = true;
				mask.html('<div></div>');
			}, 500);
		} else {
			mask.html('<div></div>');
		}
		document.body.appendChild(mask[0]);
	}

    function hideActivity(force) {
		if (force) {
			activityCount = 0;
			oldActivityCount = 0;
		} else {
			activityCount -= 1;
			oldActivityCount -= 1;
		}

		if (activityCount <= 0) {
			activityCount = 0;
			if (activityBusyTmo !== undefined) {
				clearTimeout(activityBusyTmo);
				activityBusyTmo = undefined;
			}

			doHideActivity();
		}
    }

	function doHideActivity() {
		if (displayingMsgBox)
			return;

		//turn the navigator activity off regardless
		//if we have forced the acivity off or we have counted it down
		//it should be off anyway
		//if we have reprovisioned the busy flag will be gone
		//but the indicator may still be showing
		activityBusy = false;
		$('.activity').remove();
	}

    function msgBox(callback, caption, message) {
        var btn, box, container, i, m, mlist, splash, hider;
        log.debug('msbox - caption : ' + caption + ' message : ' + message);

        function btnClick(e) {
            var btn, text;
            log.debug('msbox button clicked : ' + e);
            if (!$.ui.defaultPrevented(e)) {
                e.preventDefault();
                e.stopPropagation();
                btn = $(this);
                text = btn.text();
                box.find('.msgBoxButton').unbind('click', btnClick);
                box.find('.msgBoxButton').unbind('touchstart', btnClick);
                setTimeout(function() {
                    log.debug('msbox remove');
                    if( hider ) {
                        hider.remove();
                    }
                    displayingMsgBox = false;
					if (activityCount > 0) 
						doShowActivity();
                    container.remove();
                    splash.remove();
                    if (callback) {
                        callback(text);
                    }
                }, 100);
            }
        }
        container = $('#msgBoxContainer');
        if (container.length) {
            log.error('msbox function called whilst already displaying a message - caption : ' + caption + ' message : ' + message);
            callback('');
            return;
        }
        $(':focus').blur(); // Force save of focused field
        splash = $(document.createElement('div'));
        splash[0].id = 'msgBoxSplash';
        container = $(document.createElement('div'));
        container[0].id = 'msgBoxContainer';
        box = $(container[0].appendChild(document.createElement('div')));
        if (caption) {
            box[0].appendChild(document.createElement('h1')).innerText = caption;
        }
        if (message) {
            mlist = message.split('|');
            if (mlist.constructor === Array) {
                for (m = 0; m < mlist.length; m++) {
                    box[0].appendChild(document.createElement('p')).innerText = mlist[m];
                }
            } else {
                box[0].appendChild(document.createElement('p')).innerText = message;
            }
        }
        for (i = 3; i < arguments.length; i += 1) {
            btn = $(box[0].appendChild(document.createElement('div')));
            btn.addClass('msgBoxButton');
            btn.text(arguments[i]);
            $.ui.generateTaps(btn.bind($.ui.tapEvent, btnClick));
        }
        document.body.appendChild(splash[0]);
        document.body.appendChild(container[0]);
        
        // For WP8:
        hider = $(document.createElement('div'));
		hider[0].id = 'msgBoxContainerHider';
		document.body.appendChild(hider[0]);
		
		$('#msgBoxContainerHider').bind('click', function(e) {
			console.log("Clicked the hider panel");
		});
        
		container.style('left', '1px');
        setTimeout(function() {
			container.style('left', '0px');
        }, 0);
        
        oldActivityCount = activityCount;
        if (oldActivityCount) {
            activityCount = 1;
            hideActivity();
        }
        
        if (activityCount > 0) 
			doHideActivity();
		displayingMsgBox = true;
    }

    function getDateFormat() {
        return dateFormat;
    }

    function getPreNotifyCount() {
        return preNotifyCount;
    }

    function updateCheckingEvents(value) {
        countCheckingEvents();
        if (value > 0) {
            localStorage[counterName] = parseFloat(localStorage[counterName]) + 1;
        } else {
            localStorage[counterName] = 0;
        }
    }
    
    function countCheckingEvents() {
        if (localStorage[counterName] === undefined) {
            localStorage[counterName] = 0;
        }
        return parseFloat(localStorage[counterName]);
    }
 
 	function addCacheListeners() {
 		function resetCheckingEvents( ) {
 			updateCheckingEvents(0);	
 		}
 		var cache = window.ctAppCache;
 		if (cache) {
			cache.addEventListener('checking', resetCheckingEvents, false); 
			cache.addEventListener('downloading', resetCheckingEvents, false); 
			cache.addEventListener('noupdate', resetCheckingEvents, false); 
			cache.addEventListener('updateready', resetCheckingEvents, false); 
			cache.addEventListener('progress', resetCheckingEvents, false); 
			cache.addEventListener('cached', resetCheckingEvents, false); 
			log.debug('Added cache listeners');	
		}
 	} 
 	  
    function gotoUrl(url, showActivity) {
        var currentProcess, currentSubjectGuid, subjectStack, cache, targetUrl, badEvents;
        function failedToProvision(fromWhere) {
            aborted = true;
            function done(URL) {
                log.debug('On our way home to ' + URL);
            }
            log.debug('Process provisioning error - ' + fromWhere);
            if (typeof (mc) !== 'undefined') {
                mc.msgBox(function(text) {
                    log.debug('Calling mc.fl.gotoprovisioningurl');
                    mc.fl.gotoprovisioningurl(done);
                }, 'Provisioning Error', 'You must retry the operation. Reason: ' + fromWhere, 'OK');
            } else {
                log.debug('Changing location to ../../index.html');
                window.localStorage.provisionedState = '';
                window.MCAPTURE_Provisioning_Processes = true;
                window.locationUtils.setHref('../../index.html');
            }
        }
        function warnAndGoHome() {
            mc.fl.msgboxasync(goHome, 'There may be new process versions to be tested. The application will now be reloaded');
        }
        function checkCacheState(callback) {
            function isTesting() {
                return window.localStorage.getItem('isTesting') === 'yes';
            }

            log.debug('Check if cache update required gotoUrl');
            var cache = window.ctAppCache;
            try {
                log.debug('Current cache status=' + cache.status);
                /*
                cache.removeEventListener('checking', checkingEventListener, false); 
                cache.removeEventListener('downloading', downloadingEventListener, false); 
                cache.removeEventListener('noupdate', noUpdateEventListener, false); 
                cache.removeEventListener('updateready', updateReadyEventListener, false); 
                cache.removeEventListener('progress', progressEventListener, false); 
                cache.removeEventListener('cached', cachedEventListener, false); 
                cache.removeEventListener('error', errorEventListener, false); 
                cache.removeEventListener('obsolete', obsoleteEventListener, false); 
                */
                switch (cache.status) {
                    case 0:
                        log.debug('Current cache status uncached');
                        updateCheckingEvents(0);
                        //cache.update(); //see if the cache has been updated
                        break;
                    case 1:
                        log.debug('Current cache status idle');
                        updateCheckingEvents(0);
                        //cache.update(); //see if the cache has been updated
                        break;
                    case 2:
                        log.debug('Current cache status checking for update');
                        break;
                    case 3:
                        log.debug('Current cache status downloading');
                        break;
                    case 4:
                        log.debug('Current cache status update ready');
                        updateCheckingEvents(0);
                        // There is a cache update available. The browser will apply
                        // the update when we navigate to the new url and there is nothing
                        // we can do to prevent this. We are worried about processes that have been 
                        // deleted from the fileset. The UPV cookie should prevent this happening
                        // in production, so we are trying to deal with the testing case.
                        // The UPV cookie isn't updated with single subject processes
                        // that have the delete on close/force attribute so we still have a problem
                        // If we don't rebuild the process list after the cache swap we will
                        // try to open process versions that may no longer exist on the device.
                        // When that happens we request the url from the server and if we are
                        // online at that point, the server sends an error page with a retry button that
                        // sends us back to the index.
                        // That should force us to clear the provisioning control indicators
                        // so that we set up the new process vesrions in memory and local storage
                        // We need to force the user though that process on the device instead
                        // of requesting the url from the server because the device might because
                        // the device might be offline
                        cache.swapCache();
                        //if (isTesting()) {
                            warnAndGoHome();
                            return;
                        //}
                        break;
                    case 5:
                        log.debug('Current cache status obsolete');
                        updateCheckingEvents(0);
                        break;
                    default:
                        log.debug('Current cache status unknown = ' + cache.status);
                        //cache.update(); //see if the cache has been updated
                        updateCheckingEvents(0);
                        break;

                }

            } catch (e) {
                log.error('gotoUrl : Cache Error : ' + e);
                failedToProvision(e);
                return;
            }
            callback();
        }
		function isGoingHome() {
			var isHome = false;
			if (url.indexOf('visualize.html') >= 0) {
				isHome = mc.db.getProcess(url.substring(6).replace('/visualize.html','').replace('/', ' ')).home;
			}
            if (url.indexOf('launch.html') >= 0) {
				isHome = true;
			}
			return isHome;
		}
        function checkCacheStatus() {
			if(isGoingHome()) {
				// Graham changed this to launch.html and made it positive
				// It now only goes through the cache check if we were going
				// to a home process.
				// old message:
                //dont request cache check if we are going to index page
                //we only want a request for the index page to arrive at the server
                //not a request for the cache because that may confuse it
                //especially if the url has a query string with the device shell info on it
                checkCacheState(navigateToUrl);
            } else {
                navigateToUrl();
            }
        }

        function doCheckPopupBlocked(poppedWindow) {

            var result = false;
            //None of this seems to work in debug so ignore it for now
            return result;

            try {
                if (typeof poppedWindow == 'undefined') {
                    // Safari with popup blocker... leaves the popup window handle undefined
                    result = true;
                }
                else if (poppedWindow && poppedWindow.closed) {
                    // This happens if the user opens and closes the client window...
                    // Confusing because the handle is still available, but it's in a "closed" state.
                    // We're not saying that the window is not being blocked, we're just saying
                    // that the window has been closed before the test could be run.
                    result = false;
                }
                else if (poppedWindow && poppedWindow.outerWidth == 0) {
                    // This is usually Chrome's doing. The outerWidth (and most other size/location info)
                    // will be left at 0, EVEN THOUGH the contents of the popup will exist (including the
                    // test function we check for next). The outerWidth starts as 0, so a sufficient delay
                    // after attempting to pop is needed.
                    result = true;
                }
                else if (poppedWindow && poppedWindow.test) {
                    // This is the actual test. The client window should be fine.
                    result = false;
                }
                else {
                    // Else we'll assume the window is not OK
                    result = true;
                }

            } catch (err) {
                //if (console) {
                //    console.warn("Could not access popup window", err);
                //}
            }

            if (result)
                alert("The popup was blocked. You must allow popups to use this site.");
            else
                poppedWindow.focus();

            mc.hideActivity(true);
        }
        function checkPopupBlocked(poppedWindow) {
            setTimeout(function() { doCheckPopupBlocked(poppedWindow); }, 5000);
        }

        function openWindow(url) {
            alert("You must allow popups to use site '" + url + "'");
            var windowName = 'userConsole'; //_blank
            var poppedWindow = window.open(url, windowName, 'width=1000, height=700, left=24, top=24, scrollbars, resizable');
            checkPopupBlocked(poppedWindow)
        }
        function isApplicationUrl(url) {
            if (url.toLowerCase().indexOf('cthttp') === 0) {
                return false;
            } else if (url.toLowerCase().indexOf('exhttp') === 0) {
                return false;
            } else if (url.toLowerCase().indexOf(':') !== -1) {
                //any protocol change means its not an app url
                //because we only request relative urls
                return false;
            }
            return true;
        }
        function isVisualization() {
            try {
                return (mc.db.getCurrentProcess().id === 'Visualization');
            } catch (ex) {
                log.debug('Error testing for for visualization ' + ex);
                return false;
            }
        }
        function isOurShell() {
            try {
                return (cordova !== undefined && cordova.exec !== undefined && window.plugins !== undefined && window.plugins.settings !== undefined);
            } catch (ex) {
                log.debug('Error testing for shell ' + ex);
                return false;
            }
        }
        function navigateToUrl() {
            log.debug('Navigating to ' + url);
            if (isVisualization() || !isOurShell()) {
                log.debug('Testing or visualization showing externallink ' + url);
                if (url.toLowerCase().indexOf('cthttp') === 0) {
                    targetUrl = url.substr(2, url.length - 2);
                    openWindow(targetUrl);
                    return;
                } else if (url.toLowerCase().indexOf('exhttp') === 0) {
                    targetUrl = url.substr(2, url.length - 2);
                    openWindow(targetUrl);
                    return;
                }
            }
			// The following hopefully allows for a new home process version.
			// If going home and subject stack is sufficiently small ..
 			if (subjectStack.length <= 1 && isGoingHome()) {
				mc.fl.clearsubjectstack();
				window.locationUtils.setHref("../../launch/0/launch.html");	
			} else {
 			    // If present (initially Windows 8), use Cordova to navigate, otherwise rely on the shell to intercept navigation.
 			    if (window.plugins && window.plugins.navigation && window.plugins.navigation.navigateToUrl) {
 			        window.plugins.navigation.navigateToUrl(url,
                      function (handled) {
                          if (!handled) {
                              window.locationUtils.setHref(url);
                          }
                      },
                      function (error) {
                      	if (error !== undefined && error.message !== undefined) {
                      		log.error('Error : "' + error.message + '" from shell navigating to : ' + url);
                      	} else {
							log.error("Unable to ask shell to navigate to : " + url)
                      	}
                      	window.locationUtils.setHref(url);
                      });
 			    } else {
 			        window.locationUtils.setHref(url);
 			    }
			}
            if (!isApplicationUrl(url)) {
                mc.hideActivity(true);
            }

        }
        function gotoNextUrl() {
            // log.debug('After deleting a backup, will navigate to ' + url);
            // mc.db.deleteBackup(function() {
            log.debug('After stopping notifications, will navigate to ' + url);
            mc.showActivity();
            stopNotifications(checkCacheStatus);
        }
        subjectStack = mc.db.getJsonItem('subjectStack') || [];
        if (!isApplicationUrl(url) || isVisualization()) {
            navigateToUrl(url);
            return;
        }
        currentProcess = mc.db.getCurrentProcess();
        if (currentProcess !== undefined) {
            currentSubjectGuid = mc.db.getCurrentSubjectGuid()
            if (currentProcess.notClientCreatable && mc.fl.isclientsubject()) {
                //We are deleting the current subject because it should not have been created on the device
                //We let it be created so that the proces developer can use the isserversubject function to test
                //and transition to an error page that will close the process and come back to here
                //See the corresponding code in mc2.question.js function processSelectorInlineQuestion(spec) {
                //However its possible for a developer to try to create one in script and that is dealt with as an error
                //See mc2.fl.js  function createSubject(processId, callback) {
                //Which does not allow the subject to be created and instead throws an error.
                mc.db.deleteSubject(currentSubjectGuid, gotoNextUrl);
            } else if ((currentProcess.singleSubject && currentProcess.deleteOnClose)) {
                //ensure that we dont delete subjects that are on the stack
                //they are needed to go back to and should be deleted on the way back
                //down the stack
                if (subjectStack.length === 0 || currentSubjectGuid !== subjectStack[subjectStack.length - 1]) {
                    mc.db.deleteSubject(mc.db.getCurrentSubjectGuid(), gotoNextUrl);
                } else {
                    // It's just possible that someone might want to use the summarues in the subject we are just leaving
                    mc.db.evaluateSummaryValues(currentProcess.summaryMap, mc.fl.summaries, gotoNextUrl);
                }
            } else {
                mc.db.evaluateSummaryValues(currentProcess.summaryMap, mc.fl.summaries, gotoNextUrl);
            }
        } else {
            gotoNextUrl();
        }
    }
    /**
    * Retrieves the base url to re provision the app including the query string parameters
    * if this is being hosted in a shell
    *
    * @return value of the parent subject guid in the syncInfo object on the current subject
    */
    function gotoProvisioningUrl(callback) {
        //debugger;
        var timer, provisioningURL;
        provisioningURL = "../../index.html";
        function stopTimer() {
            if (timer !== undefined) {
                clearTimeout(timer);
                timer = undefined;
            }
        }
        function provision(URL) {
            stopTimer();
            mc.fl.clearsubjectstack();
            window.localStorage.provisionedState = '';
            window.MCAPTURE_Provisioning_Processes = true;
            mc.gotoUrl(URL, true);
            if (callback !== undefined) {
                if (typeof callback === "function") {
                    callback(URL);
                } else if (typeof callback["resume"] === "function") {
                    callback.resume(URL);
                } else {
                    log.error("Unable to exit from provisioning url reason: invalid callback");
                }
            } else {
                log.debug("Unable to exit from provisioning url reason: callback undefined");
            }
        }
        function getCodeVersion() {
            //work out what we are and try to get the code version
            //X-mDesign-Client=AndroidPhoneGap^&X-mDesign-Client-Version=6.1.0.55
            log.debug("User agent: " + window.navigator.appVersion);
            var deviceType, codeVersion;
            if ($.isAndroid) {
                deviceType = "Android";
            } else if ($.isWp8) {
                deviceType = "WP8";
            } else if ($.isIpad || $.isIphone) {
                deviceType = "IOS";
            } else {
                deviceType = "Unknown";
            }
            codeVersion = mc.version.getversion("framework");
            return "X-mDesign-" + deviceType + "-Code-Version=" + codeVersion;
        }
        function success(URL) {
            stopTimer();
            log.info("Provisioning url from shell : " + URL);
            provisioningURL = URL + "&" + getCodeVersion();
            log.info("Provisioning url request : " + provisioningURL);
            provision(provisioningURL);
        }
        function error(e) {
            stopTimer();
            log.error("Unable to get provisioning url from shell reason: " + e);
            provisioningURL = provisioningURL + "?" + getCodeVersion();
            log.info("Provisioning url derived : " + provisioningURL);
            provision(provisioningURL);
        }
        function timeout() {
            stopTimer();
            log.debug("timeout: plugin did not return");
            error("getProvisioningURL - timeout");
        }
        if (cordovaready) {
            if (window.plugins !== undefined && window.plugins.settings !== undefined) {
                if (typeof (window.plugins.settings.getProvisioningURL) === 'function') {
                    try {
                        timer = setTimeout(timeout, 2 * 1000);
                        window.plugins.settings.getProvisioningURL(success, error);
                        log.debug("Provisioning URL requested from shell");
                    } catch (e) {
                        error(e);
                    }
                    return;
                }
                log.debug("typeof(window.plugins.settings.getProvisioningURL) = " + typeof (window.plugins.settings.getProvisioningURL));
                error("getProvisioningURL missing or invalid");
                return;
            }
            log.debug("plugins not ready: " + typeof (window.plugins) + " - " + typeof (window.plugins.settings));
            error("getProvisioningURL - plugins not ready");
        } else {
            log.debug("cordova not ready ");
            provision(provisioningURL + "?redetect-device=no&" + getCodeVersion());            
        }
    }

    function goHome() {
        var homeProcess;

        homeProcess = mc.db.getHomeProcess();
        if (homeProcess && homeProcess.url) {
            mc.fl.clearsubjectstack();
            window.localStorage.provisionedState = '';
            window.MCAPTURE_Provisioning_Processes = true;
            gotoUrl(homeProcess.url, !homeProcess.urlProcess);
        }
    }

    function initBehaviours() { // This code may be able to stop the Android auto dialing on elements with relevant class.
        // Unfortunately it has side effects making subsequent touches unresponsive. There is no
        // way of reliably preventing inherent touch behaviour from JavaScript.
        $('.preventDefaultTouch').bind('touchstart', $.ui.cancelEvent).bind('touchmove', $.ui.cancelEvent).bind('touchend', $.ui.cancelEvent);
    }

    function initButtons() {
        $('.pageBack').bind($.ui.tapEvent, function(e) {
            if (!$.ui.defaultPrevented(e) && !$(this).attr('disabled')) {
                e.preventDefault();
                currentPage($.ui.parentPage(this).id);
                mc.fl.pageback();
            }
        });
        $('.pageForward').bind($.ui.tapEvent, function(e) {
            if (!$.ui.defaultPrevented(e) && !$(this).attr('disabled')) {
                e.preventDefault();
                currentPage($.ui.parentPage(this).id);
                mc.fl.pagenext();
            }
        });
        $('.pageHome').bind($.ui.tapEvent, function(e) {
            if (!$.ui.defaultPrevented(e) && !$(this).attr('disabled')) {
                e.preventDefault();
                currentPage($.ui.parentPage(this).id);
                mc.fl.pagehome();
            }
        });
        $('.jmuiToolButton[id],.jmuiDeleteButton[id],.jmuiCancelButton[id],.jmuiBackButton[id],.jmuiAddButton[id],.jmuiActionButton[id]').bind($.ui.tapEvent, function(e) {
            if (!$.ui.defaultPrevented(e) && !$(this).attr('disabled')) {
				var actionButton;
                e.preventDefault();				
				actionButton = this;
				$(actionButton).attr('disabled', true);
				/* Collapse the keyboard if an input or textarea is in focus before running an action*/
				if(jQuery("input:focus, textarea:focus").length>0){
					jQuery("input:focus, textarea:focus").blur();
				}
                mc.fl.execFormula('action_' + this.id, function(result) {
					$(actionButton).removeAttr('disabled');
				}, function(e) {
					$(actionButton).removeAttr('disabled');
                    alert(e);
                }, true);
            }
        });
    }
	
	function initCss() {
		var css;
		css = mc.db.getMetaValue('currentCss');				
		if( css ) {					
			mc.fl.switchcss(css);
		}
	}

    function stopNotifications(callback) {
        var receiver, user;
        user = mc.db.getUserInfo();
        receiver = user.mSuiteUserName;
        mc.notify.service.cancelInboxChanges(receiver, callback);
    }

    function initNotifications(userName) {
        var receiver,userInfo;
        function inboxChange(e, r) {
            function preNotifyError(e) {
                log.warn(e);
                showNotificationIndicator(true);
                preNotifyCount -= 1;
            }
            function preNotifySuccess(b) {
                if (b) {
                    log.debug("preNotifySuccess - rec: " + receiver + " id: " + r.message.id);
                    mc.notify.service.messageReceivedAck(receiver, r.message.id);
					refreshNotificationIndicator();
                } else {
                    showNotificationIndicator(true);
                }
                preNotifyCount -= 1;
            }
            if (!e && r && r.message && r.message.channel === userName) {
                log.info('Inbox change action: ' + r.action);
                switch (r.action) {
                    case 'create':
                        log.debug('Inbox create to be actioned r = ' + JSON.stringify(r))
                        if (!mc.notify.handleMessage(r.message)) {
                            preNotifyCount += 1;
                            mc.fl.execFormula('preNotification', preNotifySuccess, preNotifyError, true, r.message);
                        } else {
                            log.warn('Inbox change not handled')
                        }
                        break;
                    case 'update':
                        break;
                    case 'delete':
                        refreshNotificationIndicator();
                        break;
                    default:
                        log.warn('Inbox change - unknown action: ' + r.action);
                        break;
                }
            } else {
                if (e) {
                    log.warn('Inbox change error: ' + e);
                } else {
                    log.warn('Inbox change not actioned r = ' + JSON.stringify(r))
                }
            }
        }
        userInfo = mc.db.getUserInfo();
        
        function removeSystemChannel(callback) {
            if (userInfo.mSuiteUserName !== "" ) {
				if (userInfo.mSuiteUserName !== userName) {
					receiver = userInfo.mSuiteUserName;
					log.info("Cancel inbox changes:" + receiver);
					mc.notify.service.cancelInboxChanges(receiver, function() {
						log.warn("Remove current system channel user:" + receiver);
						mc.notify.service.removeChannel(receiver, function(e) {
							if (e) {
								log.warn(e);
							}
							userInfo.receveInboxChanges = false;
							userInfo.mSuiteUserName = "";
							mc.db.setUserInfo(userInfo);
							log.info("Setup new user:" + userName);
							callback();
						});
					});
				} else {
					log.info("Old is not changed:" + userName);
					callback();
				}
            } else {
                log.info("Old user is blank - setup new user:" + userName);
                callback();
            }
        }
        function receiveInboxChanges() {
			log.info("Receive inbox changes for user:" + userName);
			receiver = userName; // + '_' + mc.db.getCurrentProcess().id;
			if (window.receveInboxChanges !== receiver) {
				window.receveInboxChanges = receiver
				mc.notify.service.receiveInboxChanges(receiver, inboxChange);
				userInfo.receveInboxChanges = true;
				mc.db.setUserInfo(userInfo);
			} else {
				log.info("Receive inbox changes for user:" + userName + " no change");
			}
			mc.refreshNotificationIndicator();
		}
        function initSystemChannel() {
            if (userName !== "") {
                if (!userInfo.receveInboxChanges || userInfo.mSuiteUserName !== userName) {
                    log.info("Add new system channel user:" + userName);
                    mc.notify.service.addChannel(userName, function(e) {
                        if (e) {
                            log.warn(e);
                        }
						userInfo.mSuiteUserName = userName;
						receiveInboxChanges();
						return;
                    });
                } else {
                    log.info("No change to system channel");
					receiveInboxChanges();
					return;
                }
            } else {
                log.warn("No user name so cannot set up notifications system channel");
            }
			mc.refreshNotificationIndicator();
        }
        function checkSystemChannel(channels) {
            if (channels && channels.indexOf(userName) < 0) {
               log.info("Change system channel from:" + userInfo.mSuiteUserName + " to :" + userName);
               removeSystemChannel(initSystemChannel);
            } else {
               log.info("System channel already set to:" + userName);
               removeSystemChannel(initSystemChannel);
            }
        }
        if (userInfo) {
            if (!userInfo.receveInboxChanges) {
               log.info("Initialize system channel to :" + userName);
               initSystemChannel();
            } else {
               mc.notify.service.listChannels(checkSystemChannel);
            }
        } else {
            log.warn("No user info so cannot set up notifications system channel");
        }
    }


    function initPage(pageId, pageSpec) {
        var page, questions, query, headerTemplate, footerTemplate, tlTemplate, trTemplate;

        function deleteQuestions() {
            var i;
            for (i = 0; i < questions.length; i += 1) {
                questions[i].deleteValue();
            }
        }

        function makeQuestion(q) {
            var question = mc.q(page, q);
            if (question) {
                questions[questions.push(question) - 1].initialize();
                question.getQuestionObject().bind('questionLoaded', function() {
                    $.ui.refreshScroller(page);
                });
            } else {
                log.warn('Failed to create question object for id: ' + q.attr('id'));
            }
        }

        function load() {
            var bar, extra, html, i, loadCount, rowIndex, toolbar;

            function questionLoaded() {
                this.removeEventListener('questionLoaded', questionLoaded);
                loadCount -= 1;
                if (loadCount <= 0) {
                    mc.fl.refreshhidden();
                }
            }
            currentPage(pageId);
            rowIndex = page.attr('rowIndex');
            bar = page.find('.jmuiHeader');
            if (bar.length === 1) {
                extra = bar.find('.extra');
                html = headerTemplate ? $.tmpl(headerTemplate, mc.db.getCurrentSubject()) : '';
                if (html && extra.length === 0) {
                    extra = $(window.document.createElement('div'));
                    extra.addClass('extra');
                    bar[0].appendChild(extra[0]);
                }
                extra.html(html || '');

                extra = bar.find('.buttonExtra.head.left');
                html = tlTemplate ? $.tmpl(tlTemplate, mc.db.getCurrentSubject()) : '';
                extra.html(html || '');

                extra = bar.find('.buttonExtra.head.right');
                html = trTemplate ? $.tmpl(trTemplate, mc.db.getCurrentSubject()) : '';
                extra.html(html || '');
            }
            bar = page.find('.jmuiFooter');
            if (bar.length === 1) {
                extra = bar.find('.extra');
                html = footerTemplate ? $.tmpl(footerTemplate, mc.db.getCurrentSubject()) : '';
                if (html && extra.length === 0) {
                    extra = $(window.document.createElement('div'));
                    extra.addClass('extra');
                    toolbar = bar.find('.jmuiToolbar');
                    if (toolbar.length === 0) {
                        bar[0].appendChild(extra[0]);
                    } else {
                        bar[0].insertBefore(extra[0], toolbar[0]);
                    }
                }
                extra.html(html || '');

                if (pageSpec.footerButtonTemplateList) {                    
                    for (btnSpec in pageSpec.footerButtonTemplateList) {
                        var btn, templ;
                        btn = bar.find('.md_toolbarButton_'+btnSpec + ' > .buttonExtra')
                        if (btn.length === 1) {
                            templ = pageSpec.footerButtonTemplateList[btnSpec];
                            html = templ ? $.tmpl(templ, mc.db.getCurrentSubject()) : '';
                            btn.html(html || '');
                        }
                    }
                }
            }
            $.ui.setScrollerHeight(page);
            try {
                loadCount = questions.length;
                for (i = 0; i < questions.length; i += 1) {
                    questions[i].getQuestionObject()[0].addEventListener('questionLoaded', questionLoaded);
                    questions[i].setRowIndex(rowIndex);
                    questions[i].load();
                }
            } catch (e) {
                log.warn('Exception caught loading question');
            }
            if (query && query.constructor === Function) {
                page.find('.jmuiToolbar > div').removeAttr('disabled');
                page.find('.gridInline, .popupQuestions li').removeAttr('disabled');
            }
        }

        function onPageAnimationStart(evt) {
            var i;
            if (evt === undefined || evt.direction === 'in') {
                if (query && query.constructor === Function) {
                    page.find('.jmuiToolbar > div').attr('disabled', 'disabled');
                    page.find('.gridInline, .popupQuestions li').attr('disabled', 'disabled');
                    query(load);
                } else {
                    load();
                }
            } else if (evt.direction === 'out') {
                log.debug('Unloading page ' + pageId);
                $('.pageBack,.pageForward,.pageHome').attr('disabled', true);
                for (i = 0; i < questions.length; i += 1) {
                    questions[i].unload();
                }
                log.debug('Done unloading page ' + pageId);
            }
        }

        function onPageAnimationEnd(evt) {
            var i;
            if (evt === undefined || evt.direction === 'in') {
                for (i = 0; i < questions.length; i += 1) {
                    questions[i].postLoad();
                }
            } else if (evt.direction === 'out') {
                for (i = 0; i < questions.length; i += 1) {
                    questions[i].postUnload();
                }
                log.debug('Enabling buttons' + pageId);
                $('div.jmuiHeader > div[disabled="true"],.pageBack,.pageForward,.pageHome').removeAttr('disabled');
            }
        }
        log.debug('Initializing page ' + pageId);
        if (pageSpec) {
            query = pageSpec.query;
            headerTemplate = pageSpec.headerTemplate;
            footerTemplate = pageSpec.footerTemplate;
            tlTemplate = pageSpec.topLeftButtonTemplate;
            trTemplate = pageSpec.topRightButtonTemplate;
        }
        
        page = $('#' + pageId);
        questions = [];
        page.bind('jmuiPageAnimationStart', onPageAnimationStart);
        page.bind('jmuiPageAnimationEnd', onPageAnimationEnd);
        page.find('ul[id]').each(function() {
            makeQuestion($(this));
        });
        page.find('li[id]').each(function() {
            makeQuestion($(this));
        });
        page.find('.jmuiDeleteButton').bind($.ui.tapEvent, function(e) {
            var me;
            if (!e.ignoreDelete && !$.ui.defaultPrevented(e)) {
                e.preventDefault();
                me = $(this);
                msgBox(function(text) {
                    if (text === 'Yes') {
                        deleteQuestions();
                        me.trigger($.ui.tapEvent, {
                            jmuiTarget: e.jmuiTarget,
                            ignoreDelete: true
                        });
                    }
                }, 'Confirm', 'Delete', 'Yes', 'No');
            }
        });
        if (page.hasClass('jmuiCurrent') === true) {
            onPageAnimationStart();
            onPageAnimationEnd();
        }
        log.debug('Done initializing page ' + pageId);
    }

    function initReplicatePage() {
        var replicatePage, replicateSuccess, status;

        function setProgressComplete(pc) {
            var bar, width;
            if (pc < 0) {
                pc = 0;
            }
            if (pc > 100) {
                pc = 100;
            }
            width = '';
            width += pc + '%';
            bar = $('#replicateProgressComplete');
            bar.style('width', width);
        }

        function updateStatus(progress) {
            if (progress.overall !== undefined) {
                setProgressComplete(progress.overall);
            }
            if (progress.action !== undefined) {
                status.text(progress.action);
            }
        }
        replicatePage = $('#replicatePage');
        replicatePage.bind('jmuiPageAnimationStart', function(e) {
            if (e.direction === 'in') {
                status.text('');
                setProgressComplete(0);
                if (mc.replInfo !== undefined && mc.replInfo.title !== undefined) {
                    replicatePage.find('h1').html(mc.replInfo.title);
                } else {
                    replicatePage.find('h1').html('Syncing');
                }
                replicatePage.find('.jmuiCancelButton').removeAttr('disabled');
            }
        });
        replicatePage.bind('jmuiPageAnimationEnd', function(e) {
            function replicationComplete(success) {
                var callback, url, page;
                replicateSuccess = success;
                if (mc.replInfo) {
                    callback = mc.replInfo.callback;
                    url = mc.replInfo.url;
                    page = mc.replInfo.page;
                    delete mc.replInfo;
                }
                if (callback) {
                    callback.resume(replicateSuccess);
                    callback = undefined;
                } else if (url) {
                    try {
                        gotoUrl(url, false);
                    } catch (e) {
                        goHome();
                    }
                } else if (mc.db.getCurrentProcess().replicator) {
                    goHome();
                } else if (page) {
                    $.ui.gotoPage($('#' + page), 'jmuiSlide', true);
                } else {
                    $.ui.gotoPage($('#processesPage'), 'jmuiSlide', true);
                }
            }
            if (e.direction === 'in') {
                if (!mc.repl.isReplicating()) {
                    if (!mc.replInfo) {
                        mc.replInfo = mc.db.getJsonItem('mcReplInfo');
                        mc.db.deleteJsonItem('mcReplInfo');
                    }
                    mc.repl.subscribeStatus(updateStatus);
                    hideActivity(true);
                    mc.repl.replicate(replicationComplete, mc.replInfo);
                }
            }
        });
        replicatePage.find('.jmuiCancelButton').bind($.ui.tapEvent, function(e) {
            var disabled, me;
            if (!$.ui.defaultPrevented(e)) {
                e.preventDefault();
                me = $(this);
                disabled = me.attr('disabled');
                if (disabled === undefined || disabled === null) {
                    me.attr('disabled', 'disabled');
                    mc.repl.abortReplication();
                }
            }
        });
        status = replicatePage.find('.statusText');
    }

    function initPages(pages) {
        var i, n, page; //initLogPage();
        initReplicatePage();
        if (pages) {
            if (pages.constructor === Object) {
                for (page in pages) {
                    if (pages.hasOwnProperty(page)) {
                        initPage(page, pages[page]);
                    }
                }
            } else if (pages.constructor === Array) {
                n = pages.length;
                for (i = 0; i < n; i += 1) {
                    initPage(pages[i]);
                }
            }
        }
    }

    function initSize(width, height) {
        var w, h;
        w = window.outerWidth - window.innerWidth;
        h = window.outerHeight - window.innerHeight;
        w = w + width;
        h = h + height;
        window.resizeTo && window.resizeTo(w, h);
    }

    function provision(processInfo) {
        var o = { delay: '100' };
        log.debug('IN mc.provision :' + processInfo.id);
        function provisioned(o) {
            log.debug('IN mc.provision.provisioned :' + processInfo.id);
            if (window.MCAPTURE_ProcessProvisioned && window.MCAPTURE_ProcessProvisioned.constructor === Function) {
                window.MCAPTURE_ProcessProvisioned(o);
            } else {
                log.error('mc.provision cant complete:' + processInfo.id);
                log.debug('mc.provision completion function:' + window.MCAPTURE_ProcessProvisioned);
            }
        }

        log.debug('mc.provision ' + JSON.stringify(o));
        if (window.MCAPTURE_ProcessProvisioned && window.MCAPTURE_ProcessProvisioned.constructor === Function) {
            window.MCAPTURE_ProcessProvisioned(o);
        }
        mc.db.createProcess(processInfo, provisioned);
    }

    function doStartupReplication() {
        var callback = {};
        callback.resume = function startUpReplicationFinished(success) {
        }
        var search = localStorage.searchString;
        localStorage.removeItem('searchString');
        if (search) {
            var query = search.substr(1);
            var data = query.split("&");
            var result = {};
            for (var i = 0; i < data.length; i++) {
                var item = data[i].split("=");
                if (item.length > 1)
                    result[item[0]] = item[1];
                else
                    result[item[0]] = '';
            }
            if (result.replicate == 'true') {
                mc.fl.replicatedialog();
                // mc.fl.replicatedialog(callback, result.processId || 'all', decodeURIComponent(result.profileAlias) || 'defaultRepProfile', decodeURIComponent(result.title) || 'Replicating',  decodeURIComponent(result.url) || '', result.timeout || 60);					
            }
        }
    }

    function getRootPath() {
        if (!rootPath) {
            var path = window.locationUtils.getURI().path();
            var i = path.toLowerCase().lastIndexOf('/mdesign/') + 1;
            rootPath = path.substr(0, i).replace("/^\/*/", '/');
        }
        return rootPath;
    }

    function getApplicationID(callback) {
        if (window.plugins && window.plugins.settings) {
            window.plugins.settings.getApplicationID(callback, function() {
                log.error('Failed to retrieve ApplicationID from call to window.plugins.settings.getApplicationID');
            });
        } else {
            var applicationID = window.localStorage['applicationID'];
            if (!applicationID) {
                applicationID = window.localStorage['applicationID'] = mc.db.guid();
            }
            callback(applicationID);
        }
    }

    function ready(visualizing, width, height, processInfo, initCallback) {
        var keyboardTimeout;
        log.debug('IN mc.ready');
        setTimeout(function() {
            var currentPageId;
			if (processInfo) {
				log.debug('IN DOM ready for ' + processInfo.id);
				if (processInfo.useAnimation === false) {
					$.hasAnimation = false;
				}
			} else {
				log.debug('IN DOM ready for undefined process');
			}
            $(window).bind('load', function() {
                $(window).trigger('resize');
            });
            if (width > 0 && height > 0) {
                initSize(width, height + 1);
            }

            var dbReady = function() {
                var page,userInfo;
                log.debug('IN DB ready');
                log.debug('File System is ' + (mc.fs.available ? '' : 'not ') + 'available.');
                log.debug('File System is ' + (mc.fs.availableForAtts ? '' : 'not ') + 'available for attachments.');
                
                function initComplete() {
					if (!processInfo) {
						log.error('initComplete called for undefined process');
						return;
					}
                    mc.q.ready(processInfo.questions);
                    currentPageId = currentPage();
                    initButtons();
                    initPages(processInfo.pages);
                    initBehaviours();
				    initCss();
				    userInfo = mc.db.getUserInfo();
				    if (userInfo && userInfo.mSuiteUserName !== "") {
                        initNotifications(userInfo.mSuiteUserName);
                    }				
                    if (currentPageId) {
                        page = $('#' + currentPageId);
                        if (!page.hasClass('jmuiCurrent')) {
                            $.ui.gotoPage(page);
                        }
                    } else if (!$('.jmuiPage.jmuiCurrent').length) {
                        $.ui.gotoPage($('.jmuiLayout.jmuiCurrent .jmuiPage'));
                    }
                    mc.hideActivity(true);

                    log.debug('Triggering mcready');
                    $(document).trigger('mcready');

                    log.debug('OUT DB ready');

                    doStartupReplication();
                }               

                mc.notify.createNotificationService(function () {
                    if (initCallback) {
                        initCallback(initComplete);
                    } else {
                        initComplete();
                    }
                });
            };

            mc.db.ready(visualizing, processInfo, dbReady);
            
            function onHideKeyboard() {
		        $('div.jmuiPage').removeClass('jmuiKeyboardUp');
				keyboardTimeout = setTimeout(function(){
				    jmfw.ui.setScrollerHeight(jmfw('div.jmuiPage.jmuiCurrent'));
				},1500);
		    }		
		    function onShowKeyboard() {
		        $('div.jmuiPage').addClass('jmuiKeyboardUp');
				clearTimeout(keyboardTimeout);
		    }
            
    	    if ($.isAndroid) {
    	        document.addEventListener("hidekeyboard", onHideKeyboard, false);
                document.addEventListener("showkeyboard", onShowKeyboard, false);
    	    } else {
            if(!jmfw.isIE) {
              $('input, textarea').bind('focus', onShowKeyboard);
              $('input, textarea').bind('blur', onHideKeyboard);
            }
		    }	
    	    if (processInfo !== undefined) {
    	    	log.debug('OUT DOM ready for ' + processInfo.id);
    	    } else {
    	    	log.error('OUT DOM ready - no process');
    	    }
        }, 100);
		addCacheListeners();
        log.debug('OUT mc.ready');
    }
    activityCount = 0;
    preNotifyCount = 0;
    dateFormat = 'd MM, yy';

    if ($.isIE) {
        //It's not possible to change the user agent string in windows 8
        //We can detect whether the code is running in a browser by inspecting the isPPA
        //because in windows 8, it must be a shell to be running in PPA mode
        testingInBrowser = !window.locationUtils.isPPA();
    } else if (window.mdesignshell) {
        //The device type is unrestricted (i.e. a shell)
        //But we may be prending to be that and be a browser launched from the studio
        //cordova will be present but may not be usable
        if (localStorage.getItem("isTesting") === null) {
            if (typeof (MCAPTURE_CFG) !== "undefined") {
                //We loose the MCAPTURE_CFG so preserve the isTesting launch condition
                localStorage.setItem("isTesting", MCAPTURE_CFG.isTesting.toLowerCase());
            }
        }
        testingInBrowser = (
            (window.navigator.userAgent.toLowerCase().indexOf('cttesting') >= 0) ||
            (localStorage.getItem("isTesting") === 'yes') ||
            (window.document.title.toLowerCase() === "visualization")
        );
    } else {
        //cordova will not be present because its a restricted client
        if ($.isIphone || $.isIpad) {
            //iThing cant use web-notify
            testingInBrowser = false;
        } else {
            testingInBrowser = true;
        }
    }
    mc = {
        currentPage: currentPage,
        db: undefined,
        fl: undefined,
        getDateFormat: getDateFormat,
        getLongDateFormat: getDateFormat,
        getPreNotifyCount: getPreNotifyCount,
        getRootPath: getRootPath,
        getApplicationID: getApplicationID,
        getShortDateFormat: getDateFormat,
        goHome: goHome,
        gotoUrl: gotoUrl,
        gotoProvisioningUrl: gotoProvisioningUrl,
        hideActivity: hideActivity,
        initnotifications : initNotifications,
        msgBox: msgBox,
        provision: provision,
        q: undefined,
        ready: ready,
        refreshNotificationIndicator: refreshNotificationIndicator,
        showActivity: showActivity,
        showNotificationIndicator: showNotificationIndicator,
        sid: undefined,
        unrestricted: window.plugins && window.plugins.settings, //true
        testingInBrowser: testingInBrowser,
        phonegapPresent: phonegapPresent,
        getShellType: getShellType,
        getobjectclass: getObjectClass
    };
    mc.profiler = profiler();
    return mc;
} (window.jmfw));
/*
** END OF MC2.JS
*/
/*jslint browser: true, devel: true, bitwise: true, continue: true, evil: true, forin: true, nomen: true, plusplus: true, regexp: true, sloppy: true, white: true */
(function($, mc) {
    var backupSubject, currentProcess, currentSubject, db, noCurrentSubject, positionWatchId, expansionError;

    /**
    * All database transactions should be performed using this function
    */
    function doTx(type, execute, error, complete) {
        var failCount, success;
        function txFn(tx) {
            success = true;
            execute(tx);
        }
        function txError(e) {
            if (error) {
                log.error('Supplied transaction failed callback error : ' + e);
                error(e);
            } else {
                log.error('Supplied transaction no error callback failed ' + e);
            }
        }
        function txComplete() {
            if (success) {
                if (complete) {
                    complete();
                }
            } else {
                failCount += 1;
                if (failCount < 3) {
                    log.debug('Supplied transaction function not called. Will retry, failCount: ' + failCount);
                    db[type](txFn, txError, txComplete);
                } else {
                    log.error('Supplied transaction function not called. Exceeded retry count, failCount: ' + failCount);
                    if (complete) {
                        complete();
                    }
                }
            }
        }
        success = false;
        failCount = 0;
        db[type](txFn, txError, txComplete);
    }

    function setDb(dbase) {
        db = dbase;
    }

    function _currentSubject(subject) {
        if (subject) {
            currentSubject = subject;
        }
        return currentSubject;
    }

    function _deleteSubject(subjectGuid, keepAttachments, callback) {
        var params, calledBack;
        calledBack = false;
        function safeCallback(e) {
            if (callback) {
                if (!calledBack) {
                    calledBack = true;
                    callback(e);
                }
            }
        }
        function error(tx, e) {
            tx = undefined;
            safeCallback(e);
        }
        function success(tx, result) {
            tx = undefined;
            result = undefined;
            safeCallback();
        }
        function txFail(e) {
            safeCallback(e);
        }
        function txSuccess() {
            safeCallback();
        }
        params = [subjectGuid];
        doTx('transaction', function(tx) {
            if (!keepAttachments) {
                tx.executeSql('DELETE FROM attachment WHERE subjectGuid=?;', params);
                if (mc.fs.availableForAtts) {
                    mc.fs.deleteAttachments(subjectGuid);
                }
            }
            tx.executeSql('DELETE FROM subject WHERE guid=?;', params, success, error);
        }, txFail, txSuccess);
    }

    function _deleteSubjectInTransaction(tx, subjectGuid, keepAttachments, callback) {
        var params;
        function safeCallback(e) {
            if (callback) {
                callback(e);
            }
        }
        function error(tx, e) {
            tx = undefined;
            safeCallback(e);
        }
        function success(tx, result) {
            tx = undefined;
            result = undefined;
            safeCallback();
        }
        params = [subjectGuid];
        if (!keepAttachments) {
            tx.executeSql('DELETE FROM attachment WHERE subjectGuid=?;', params);
            if (mc.fs.availableForAtts) {
                mc.fs.deleteAttachments(subjectGuid);
            }
        }
        tx.executeSql('DELETE FROM subject WHERE guid=?;', params, success, error);
    }

    /**
    * Public access to execute a sql query
    */
    function executeQuery(sql, callback) {
        doTx('transaction', function(tx) {
            tx.executeSql(sql, [], callback, callback);
        });
    }

    /**
    * Compare two version strings.
    *
    * @param	v1
    *					String containing a version string in format 1[.2.3.x...]
    * @param	v2
    *					String containing a version string in format 1[.2.3.x...]
    *
    * @return	-1 if v1 < v2, +1 if v1 > v2, 0 if v1 === v2
    */
    function compareVersions(v1, v2) {
        var diff, i, n, n1, n2, p1, p2;
        p1 = v1.split('.');
        p2 = v2.split('.');
        n1 = p1.length;
        n2 = p2.length;
        n = n1 < n2 ? n1 : n2;
        for (i = 0; i < n; i += 1) {
            diff = parseInt(p1[i], 10) - parseInt(p2[i], 10);
            if (diff < 0) {
                return -1;
            }
            if (diff > 0) {
                return 1;
            }
        }
        if (n1 < n2) {
            return -1;
        }
        if (n1 > n2) {
            return 1;
        }
        return 0;
    }

    /**
    * Retrieve a JSON packed object from local storage with the supplied name
    *
    * @param name
    *					string containing key name of item in local storage
    *
    * @return	unpacked persistent JSON object
    */
    function getJsonItem(name) {
        var item;
        item = mc.profiler.profileSync('getJsonItemRead', function() {
            return localStorage.getItem(name);
        });
        if (item !== undefined && item !== null) {
            item = mc.profiler.profileSync('getJsonItemParse', function() {
                return $.jsonParse(item);
            });
        }
        return item || undefined;
    }

    /**
    * Retrieve the guid of the supplied subject regardless of whether the supplied
    * subject is a guid or a subject object
    *
    * @param	subjectGuid
    *					String containing the guid to return or Object containing the subject
    *					_meta block containing the subject guid
    * 
    * @return	String containing the subject guid
    */
    function getSubjectGuid(subjectGuid) {
        if (subjectGuid && subjectGuid.constructor === Object) {
            subjectGuid = subjectGuid._meta.guid;
        }
        return subjectGuid;
    }

    /**
    * Retrieve the saved process matching the supplied process name
    *
    * @return	saved process object
    */
    function getProcess(processName) {
        return mc.profiler.profileSync('getProcess', function() {
            return mc.db.getJsonItem(processName);
        });
    }

    /**
    * Retrieve the names array of the installed processes
    *
    * @return names array of installed processes 
    */
    function getProcessNames() {
        return mc.db.getJsonItem('processNames');
    }

    /**
    * Retrieve an array of version strings for the supplied processId
    *
    * @param	processId
    *					String containing the processId to search for versions of
    *
    * @return	array of strings containing installed versions
    */
    function getProcessVersions(processId) {
        var versions = [], names;
        names = mc.db.getProcessNames();
        if (names !== undefined) {
            $.each(names, function(index, value) {
                var id, parts, version;
                index = undefined;
                parts = value.split(' ');
                id = parts[0];
                version = parts[1];
                if (processId === id) {
                    versions.push(version);
                }
            });
        }
        return versions;
    }

    /**
    * Retrieve the latest version string matching the supplied processId
    *
    * @param	processId
    *					String containing the processId to search for the latest version
    *
    * @return	String containing latest installed version
    */
    function getLatestProcessVersion(processId) {
        var latestVersion, versions;
        versions = mc.db.getProcessVersions(processId);
        if (versions !== undefined) {
            $.each(versions, function(index, value) {
                index = undefined;
                if (latestVersion !== undefined) {
                    if (compareVersions(latestVersion, value) < 0) {
                        latestVersion = value;
                    }
                } else {
                    latestVersion = value;
                }
            });
        }
        return latestVersion;
    }

    /**
    * Persist a JSON packed object to local storage with the supplied name
    *
    * @param name
    *					string containing key name of item in local storage
    * @param item
    *					object to be JSON packed and saved
    */
    function setJsonItem(name, item) {
        var s;
        s = mc.profiler.profileSync('setJsonItemStringify', function() {
            return $.jsonStringify(item);
        });
        mc.profiler.profileSync('setJsonItemWrite', function() {
            try {
                localStorage.setItem(name, s);
            } catch (e) {
                if (e.code === 22) { // QUOTA_EXCEEDED_ERR - iPad bug workaround
                    localStorage.removeItem(name);
                    localStorage.setItem(name, s);
                } else {
                    throw (e);
                }
            }
        });
    }

    /**
    * Save the supplied process with the supplied process name
    *
    * @param	processName
    *					string containing unique name of process-version
    * @param	process
    *					process object to save
    */
    function setProcess(processName, process) {
        log.debug('IN mc.db.setProcess');
        mc.profiler.profileSync('setProcess', function() {
            log.debug('OUT mc.db.setProcess profiler');
            mc.db.setJsonItem(processName, process);
        });
    }

    /**
    * Save the names array of installed processes
    *
    * @param	processNames
    *					array of strings containing the unique name of all installed process-
    *					versions
    */
    function setProcessNames(processNames) {
        mc.db.setJsonItem('processNames', processNames);
    }

    /**
    * Make a string representation of a unique process name from the supplied
    * process info object
    *
    * @param processInfo
    *					Object containing at least id & version.
    *
    * @return	string containing unique process name
    */
    function makeProcessName(processInfo) {
        var processName;
        processName = '';
        if (processInfo && processInfo.id && processInfo.version) {
            processName = processInfo.id.replace(' ', '_');
            processName += ' ' + processInfo.version.replace(' ', '_');
        }
        return processName;
    }

    /**
    * Retrieve the saved subject matching the supplied subject guid
    *
    * @return	saved subject object
    */
    function getSubject(subjectGuid, callback, columns) {
        if (callback && typeof callback === 'function') {
            if (subjectGuid && subjectGuid.constructor === String) {
                if (!columns && currentSubject && subjectGuid === currentSubject.guid) {
                    callback(currentSubject.value);
                } else {
                    doTx('readTransaction', function(transaction) {
                        var i, params, sql;
                        function success(tx, result) {
                            var subject;
                            tx = undefined;
                            if (result && result.rows.length > 0) {
                                subject = $.jsonParse(result.rows.item(0).answers);
                                if (columns) {
                                    columns = result.rows.item(0);
                                    delete columns.answers;
                                }
                            }
                            callback(subject, undefined, columns);
                        }
                        function error(tx, e) {
                            tx = undefined;
                            callback(undefined, e);
                        }
                        params = [subjectGuid];
                        sql = 'SELECT answers ';
                        if (columns) {
                            for (i = 0; i < 50; i += 1) {
                                sql += ', col' + i.toString();
                            }
                        }
                        sql += ' FROM subject WHERE guid = ?';
                        transaction.executeSql(sql, params, success, error);
                    });
                }
            } else {
                callback(subjectGuid);
            }
        }
    }

    /**
    * Retrieve an object containing all of the installed process-versions which
    * have current subjects
    *
    * @param callback
    *					function to receive object containing a member for each processId. The
    *					name of the member id the processId, the value of the member is an array
    *					of strings, each string is an installed version of the respective 
    *					process.
    */
    function getUsedProcessVersions(callback) {
        var calledBack;
        function safeCallback(o) {
            if (!calledBack) {
                calledBack = true;
                callback(o);
            }
        }
        if (callback && typeof callback === 'function') {
            doTx('readTransaction', function(tx) {
                var sql;
                function success(tx, result) {
                    var i, row, usedProcessVersions = {};
                    tx = undefined;
                    if (result && result.rows && result.rows.length) {
                        for (i = 0; i < result.rows.length; i += 1) {
                            var processName, process;
                            row = result.rows.item(i);

                            processName = makeProcessName({ id: row.processId, version: row.processVersion });
                            process = getProcess(processName);

                            if (process.home)
                                continue;

                            //We must maintain the UPV because at some point we may step out of this subject
                            //into another and expect to come back to this one before deleting it
                            //We may request a new cache in the intervening period and if that gets swapped
                            //we will be unable to open this subject
                            //if (process.singleSubject && (process.deleteOnClose || process.deleteOnOpen))
                            //    continue;

                            if (usedProcessVersions[row.processId] === undefined) {
                                usedProcessVersions[row.processId] = [row.processVersion];
                            } else {
                                usedProcessVersions[row.processId].push(row.processVersion);
                            }
                        }
                    }
                    safeCallback(usedProcessVersions);
                }
                function error(tx, e) {
                    tx = undefined;
                    e = undefined;
                    safeCallback({});
                }

                sql = "SELECT DISTINCT processId, processVersion FROM subject WHERE backupGuid IS NULL";
                tx.executeSql(sql, [], success, error);

            }, function() {
                safeCallback({});
            });
        }
    }

    /**
    * Save a named value and expiry date in the document cookie
    *
    * @param	name
    *					String containing the name of the item to be saved in the cookie
    * @param	value
    *					String containing the value of the item to be saved in the cookie
    * @param expireDays
    *					Optional number containing the number of days before the item expires
    */
    function setCookie(name, value, expireDays) {
        var exDate;
        if (value === undefined || value === null) {
            expireDays = -1;
            value = '';
        }
        exDate = new Date();
        exDate.setDate(exDate.getDate() + expireDays);
        document.cookie = name + "=" + window.escape(value) +
			((expireDays === undefined) ? "" : ";expires=" + exDate.toUTCString()) + "; path=/";
    }

    function updateUsedProcessVersionsCookie(callback) {
        mc.db.getUsedProcessVersions(function(usedProcessVersions) {
            mc.db.setCookie('usedProcessVersions', $.jsonStringify(usedProcessVersions));
            if (window.plugins && window.plugins.settings && window.plugins.settings.setPreference) {
                window.plugins.settings.setPreference(function() {
                    log.debug('Set usedProcessVersions to: ' + $.jsonStringify(usedProcessVersions));
                }, function() {
                    log.error('Failed to set usedProcessVersions preference');
                }, "usedProcessVersions", $.jsonStringify(usedProcessVersions));
            }
            callback();
        });
    }

    /**
    * Delete the process with the supplied name. Ensure any subjects are also
    * deleted and the processNames list is maintained
    *
    * @param	processName
    *					String containing the name of the process to delete
    */
    function deleteProcess(processName) {
        var i, n, process, processNames;
        process = mc.db.getProcess(processName);
        //		if (process.subjectGuids !== undefined) {
        //			$.each(process.subjectGuids, function (index, value) {
        //				index = undefined;
        //				localStorage.removeItem(value); // Think this is a bug, legacy of when subjects were stored in localStorage
        //			});
        //		}
        //		localStorage.removeItem(processName);
        processNames = mc.db.getProcessNames();
        if (processNames) {
            n = processNames.length;
            for (i = 0; i < n; i += 1) {
                if (processNames[i] === processName) {
                    processNames.splice(i, 1);
                    break;
                }
            }
            setProcessNames(processNames);
        }
    }

    /**
    * Delete the subject with the supplied guid. Ensure process integrity is
    * maintained.
    *
    * @param subjectGuid
    *					String containing guid of subject or subject object to delete
    * @param	callback
    *					optional function called when deletion has completed. 1st parameter is
    *					an error object, if it's undefined then no error occurred.
    * @param	keepAttachments
    *					If set attachments won't be deleted
    *					
    */
    function deleteSubject(subjectGuid, callback, keepAttachments) {
        mc.db.getSubject(subjectGuid, function(subject, e) {
            var i, n, process, processName;
            function deleted(e) {
                if (!e) {
                    if (!keepAttachments && mc.replstore !== undefined) {
                        mc.replstore.delete_attachment_date(subjectGuid);
                    }
                    if (process && process.version !== mc.db.getLatestProcessVersion(process.id)) {
                        if (process.subjectGuids === undefined ||
														process.subjectGuids.length === 0) {
                            deleteProcess(processName);
                        }
                    }
                    updateUsedProcessVersionsCookie(function() {
                        if (callback) {
                            callback();
                        }
                    });
                } else {
                    if (callback) {
                        callback(e);
                    }
                }
            }
            subjectGuid = mc.db.getSubjectGuid(subjectGuid);
            if (subject !== undefined && subject !== null) {
                processName = mc.db.makeProcessName({ 'id': subject._meta.processId,
                    'version': subject._meta.processVersion
                });
                if (currentProcess !== undefined && currentProcess.name !== undefined
						&& currentProcess.name === processName) {
                    process = currentProcess.value;
                } else {
                    process = mc.db.getProcess(processName);
                }
                if (process !== undefined) {
                    if (process.subjectGuids !== undefined) {
                        n = process.subjectGuids.length;
                        for (i = 0; i < n; i += 1) {
                            if (process.subjectGuids[i] === subjectGuid) {
                                process.subjectGuids.splice(i, 1);
                                if (process.currentSubjectGuid === subjectGuid) {
                                    delete process.currentSubjectGuid;
                                }
                                mc.db.setProcess(processName, process);
                                break;
                            }
                        }
                    }
                }
                mc.db._deleteSubject(subjectGuid, keepAttachments, deleted);
            } else {
                if (callback) {
                    callback(e);
                }
            }
        });
    }

    /**
    * Retrieve all of the guids which are backups of the supplied guid
    *
    * @param	guid
    *					string containing guid to find backups of
    * @param	callback
    *					function called back when backup guids have been retrieved. 1st parameter
    *					parameter is array of guid strings
    */
    function getBackupGuids(guid, callback) {
        var guids, params, sql;
        function error(tx, e) {
            tx = undefined;
            e = undefined;
            callback();
        }
        function success(tx, result) {
            var i;
            tx = undefined;
            guids = [];
            if (result.rows && result.rows.length) {
                for (i = 0; i < result.rows.length; i += 1) {
                    guids.push(result.rows.item(i).guid);
                }
            }
            callback(guids);
        }
        params = [];
        sql = 'SELECT guid FROM subject WHERE backupGuid=?;';
        params.push(guid);
        doTx('readTransaction', function(tx) {
            tx.executeSql(sql, params, success, error);
        });
    }

    /**
    * Retrieve the saved attachment matching the supplied subject guid and name
    *
    * @return	saved subject object
    */
    function getAttachment(subjectGuid, name, callback) {
        if (callback && typeof callback === 'function') {
            log.debug('getAttachment ' + subjectGuid + ' ' + name);
            doTx('readTransaction', function(tx) {
                var params, sql;
                function success(tx, result) {
                    tx = undefined;
                    if (result && result.rows.length > 0) {
                        callback(result.rows.item(0).data);
                    } else {
                        callback();
                    }
                }
                function error(tx, e) {
                    tx = undefined;
                    callback(undefined, e);
                }
                params = [mc.db.getSubjectGuid(subjectGuid), name];
                sql = 'SELECT data FROM attachment WHERE subjectGuid=? AND name=?';
                tx.executeSql(sql, params, success, error);
            });
        }
    }

    /**
    * Save the supplied attachment with the supplied subject guid and name
    *
    * @param	subjectGuid
    *					string containing unique guid of subject
    * @param	name
    *					name of attachment - must be unique for this subject
    * @param data
    *					data of attachment to save
    * @param callback
    *					optional function called on completion. 1st parameter is error object,
    *					if error object is undefined then the operation succeeded
    */
    function setAttachment(subjectGuid, name, data, markChanged, callback) {
        var params, sql;

        function success(tx, r) {
            tx = undefined;
            r = undefined;

            if (markChanged) {
                mc.replstore.store_attachment_date(subjectGuid, name, new Date());
            }
            if (callback) {
                callback();
            }
        }

        function error(tx, e) {
            tx = undefined;
            if (callback) {
                callback(e);
            }
        }

        log.debug('setAttachment ' + subjectGuid + ' ' + name);
        function update(tx) {
            sql = 'UPDATE attachment SET data=? WHERE subjectGuid=? AND name=?';
            params = [data, subjectGuid, name];
            tx.executeSql(sql, params, success, error);
        }

        sql = 'INSERT INTO attachment (subjectGuid,name,data) VALUES(?,?,?)';
        params = [mc.db.getSubjectGuid(subjectGuid), name, data];
        doTx('transaction', function(tx) {
            tx.executeSql(sql, params, function(tx, result) {
                if (result && result.rowsAffected === 1) {
                    success(tx, result);
                } else {
                    update(tx);
                }
            }, update);
        }, function(e) { error(undefined, e); });
    }

    /**
    * Get a list of all attachments in the database
    *
    * @param	guid
    *					optional string containing the guid which to filter attachments for
    *
    * @return	array of all attachments, as {subjectGuid: guid, name: attachmentName}
    */
    function getAttachmentList(guid, callback) {
        if (callback && typeof callback === 'function') {
            doTx('readTransaction', function(tx) {
                var params, sql;
                function success(tx, result) {
                    var dataOut, i, row;
                    tx = undefined;
                    if (!result) {
                        callback();
                    } else {
                        dataOut = [];
                        for (i = 0; i < result.rows.length; i += 1) {
                            row = result.rows.item(i);
                            dataOut.push({ subjectGuid: row.subjectGuid, name: row.name });
                        }
                        callback(dataOut);
                    }
                }
                function error(tx, e) {
                    tx = undefined;
                    callback(undefined, e);
                }
                params = [];
                sql = 'SELECT subjectGuid, name FROM attachment';
                if (guid) {
                    sql += ' WHERE subjectGuid=?';
                    params.push(guid);
                }
                tx.executeSql(sql, params, success, error);
            });
        }
    }

    function ensureReplDataPresent(subject) {
        if (subject._meta === undefined) {
            subject._meta = {};
        }
        if (subject._meta.syncInfo === undefined) {
            subject._meta.syncInfo = {};
        }
        if (subject._meta.syncInfo.cseq === undefined) {
            subject._meta.syncInfo.cseq = 1;
        }
        if (subject._meta.syncInfo.sseq === undefined) {
            subject._meta.syncInfo.cseq = 0;
        }
    }

    /**
    * Save the supplied subject with the supplied subject guid
    *
    * @param	subjectGuid
    *					string containing unique guid of subject
    * @param	subject
    *					subject object to save
    * @param noTouch
    *					boolean indicating whether the modified field should not be updated
    * @param callback
    *					optional function called on completion. 1st parameter is error object,
    *					if error object is undefined then the operation succeeded
    * @param	columnValues
    *					optional array of column values to save
    */
    function setSubject(subjectGuid, subject, noTouch, callback, columnValues) {
        var i, metaColumns, n, params, serverIdValue, sqlUpdate, sqlInsert, syncInfoList;
        function success(tx, r) {
            tx = undefined;
            r = undefined;
            if (callback) {
                callback();
            }
        }
        function error(tx, e) {
            tx = undefined;
            if (callback) {
                callback(e);
            }
        }
        function insert(tx) {
            sqlInsert += 'answers,guid) VALUES (';
            n = params.length;
            for (i = 0; i < n; i += 1) {
                sqlInsert += i ? ',?' : '?';
            }
            sqlInsert += ')';
            tx.executeSql(sqlInsert, params, success, error);
        }
        if (noTouch !== true) {
            subject._meta.modified = new Date();
            mc.db.ensureReplDataPresent(subject);
            subject._meta.syncInfo.cseq++;
        }
        subjectGuid = mc.db.getSubjectGuid(subjectGuid);
        sqlUpdate = 'UPDATE subject SET ';
        sqlInsert = 'INSERT INTO subject (';
        metaColumns = ['processId', 'processVersion', 'created', 'modified'];
        n = metaColumns.length;
        params = [];
        for (i = 0; i < n; i += 1) {
            if (subject._meta.hasOwnProperty(metaColumns[i])) {
                sqlUpdate += metaColumns[i] + '=?,';
                sqlInsert += metaColumns[i] + ',';
                params.push(subject._meta[metaColumns[i]]);
            }
        }
        if (columnValues) {
            for (i = 0; i < columnValues.length; i += 1) {
                if (columnValues[i] !== undefined && columnValues[i] !== null) {
                    sqlInsert += 'col' + i + ',';
                    sqlUpdate += 'col' + i + '=?,';
                    params.push(columnValues[i]);
                }
            }
        }
        sqlUpdate += 'serverId=?,';
        sqlInsert += 'serverId,';
        syncInfoList = subject._meta.syncInfo;
        if (syncInfoList !== undefined) {
            serverIdValue = syncInfoList.ServerId;
            if (serverIdValue !== undefined) {
                params.push(serverIdValue);
            } else {
                params.push(null);
            }
        } else {
            params.push(null);
        }
        sqlUpdate += 'backupGuid=?,';
        sqlInsert += 'backupGuid,';
        params.push(subject._meta.backupGuid || null);
        sqlUpdate += ' answers=? WHERE guid=?';
        params.push($.jsonStringify(subject));
        params.push(subjectGuid);
        doTx('transaction', function(transaction) {
            transaction.executeSql(sqlUpdate, params, function(tx, result) {
                if (result && result.rowsAffected === 1) {
                    success(tx, result);
                } else {
                    insert(transaction);
                }
            }, insert);
        });
        if (currentSubject && currentSubject.guid && currentSubject.guid === subjectGuid) {
            currentSubject.value = subject;
        }
    }

    /**
    * Clone the subject with the matching guid
    *
    * @param	guid
    *					string containing guid of subject to clone OR object containing the 
    *					subject
    * @param	persist
    *					boolean indicating whether the cloned subject should persist or not
    * @param	callback
    *					function called back when subject object has been cloned. 1st parameter
    *					is object containing the cloned subject object
    * @param	newGuid
    *					optional string containing the guid of the clone. If not supplied a new
    *					guid will be generated, _meta & syncInfo will be reset to defaults
    * @param backup
    *					optional boolean indicating that the purpose of the clone is backup
    */
    function cloneSubject(guid, persist, callback, newGuid, backup) {
        function gotSubject(subject, e, columns) {
            var d;
            e = undefined;
            function duplicateAttachment(guid, name, callback) {
                mc.att.duplicateAttachment(guid, name, subject._meta.guid, name, callback);
            }
            function duplicateAttachments(guid, callback) {
                function gotAttachmentList(atts) {
                    var count, i;
                    function duplicated() {
                        count -= 1;
                        if (count <= 0) {
                            callback();
                        }
                    }
                    count = 0;
                    if (atts && atts.length) {
                        count = atts.length;
                        for (i = 0; i < atts.length; i += 1) {
                            duplicateAttachment(atts[i].subjectGuid, atts[i].name, duplicated);
                        }
                    } else {
                        callback();
                    }
                }
                mc.db.getAttachmentList(guid, gotAttachmentList);
            }
            if (subject) {
                guid = mc.db.getSubjectGuid(guid);
                if (subject === currentSubject.value || subject === backupSubject) {
                    subject = $.jsonCopy(subject);
                }
                if (newGuid) {
                    subject._meta.guid = newGuid;
                } else {
                    d = new Date();
                    subject._meta.created = d;
                    subject._meta.modified = d;
                    subject._meta.completed = false;
                    subject._meta.deleted = false;
                    delete subject._meta.pageStack;
                    delete subject._meta.syncInfo.ServerId;
                    delete subject._meta.syncInfo.SyncData;
                    delete subject._meta.syncInfo.timeout;
                    subject._meta.syncInfo.cseq = 1;
                    subject._meta.syncInfo.sseq = 0;
                    subject._meta.guid = mc.db.guid();
                    // A new subject on the device doesnt have a meta.process so make the name
                    var processName = mc.db.makeProcessName({ 'id': subject._meta.processId,
                        'version': subject._meta.processVersion
                    });
                    var process = mc.db.getProcess(processName);
                    process.subjectGuids.push(subject._meta.guid)
                    mc.db.setProcess(processName, process);
                }
                if (backup) {
                    subject._meta.backupGuid = guid;
                } else {
                    delete subject._meta.backupGuid;
                }

                if (persist) {
                    duplicateAttachments(guid, function() {
                        var a, i;
                        if (columns) {
                            a = [];
                            for (i = 0; i < 50; i += 1) {
                                a[i] = columns['col' + i.toString()];
                            }
                        }
                        mc.db.setSubject(subject._meta.guid, subject, true, function() {
                            callback(subject);
                        }, a);
                    });
                } else {
                    callback(subject);
                }
            } else {
                callback();
            }
        }
        mc.db.getSubject(guid, gotSubject, true);
    }

    /**
    * Delete all backups of the the current subject
    *
    * @param	callback
    *					function called back when backups have been deleted.
    */
    function deleteBackup(callback) {
        function gotGuids(guids) {
            var count, i;
            function complete() {
                count -= 1;
                if (count <= 0) {
                    callback();
                }
            }
            if (guids && guids.length) {
                count = guids.length;
                for (i = 0; i < guids.length; i += 1) {
                    mc.db.deleteSubject(guids[i], complete);
                }
            } else {
                callback();
            }
        }
        backupSubject = undefined;
        try {
            getBackupGuids(currentSubject.guid, gotGuids);
        } catch (e) {
            callback();
        }
    }


    /**
    * Backup the current subject
    *
    * @param	callback
    *					function called back when subject has been backed up. 1st parameter is
    *					object containing the backed up subject
    */
    function backupCurrentSubject(callback) {
        mc.db.deleteBackup(function() {
            mc.db.cloneSubject(currentSubject.value, true, function(subject) {
                backupSubject = subject;
                callback(subject);
            }, undefined, true);
        });
    }

    /**
    * Create the SQLite database, subject & summary tables. Upgrade to current
    * version.
    * N.B. You can only reliably call db.changeVersion once during this instance
    * 			of a URL. Also, db.version does NOT change until a URL refresh. This
    *			documented in the Safari Developer Library. Safari also has a better
    *			versioning algorithm than the outdated w3c spec and is implemented here.
    *
    * @param	success
    *					function called when database has been successfully opened and upgraded
    *					to the current version
    * @param error
    *					function called when a database error has occurred
    */
    function createDb(success, error) {
        log.debug('IN mc.db.createDb');
        var retryCount;
        function createSchema10(transaction) {
            var i, sql, successCount;
            successCount = 0;
            sql = 'CREATE TABLE IF NOT EXISTS subject'
					+ ' (id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,'
					+ ' processId TEXT NOT NULL, processVersion TEXT NOT NULL, type INTEGER,'
					+ ' guid TEXT NOT NULL, backupGuid TEXT, serverId TEXT, created DATETIME,'
					+ ' modified DATETIME, answers TEXT';
            for (i = 0; i < 50; i += 1) {
                sql += ', col' + i + ' TEXT';
            }
            sql += ');';
            transaction.executeSql(sql, undefined, undefined, error);
            for (i = 0; i < 10; i += 1) {
                sql = 'CREATE INDEX IF NOT EXISTS col' + i + ' ON subject(col' + i + ');';
                transaction.executeSql(sql, undefined, undefined, error);
            }
            sql = 'CREATE UNIQUE INDEX IF NOT EXISTS subjectByGuid ON subject(guid);';
            transaction.executeSql(sql, undefined, undefined, error);
            sql = 'CREATE TABLE IF NOT EXISTS attachment'
					+ ' (id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,'
					+ ' subjectGuid TEXT NOT NULL, name TEXT NOT NULL, data BLOB);';
            transaction.executeSql(sql, undefined, undefined, error);
            sql = 'CREATE UNIQUE INDEX IF NOT EXISTS subjectByGuid ON subject(guid);';
            transaction.executeSql(sql, undefined, undefined, error);
            sql = 'CREATE UNIQUE INDEX IF NOT EXISTS attachmentByGuidName ON attachment(subjectGuid,name);';
            transaction.executeSql(sql, undefined, undefined, error);
        }

        function expand(db, success, error) {
            var options = window.deviceOptions, expandTo, o = { delay: '' };
            if (!options || !options.expandDatabaseTo || options.expandDatabaseTo < 1) {
                log.debug('Initial database expansion not requested.');
                success();
                return;
            }
            expandTo = options.expandDatabaseTo;
            log.debug('Initial database expansion requested: ' + expandTo + 'MB');

            if (mc.testingInBrowser) {
                log.debug('Database expansion skipped (testing in browser).');
                success();
                return;
            }
            function myError(e) {
                o.delay = '400';
                MCAPTURE_ProcessProvisioned(o);
                expansionError = JSON.stringify(e)
                log.error('Error expanding initial database' + expansionError);
                success();
            }
            function mySuccess() {
                log.debug('Database expansion complete.');
                o.delay = '300';
                MCAPTURE_ProcessProvisioned(o);
                success();
            }
            function drop(success) {
                log.debug('IN mc.db.createDb.drop');
                o.delay = '10000';
                MCAPTURE_ProcessProvisioned(o);
                db.transaction(function(tx) {
                    var sql = 'DROP TABLE IF EXISTS expandDB';
                    tx.executeSql(sql, []);
                }, myError, success);
            }
            function create(success) {
                log.debug('IN mc.db.createDb.create');
                o.delay = '100';
                MCAPTURE_ProcessProvisioned(o);
                db.transaction(function(tx) {
                    var sql = 'CREATE TABLE IF NOT EXISTS expandDB (data BLOB)';
                    tx.executeSql(sql, []);
                }, myError, success);
            }
            function fill(success) {
                //debugger;
                log.debug('IN mc.db.createDb.fill');
                var data = Array(128 * 1024 + 1).join('a');
                var sql = 'INSERT INTO expandDB (data) VALUES (?)';
                var params = [data];
                var i = 4 * expandTo;
                db.transaction(function(transaction) {
                    function insert() {
                        log.debug('Expanding initial database (' + i + ')');
                        o.delay = i.toString();
                        MCAPTURE_ProcessProvisioned(o);
                        if (i === 0) {
                            return;
                        }
                        i--;
                        transaction.executeSql(sql, params, insert);
                    }
                    insert();
                }, myError, success);
            }
            drop(function() {
                create(function() {
                    fill(function() {
                        drop(mySuccess);
                    });
                });
            });
        }

        function openDb() {
            log.debug('IN mc.db.createDb.openDb');
            try {
                db = window.openDatabase('mDesign', '', 'mDesign', 1048576);
                switch (db.version) {
                    case '':
                        function mySuccess(callback) {
                            expand(db, success, error);
                        }
                        db.changeVersion('', '1.0', createSchema10, error, mySuccess);
                        break;
                    case '1.0':
                        success();
                        break; // Up to date
                    /*
                    // Version 2.0
                    case '':
                    db.changeVersion('', '2.0', createSchema20, error, success);
                    break;
                    case '1.0':
                    db.changeVersion('1.0', '2.0', upgrade10to20, error, success);
                    break;
                    case '1.1':
                    db.changeVersion('1.1', '2.0', upgrade11to20, error, success);
                    break;
                    case '2.0':
                    success();
                    break;
                    */ 
                    default:
                        error({ message: 'Invalid database version: ' + db.version });
                        break;
                }
            } catch (ex) {
                retryCount -= 1;
                if (retryCount > 0) {
                    log.error('Failed to open database, will retry in 500ms.');
                    setTimeout(openDb, 500);
                } else {
                    log.error('Failed to open database, retryCount exceeded. Exception: ' + ex.message);
                    error(ex);
                }
            }
        }
        if (!db) {
            retryCount = 3;
            openDb();
        } else {
            success();
        }
    }

    /**
    * Drop all tables in the SQLite database
    */
    function clear(success, error) {
        log.debug('IN mc.db.clear');
        function createSuccess() {
            var successCount;
            function incSuccessCount() {
                if (++successCount === 4) {
                    db.changeVersion(db.version, '', function() { }, error, success);
                    //success();
                }
            }
            function dropSuccess(tx, result) {
                tx = undefined;
                result = undefined;
                incSuccessCount();
            }
            function dropError(tx, e) {
                tx = undefined;
                if (e.code === 1) {
                    incSuccessCount();
                } else {
                    error(e);
                }
            }
            if (db) {
                successCount = 0;
                doTx('transaction', function(transaction) {
                    transaction.executeSql('DROP TABLE IF EXISTS subject', undefined, dropSuccess, dropError);
                    transaction.executeSql('DROP TABLE IF EXISTS attachment', undefined, dropSuccess, dropError);
                    transaction.executeSql('DROP INDEX IF EXISTS subjectByName', undefined, dropSuccess, dropError);
                    transaction.executeSql('DROP INDEX IF EXISTS attachmentByGuidName', undefined, dropSuccess, dropError);
                });
            } else {
                error({ message: 'SQLite db not created, unknown error.' });
            }
        }
        function createError(tx, e) {
            tx = undefined;
            error(e);
        }

        function clearDB() {
            log.debug('clear[db]');
            if (db === undefined) {
                mc.db.createDb(createSuccess, createError);
            } else {
                createSuccess();
            }
        }
        function clearFS() {
            log.debug('clear[fs]');
            mc.fs.clear(clearDB, function(e) {
                error({ message: 'File System not cleared, error ' + e.code });
            });
        }
        mc.fs.availableForAtts ? clearFS() : clearDB();
    }

    /**
    * Create a new pseudo unique guid
    *
    * @return	string containing new guid
    */
    function guid() {
      return window.uuid();
    }

    /**
    * Retrieve all the subject guids belonging to the supplied processId and
    * process version
    *
    * @param processId
    *					optional String containing the processId to use on the query
    * @param processVerions
    *					optional String containing the processVersion to use in the query
    * @param callback
    *					function to receive the array of guids
    */
    function getSubjectGuids(processId, processVersion, callback) {
        log.debug('IN mc.db.getSubjectGuids');
        if (callback && typeof callback === 'function') {
            if (db) {
                function transactionCallback() {
                    log.error('mc.db.getSubjectGuids - transaction callback');
                    callback([]);
                }
                doTx('readTransaction', function(tx) {
                    var params, sql;
                    function success(tx, result) {
                        var guids, i;
                        tx = undefined;
                        guids = [];
                        if (result && result.rows && result.rows.length) {
                            for (i = 0; i < result.rows.length; i += 1) {
                                guids.push(result.rows.item(i).guid);
                            }
                        }
                        callback(guids);
                    }
                    function error(tx, e) {
                        tx = undefined;
                        e = undefined;
                        callback([]);
                    }
                    params = [];
                    sql = 'SELECT guid FROM subject WHERE backupGuid IS NULL';
                    if (processId || processVersion) {
                        sql += ' AND';
                        if (processId) {
                            sql += ' processId = ?';
                            params.push(processId);
                            if (processVersion) {
                                sql += ' AND';
                            }
                        }
                        if (processVersion) {
                            sql += ' processVersion = ?';
                            params.push(processVersion);
                        }
                    }
                    tx.executeSql(sql, params, success, error);
                }, transactionCallback);
            } else {
                log.error('mc.db.getSubjectGuids - no database');
                callback([]);
            }
        } else {
            log.error('mc.db.getSubjectGuids - no callback');
        }
    }

    /**
    * Create a persistent process with the supplied info and maintains persistent
    * processNames array
    *
    * @param processInfo
    *					Object containing at least id & version. Can optionally contain
    *					title, hidden & pages
    * @param callback
    * 					function to receive object containing the unique name identifying
    *					process-version and the process object
    */
    function createProcess(processInfo, callback) {
        log.debug('IN mc.db.createProcess');
        function dbError(e) {
            log.debug('IN mc.db.createProcess.dbError : ' + e);
            if (callback) {
                callback(e);
            }
        }
        function dbCreated() {
            log.debug('IN mc.db.createProcess.dbCreated');
            var i, n, process, processName, processNames, property;
            processName = mc.db.makeProcessName(processInfo);
            processNames = mc.db.getProcessNames() || [];
            n = processNames.length;
            log.debug('mc.db.createProcess.dbCreated count: ' + n);
            for (i = 0; i < n; i += 1) {
                log.debug('mc.db.createProcess.dbCreated process ' + processNames[i]);
                if (processNames[i] === processName) {
                    process = mc.db.getProcess(processName);
                    if (process === undefined) {
                        log.debug('mc.db.createProcess.dbCreated process not found');
                        processNames.splice(i, 1);
                        n -= 1;
                    }
                    break;
                }
            }
            if (process === undefined) {
                log.debug('mc.db.createProcess.dbCreated process not defined');
                process = processInfo;
                process.visualizationSubjectGuid = mc.db.guid();
                processNames.push(processName);
                setProcessNames(processNames);
                mc.db.getSubjectGuids(processInfo.id, processInfo.version, function(guids) {
                    log.debug('IN mc.db.createProcess gotSubjectGuids');
                    process.subjectGuids = guids;
                    setProcess(processName, process);
                    if (callback) {
                        callback({ name: processName, value: process });
                    } else {
                        log.debug('mc.db.createProcess goSubjectGuids no callback');
                    }
                });
            } else {
                log.debug('mc.db.createProcess.dbCreated copy process');
                for (property in processInfo) {
                    if (processInfo.hasOwnProperty(property)) {
                        process[property] = processInfo[property];
                    }
                }
                mc.db.setProcess(processName, process);
                if (callback) {
                    callback({ name: processName, value: process });
                } else {
                    log.debug('mc.db.createProcess no callback');
                }
            }
        }
        if (!db) {
            mc.db.createDb(dbCreated, dbError);
        } else {
            dbCreated();
        }
    }

    /**
    * Retrieve the saved subject matching the supplied subject guid
    *
    * @return	saved subject object
    */
    function getSubjectInTransaction(transaction, subjectGuid, callback, columns) {
        mc.profiler.profileAsync('getSubjectInTransaction', function(profileComplete) {
            var i, params, sql;
            function success(tx, result) {
                var subject;
                if (result && result.rows.length > 0) {
                    subject = mc.profiler.profileSync('getSubjectParse', function() {
                        return $.jsonParse(result.rows.item(0).answers);
                    });
                    if (columns) {
                        columns = result.rows.item(0);
                        delete columns.answers;
                    }
                }
                profileComplete();
                callback(tx, subject, undefined, columns);
            }
            function error(tx, e) {
                tx = undefined;
                profileComplete();
                callback(undefined, e);
            }
            if (callback && typeof callback === 'function') {
                if (subjectGuid && subjectGuid.constructor === String) {
                    if (!columns && currentSubject && subjectGuid === currentSubject.guid) {
                        profileComplete();
                        callback(transaction, currentSubject.value);
                    } else {
                        params = [subjectGuid];
                        sql = 'SELECT answers ';
                        if (columns) {
                            for (i = 0; i < 50; i += 1) {
                                sql += ', col' + i.toString();
                            }
                        }
                        sql += ' FROM subject WHERE guid = ?';
                        transaction.executeSql(sql, params, success, error);
                    }
                } else {
                    profileComplete();
                    callback(transaction, subjectGuid);
                }
            } else {
                profileComplete();
            }
        });
    }

    /**
    * Save the supplied subject with the supplied subject guid
    *
    * @param	transaction
    *					the existing DB transaction
    * @param	subjectGuid
    *					string containing unique guid of subject
    * @param	subject
    *					subject object to save
    * @param noTouch
    *					boolean indicating whether the modified field should not be updated
    * @param callback
    *					optional function called on completion. 1st parameter is error object,
    *					if error object is undefined then the operation succeeded
    * @param	columnValues
    *					optional array of column values to save
    */
    function setSubjectInTransaction(transaction, subjectGuid, subject, noTouch, callback, columnValues) {
        mc.profiler.profileAsync('setSubjectInTransaction', function(profileComplete) {
            var i, metaColumns, n, params, serverIdValue, sqlUpdate, sqlInsert, syncInfoList;
            function success(tx, r) {
                tx = undefined;
                r = undefined;
                profileComplete();
                if (callback) {
                    callback();
                }
            }
            function error(tx, e) {
                tx = undefined;
                profileComplete();
                if (callback) {
                    callback(e);
                }
            }
            function insert(tx) {
                sqlInsert += 'answers,guid) VALUES (';
                n = params.length;
                for (i = 0; i < n; i += 1) {
                    sqlInsert += i ? ',?' : '?';
                }
                sqlInsert += ')';
                tx.executeSql(sqlInsert, params, success, error);
            }
            if (noTouch !== true) {
                subject._meta.modified = new Date();
                mc.db.ensureReplDataPresent(subject);
                subject._meta.syncInfo.cseq++;
            }
            subjectGuid = mc.db.getSubjectGuid(subjectGuid);
            sqlUpdate = 'UPDATE subject SET ';
            sqlInsert = 'INSERT INTO subject (';
            metaColumns = ['processId', 'processVersion', 'created', 'modified'];
            n = metaColumns.length;
            params = [];
            for (i = 0; i < n; i += 1) {
                if (subject._meta.hasOwnProperty(metaColumns[i])) {
                    sqlUpdate += metaColumns[i] + '=?,';
                    sqlInsert += metaColumns[i] + ',';
                    params.push(subject._meta[metaColumns[i]]);
                }
            }
            if (columnValues) {
                for (i = 0; i < columnValues.length; i += 1) {
                    if (columnValues[i] !== undefined && columnValues[i] !== null) {
                        sqlInsert += 'col' + i + ',';
                        sqlUpdate += 'col' + i + '=?,';
                        params.push(columnValues[i]);
                    }
                }
            }
            sqlUpdate += 'serverId=?,';
            sqlInsert += 'serverId,';
            syncInfoList = subject._meta.syncInfo;
            if (syncInfoList !== undefined) {
                serverIdValue = syncInfoList.ServerId;
                if (serverIdValue !== undefined) {
                    params.push(serverIdValue);
                } else {
                    params.push(null);
                }
            } else {
                params.push(null);
            }
            sqlUpdate += 'backupGuid=?,';
            sqlInsert += 'backupGuid,';
            params.push(subject._meta.backupGuid || null);
            sqlUpdate += ' answers=? WHERE guid=?';
            mc.profiler.profileSync('setSubjectStringify', function() {
                params.push($.jsonStringify(subject));
            });
            params.push(subjectGuid);
            transaction.executeSql(sqlUpdate, params, function(tx, result) {
                if (result && result.rowsAffected === 1) {
                    success(tx, result);
                } else {
                    insert(tx);
                }
            }, insert);
            if (currentSubject && currentSubject.guid && currentSubject.guid === subjectGuid) {
                currentSubject.value = subject;
            }
        });
    }

    /**
    * Create a new subject or open existing subject with matching guid
    *
    * @param   transaction
    *                  the existing transaction object
    * @param	processId
    *					string containing process id
    * @param	processVersion
    *					string containing version number
    * @param	subjectGuid
    *					string containing guid of subject to open/create. If omitted, a new
    *					guid is created
    * @param	callback
    *					function called back when subject object has been retrieved. 1st
    *					parameter is object containing the guid identifying subject and the
    *					subject object
    */
    function createSubjectInTransaction(transaction, processId, processVersion, subjectGuid, callback) {
        mc.profiler.profileAsync('createSubjectInTransaction', function(profileComplete) {
            var process, processName;
            function gotSubjectInTransction(tx, subject, e) {
                var d, i, n; // Maintain the process array of subjectGuids
                e = undefined;
                if (process && process.subjectGuids !== undefined) {
                    n = process.subjectGuids.length;
                    for (i = 0; i < n; i += 1) {
                        if (process.subjectGuids[i] === subjectGuid) {
                            if (subject === undefined) {
                                process.subjectGuids.splice(i, 1);
                            }
                            break;
                        }
                    }
                }
                if (subject === undefined) {
                    d = new Date(); // Do not change the structure of this object.
                    // Especialy the _meta.processId & _meta.processVersion
                    // fields. They are used in many different places
                    // in both client & server code. Changing this WILL 
                    // break lots of things
                    subject = {
                        _meta: {
                            completed: false,
                            created: d,
                            deleted: false,
                            guid: subjectGuid,
                            modified: d,
                            processId: processId,
                            processVersion: processVersion,
                            summaries: {
                                processid: processId
                            },
                            syncInfo: {
                                cseq: 1,
                                sseq: 0
                            }
                        }
                    };
                    if (currentSubject && currentSubject.guid) {
                        if (!subject._meta.syncInfo) {
                            subject._meta.syncInfo = {
                                parentguid: currentSubject.guid
                            };
                        } else if (!subject._meta.syncInfo.parentguid) {
                            subject._meta.syncInfo.parentguid = currentSubject.guid;
                        }
                    }
                    if (process && subjectGuid !== process.visualizationSubjectGuid) {
                        process.subjectGuids.push(subjectGuid);
                    }
                    if (process) {
                        mc.db.setProcess(processName, process);
                    }
                    mc.db.setSubjectInTransaction(transaction, subjectGuid, subject, false, function(tx2, error) {
                        profileComplete();
                        tx2 = undefined;
                        error = undefined;
                        callback({
                            guid: subjectGuid,
                            value: subject
                        });
                    });
                } else {
                    profileComplete();
                    callback({
                        guid: subjectGuid,
                        value: subject
                    });
                }
            } // Get the process object using the supplied process id & version
            processName = mc.db.makeProcessName({
                id: processId,
                version: processVersion
            });
            if (currentProcess !== undefined && currentProcess.name !== undefined && processName === currentProcess.name) {
                process = currentProcess.value;
            } else {
                process = mc.db.getProcess(processName);
            } // Create a new unique guid if one has not been supplied
            subjectGuid = mc.db.getSubjectGuid(subjectGuid);
            if (subjectGuid === undefined) {
                subjectGuid = mc.db.guid();
            }
            mc.db.getSubjectInTransaction(transaction, subjectGuid, gotSubjectInTransction);
        });
    }

    /**
    * Create a new subject or open existing subject with matching guid
    *
    * @param	processId
    *					string containing process id
    * @param	processVersion
    *					string containing version number
    * @param	subjectGuid
    *					string containing guid of subject to open/create. If omitted, a new
    *					guid is created
    * @param	callback
    *					function called back when subject object has been retrieved. 1st
    *					parameter is object containing the guid identifying subject and the
    *					subject object
    */
    function createSubject(processId, processVersion, subjectGuid, callback) {
        var process, processName;
        function gotSubject(subject, e) {
            var d, i, n;
            e = undefined;
            // Maintain the process array of subjectGuids
            if (process && process.subjectGuids !== undefined) {
                n = process.subjectGuids.length;
                for (i = 0; i < n; i += 1) {
                    if (process.subjectGuids[i] === subjectGuid) {
                        if (subject === undefined) {
                            process.subjectGuids.splice(i, 1);
                        }
                        break;
                    }
                }
            }
            if (subject === undefined) {
                d = new Date();

                // Do not change the structure of this object.
                // Especialy the _meta.processId & _meta.processVersion
                // fields. They are used in many different places
                // in both client & server code. Changing this WILL 
                // break lots of things
                subject = {
                    _meta: {
                        completed: false,
                        created: d,
                        deleted: false,
                        guid: subjectGuid,
                        modified: d,
                        processId: processId,
                        processVersion: processVersion,
                        summaries: {
                            processid: processId
                        },
                        syncInfo: {
                            cseq: 1,
                            sseq: 0
                        }
                    }
                };
                if (currentSubject && currentSubject.guid) {
                    if (!subject._meta.syncInfo) {
                        subject._meta.syncInfo = { parentguid: currentSubject.guid };
                    } else if (!subject._meta.syncInfo.parentguid) {
                        subject._meta.syncInfo.parentguid = currentSubject.guid;
                    }
                }
                if (process && subjectGuid !== process.visualizationSubjectGuid) {
                    process.subjectGuids.push(subjectGuid);
                }
                if (process) {
                    mc.db.setProcess(processName, process);
                }
                mc.db.setSubject(subjectGuid, subject, false, function(error) {
                    if (!error) {
                        updateUsedProcessVersionsCookie(function() {
                            callback({ guid: subjectGuid, value: subject });
                        });
                    } else {
                        callback({ guid: subjectGuid, value: subject });
                    }
                });
            } else {
                updateUsedProcessVersionsCookie(function() {
                    callback({ guid: subjectGuid, value: subject });
                });
            }
        }
        // Get the process object using the supplied process id & version
        processName = mc.db.makeProcessName({ id: processId, version: processVersion });
        if (currentProcess !== undefined && currentProcess.name !== undefined
				&& processName === currentProcess.name) {
            process = currentProcess.value;
        } else {
            process = mc.db.getProcess(processName);
        }
        // Create a new unique guid if one has not been supplied
        subjectGuid = mc.db.getSubjectGuid(subjectGuid);
        if (subjectGuid === undefined) {
            subjectGuid = mc.db.guid();
        }
        mc.db.getSubject(subjectGuid, gotSubject);
    }

    /**
    * Delete all the subjects belonging to the supplied processId and
    * process version
    *
    * @param processId
    *					optional String containing the processId to use on the query
    * @param processVerions
    *					optional String containing the processVersion to use in the query
    * @param callback
    *					function to call when all deletions have completed
    */
    function deleteAllSubjects(processId, processVersion, callback) {
        function gotSubjectGuids(guids) {
            var i, remaining;
            function deleted() {
                if (! --remaining) {
                    callback();
                }
            }
            if (guids && guids.length) {
                log.info('found ' + guids.length + ' subjects to delete');
                remaining = guids.length;
                for (i = 0; i < guids.length; i += 1) {
                    mc.db.deleteSubject(guids[i], deleted);
                }
            } else {
                callback();
            }
        }
        log.info('Deleting all subjects from process ' + processId + ' version ' + processVersion);
        mc.db.getSubjectGuids(processId, processVersion, gotSubjectGuids);
    }

    /**
    * Delete the attachment with the supplied subject guid and name.
    *
    * @param subjectGuid
    *					String containing guid of subject to delete
    * @param	name
    *					String containing the name of the attachment
    * @param	callback
    *					optioanl function called when deletion has completed. 1st parameter is
    *					an error object, if it's undefined then no error occurred.
    */
    function deleteAttachment(subjectGuid, name, callback) {
        var params, sql;

        function complete() {
            mc.replstore.delete_attachment_date(subjectGuid, name);
            if (callback) {
                callback();
            }
        }

        function error(tx, e) {
            tx = undefined;
            if (callback) {
                callback(e);
            }
        }

        function success(tx, result) {
            tx = undefined;
            result = undefined;
            if (mc.fs.availableForAtts) {
                log.debug('deleteAttachment[fs data] ' + subjectGuid + ' ' + name);
                mc.fs.deleteAttachment(subjectGuid, name, complete, function(e) {
                    log.debug('unable to delete data from file system - code ' + e.code);
                    complete();
                });
            }
            else {
                complete();
            }
        }

        log.debug('deleteAttachment[db/fs] ' + subjectGuid + ' ' + name);
        subjectGuid = mc.db.getSubjectGuid(subjectGuid);
        sql = "DELETE FROM attachment WHERE subjectGuid=? AND name=?;";
        params = [subjectGuid, name];
        doTx('transaction', function(tx) {
            tx.executeSql(sql, params, success, error);
        });
    }

    /**
    * Delete the attachment with the supplied subject guid and name, using the given transaction
    *
    * @param transaction
    *					The ongoing transaction to use
    * @param subjectGuid
    *					String containing guid of subject to delete
    * @param	name
    *					String containing the name of the attachment
    * @param	callback
    *					optioanl function called when deletion has completed. 1st parameter is
    *					an error object, if it's undefined then no error occurred.
    */
    function deleteAttachmentInTransaction(transaction, subjectGuid, name, callback) {
        var params, sql;

        function success(tx, result) {
            mc.replstore.delete_attachment_date(subjectGuid, name);
            if (callback) {
                callback();
            }
        }

        function error(tx, e) {
            tx = undefined;
            if (callback) {
                callback(e);
            }
        }

        log.debug('deleteAttachmentInTransaction[db/fs] ' + subjectGuid + ' ' + name);
        subjectGuid = mc.db.getSubjectGuid(subjectGuid);
        sql = "DELETE FROM attachment WHERE subjectGuid=? AND name=?;";
        params = [subjectGuid, name];
        transaction.executeSql(sql, params, success, error);
    }

    /**
    * Delete an itempreviously saved with setJsonItem
    *
    * @param	name
    *					String containing name of item to delete
    */
    function deleteJsonItem(name) {
        delete localStorage[name];
    }

    /**
    * Delete the subject with the supplied guid. Ensure process integrity is
    * maintained.  Use the supplied transaction
    *
    * @param transaction
    *					Transaction object to use
    * @param subjectGuid
    *					String containing guid of subject or subject object to delete
    * @param	callback
    *					optioanl function called when deletion has completed. 1st parameter is
    *					an error object, if it's undefined then no error occurred.
    * @param	keepAttachments
    *					If set attachments won't be deleted
    *
    */
    function deleteSubjectInTransaction(transaction, subjectGuid, callback, keepAttachments) {
        mc.db.getSubjectInTransaction(transaction, subjectGuid, function(trx, subject, e) {
            var i, n, process, processName;
            trx = undefined;
            function deleted(e) {
                if (!e) {
                    if (!keepAttachments && mc.replstore !== undefined) {
                        mc.replstore.delete_attachment_date(subjectGuid);
                    }
                    if (process && process.version !== mc.db.getLatestProcessVersion(process.id)) {
                        if (process.subjectGuids === undefined || process.subjectGuids.length === 0) {
                            deleteProcess(processName);
                        }
                    }
                    if (callback) {
                        callback();
                    }
                    updateUsedProcessVersionsCookie(function() { });
                } else if (callback) {
                    callback(e);
                }
            }
            subjectGuid = mc.db.getSubjectGuid(subjectGuid);
            if (subject !== undefined && subject !== null) {
                processName = mc.db.makeProcessName({
                    'id': subject._meta.processId,
                    'version': subject._meta.processVersion
                });
                if (currentProcess !== undefined && currentProcess.name !== undefined && currentProcess.name === processName) {
                    process = currentProcess.value;
                } else {
                    process = mc.db.getProcess(processName);
                }
                if (process !== undefined) {
                    if (process.subjectGuids !== undefined) {
                        n = process.subjectGuids.length;
                        for (i = 0; i < n; i += 1) {
                            if (process.subjectGuids[i] === subjectGuid) {
                                process.subjectGuids.splice(i, 1);
                                if (process.currentSubjectGuid === subjectGuid) {
                                    delete process.currentSubjectGuid;
                                }
                                mc.db.setProcess(processName, process);
                                break;
                            }
                        }
                    }
                }
                mc.db._deleteSubjectInTransaction(transaction, subjectGuid, keepAttachments, deleted);
            } else {
                if (callback) {
                    callback(e);
                }
            }
        });
    }

    /**
    * Delete a field or element of a field matching the supplied data id & index
    * from the current subject and save the subject.
    *
    * @param did
    *					data id of value to delete
    * @param index
    *					optional index of element to delete
    */
    function deleteValue(did, index, callback) {
        var a;
        if (index !== undefined && index !== null) {
            if (index.constructor === String) {
                index = parseInt(index, 10);
            }
            a = currentSubject.value[did];
            if (a !== undefined && a !== null && a.constructor === Array) {
                a.splice(index, 1);
                currentSubject.value[did] = a;
            } else {
                delete currentSubject.value[did];
            }
        } else {
            delete currentSubject.value[did];
        }
        mc.db.setSubject(currentSubject.guid, currentSubject.value, false, callback);
    }

    /**
    * Evaluate the supplied summary formulas and save the respective values
    *
    * @param	map
    *					array of summary names in column order
    * @param	summaries
    *					Object containing name of the summary item & function to return value
    */
    function evaluateSummaryValues(map, summaries, callback) {
        var count, done, i, values;
        function cleanup() {
            if (done === count) {
                mc.db.setSubject(currentSubject.guid, currentSubject.value, true, callback, values);
            }
        }
        function evaluate(ordinal) {
            function success(result) {
                values[ordinal] = result;
                currentSubject.value._meta.summaries[map[ordinal]] = result;
                done += 1;
                cleanup();
            }
            function failure(e) {
                log.error('Exception: ' + e.name + '. ' + e.message);
                done += 1;
                cleanup();
            }
            window.make_formula(summaries[map[ordinal]]).execute(success, failure);
        }
        values = [];
        count = 1; // Prevent cleanup from prematurely calling callback
        done = 0;
        currentSubject.value._meta.summaries = {
            processid: currentSubject.value._meta.processId
        };
        if (map !== undefined && summaries !== undefined) {
            for (i = 0; i < map.length; i += 1) {
                if (map[i] && summaries.hasOwnProperty(map[i])) {
                    count += 1;
                    evaluate(i);
                }
            }
        }
        count -= 1; // OK to call callback now
        cleanup();
    }

    /**
    * Persist a field or element of a field matching the supplied data id & index
    * to the current subject.
    *
    * @param did
    *					data id of value to save
    * @param v
    *					value to save
    * @param index
    *					optional index of element to save
    * @param stamp
    *					optional boolean indicating whether a location stamp is required
    */
    function setValue(did, v, index, stamp, callback) {
        var newValue;             
        function createNewValue() {
            if (index !== undefined && index !== null) {
                if (index.constructor === String) {
                    index = parseInt(index, 10);
                }
                var a = currentSubject.value[did];
                if (a !== undefined && a !== null && a.constructor === Array) {
                    a[index] = v;
                } else {
                    a = [];
                    a[index] = v;
                }
                return a;
            } else {
                return v;
            }
        }        
        function addStamps() {
            var cachedPosition;
            if (stamp === true) {
                if (currentSubject.value._meta.positions === undefined) {
                    currentSubject.value._meta.positions = {};
                }
                cachedPosition = getCachedPosition();
                if (cachedPosition) {
                    currentSubject.value._meta.positions[did] = cachedPosition;
                } else {
                    delete currentSubject.value._meta.positions[did];
                }
            }
        }        
        function saveValue() {
            currentSubject.value[did] = newValue;
            addStamps();
            mc.db.setSubject(currentSubject.guid, currentSubject.value, false, callback);
        }        
        newValue = createNewValue();
        valueChanging(currentSubject.value, did, newValue, index, saveValue);
    }

    function ensureValue(did, index) {
        var v;
        if (currentSubject !== undefined && currentSubject.value !== undefined) {
            v = currentSubject.value[did];
            if (index !== undefined && index !== null) {
                if (v === undefined || v === null || v.constructor !== Array) {
                    v = [];
                }
                if (v.length <= index) {
                    mc.db.setValue(did, null, index);
                }
            } else if (!currentSubject.value.hasOwnProperty(did)) {
                mc.db.setValue(did, null);
            }
        }
    }

    /**
    * Retrieve a field or element of a field matching the supplied data id & index
    * from the current subject.
    *
    * @param did
    *					data id of value to retrieve
    * @param index
    *					optional index of element to retrieve
    *
    * @return	value of item with matching data id and index
    */
    function getValue(did, index) {
        var v;
        if (currentSubject !== undefined && currentSubject.value !== undefined) {
            v = currentSubject.value[did];
            if (index !== undefined && index !== null) {
                if (v !== undefined && v !== null && v.constructor === Array) {
                    v = v[index];
                } else {
                    v = undefined;
                }
            }
        }
        return v;
    }

    function getValueArrayLength(did) {
        var v;
        v = mc.db.getValue(did);
        if (v && v.constructor === Array) {
            return v.length;
        }
        return -1;
    }

    /**
    * Retrieve the current cached position
    *
    * @returns
    */
    function getCachedPosition() {
        var cachedPosition;
        cachedPosition = getJsonItem('cachedPosition');
        return cachedPosition;
    }

    function setCachedPosition(position) {
        setJsonItem('cachedPosition', position);
    }

    /**
    * Retrieve a named value for the document cookie
    *
    * @param	name
    *					String containing the name of the value to retrieve from the cookie
    *
    * @return	String containing the value corresponding to the supplied name,
    *					undefined if name not found
    */
    function getCookie(name) {
        var cookie, end, start;
        if (document.cookie !== undefined && document.cookie.length > 0) {
            start = document.cookie.indexOf(name + "=");
            if (start !== -1) {
                start += name.length + 1;
                end = document.cookie.indexOf(";", start);
                if (end === -1) {
                    end = document.cookie.length;
                }
                cookie = window.unescape(document.cookie.substring(start, end));
            }
        }
        return cookie;
    }

    /**
    * Retrieve the current process
    *
    * @return	current process
    */
    function getCurrentProcess() {
        if (currentProcess !== undefined) {
            return currentProcess.value;
        }
        return undefined;
    }

    /**
    * Retrieve the current subject object
    *
    * @return	current subject object
    */
    function getCurrentSubject() {
        return currentSubject.value;
    }

    /**
    * Retrieve the guid of the current subject
    *
    * @return	string containing the guid of the current subject
    */
    function getCurrentSubjectGuid() {
        var currentSubjectGuid;
        if (currentSubject !== undefined) {
            currentSubjectGuid = currentSubject.guid;
        }
        return currentSubjectGuid;
    }

    /**
    * Retrieve the error result from expanding the database
    *
    * @return	string containing the error text
    */
    function getExpansionError() {
        return expansionError;
    }

    /**
    * Retrieve the saved home process
    *
    * @return	home process object
    */
    function getHomeProcess() {
        var processName = mc.db.getJsonItem('HomeProcess');
        if (processName) {
            return mc.db.getJsonItem(processName);
        }
    }

    /**
    * Retrieve an array of objects containing the latest process names and objects
    *
    * @return	array of objects containing { name: processName, value: processObject }
    */
    function getLatestProcesses() {
        var id, latestProcesses, names, name, processes;
        latestProcesses = {};
        names = mc.db.getProcessNames();
        if (names !== undefined) {
            $.each(names, function(index, value) {
                var parts, id, version;
                index = undefined;
                parts = value.split(' ');
                id = parts[0];
                version = parts[1];
                if (latestProcesses[id] !== undefined && version !== undefined) {
                    if (compareVersions(latestProcesses[id], version) < 0) {
                        latestProcesses[id] = version;
                    }
                } else {
                    latestProcesses[id] = version;
                }
            });
        }
        processes = [];
        for (id in latestProcesses) {
            if (latestProcesses.hasOwnProperty(id)) {
                if (latestProcesses[id] !== undefined) {
                    name = mc.db.makeProcessName({ 'id': id, 'version': latestProcesses[id] });
                    processes.push({ 'name': name, 'value': mc.db.getProcess(name) });
                }
            }
        }
        return processes;
    }
    
     /**
    * Retrieve an array of objects containing old process names and objects
    *
    * @return	array of objects containing { name: processName, value: processObject }
    */
    function getOldProcesses() {
        var id, latestProcesses, oldProcessNames, oldProcessName, names, name, processes;
        latestProcesses = {};
        oldProcessNames = [];
        names = mc.db.getProcessNames();
        if (names !== undefined) {
            $.each(names, function(index, value) {
                var parts, id, version;
                index = undefined;
                parts = value.split(' ');
                id = parts[0];
                version = parts[1];
                if (latestProcesses[id] !== undefined && version !== undefined) {
                    if (compareVersions(latestProcesses[id], version) < 0) {
                        oldProcessName = mc.db.makeProcessName({id: id, version: latestProcesses[id]});
                        oldProcessNames.push(oldProcessName);
                        latestProcesses[id] = version;
                    } else {
                        oldProcessNames.push(value);
                    }
                } else {
                    latestProcesses[id] = version;
                }
            });
        }
        processes = [];
        $.each(oldProcessNames, function(index, oldProcessName) {
            log.info('found old process: ' + oldProcessName);
            processes.push({ name: oldProcessName, value: mc.db.getProcess(oldProcessName) });
        });
        return processes;
    }

    /**
    * Retrieve a value from the _meta object of the current subject.
    *
    * @param name
    *					name of value to retrieve
    *
    * @return	value of item with matching name
    */
    function getMetaValue(name) {
        var value;
        try {
            value = currentSubject.value._meta[name];
        } catch (e) {
            value = undefined;
        }
        return value;
    }

    /**
    * Retrieve the process information array
    *
    * @return	process information array
    */
    function getProcesses() {
        var i, n, process, processes, processNames;
        processNames = mc.db.getProcessNames();
        processes = [];
        if (processNames !== undefined) {
            n = processNames.length;
            for (i = 0; i < n; i += 1) {
                process = mc.db.getProcess(processNames[i]);
                if (process !== undefined) {
                    processes.push({
                        name: processNames[i],
                        value: process
                    });
                }
            }
        }
        return processes;
    }
    /**
    * Retrieve the process information by its id
    *
    * @return	process information object
    */
    function getLatestProcessById(processId) {
        var i, n, process, processNames, version, processName;
        version = mc.db.getLatestProcessVersion(processId);
        processName = mc.db.makeProcessName({ id: processId, version: version });
        process = mc.db.getProcess(processName);
        return process;
    }

    /**
    * Retrieve the subject guids belonging to the supplied processId and
    * syncId
    *
    * @param processId
    *					String containing the processId to use on the query
    * @param syncId
    *					String containing the syncId to use in the query
    * @param callback
    *					function to receive the guid
    */
    function getSubjectGuidFromReplID(processId, syncId, callback) {
        if (callback && typeof callback === 'function') {
            if (db) {
                doTx('readTransaction', function(tx) {
                    var sql;
                    function success(tx, result) {
                        var guid;
                        tx = undefined;
                        if (result && result.rows && result.rows.length) {
                            guid = result.rows.item(0).guid;
                        }
                        callback(guid);
                    }
                    function error(tx, e) {
                        tx = undefined;
                        e = undefined;
                        callback('');
                    }
                    sql = 'SELECT guid FROM subject WHERE backupGuid IS NULL AND lower(processId) = lower(?) AND serverId = ? ORDER BY processVersion DESC';
                    tx.executeSql(sql, [processId, syncId], success, error);
                }, function() { callback(''); });
            } else {
                callback('');
            }
        }
    }

    /**
    * Retrieve the supplied summaries for all the subjects belonging to the
    * supplied processId and process version
    *
    * @param processId
    *					Array of Strings or String containing the processId to use on the query
    * @param processVerions
    *					optional Array of Strings or String containing the processVersion to use
    *					in the query
    * @param	summaryNames
    *					Array of summary names to resolve into column ordinals
    * @param callback
    *					function to receive the array of guids
    */
    function getSubjectSummaries(processId, processVersion, summaryNames, filter, callback) {
        var i, order, orderCount, process, processName, recurse, v, where;
        function complete(a) {
            recurse.result = recurse.result.concat(a);
            recurse.count -= 1;
            if (recurse.count <= 0) {
                // sort results on the summaryNames until we build this into the idb index
                recurse.result.sort(function(a, b) {
                    for (i = 0; i < summaryNames.length; i++) {
                        if (a[summaryNames[i]] === null) return -1;
                        if (b[summaryNames[i]] === null) return 1;
                        if (a[summaryNames[i]].toLowerCase() > b[summaryNames[i]].toLowerCase()) return 1;
                        if (a[summaryNames[i]].toLowerCase() < b[summaryNames[i]].toLowerCase()) return -1;
                    }
                    return 0;
                });
                callback(recurse.result);
            }
        }
        if (callback && typeof callback === 'function') {
            if (db) {
                if (!processId) {
                    processId = mc.db.getCurrentProcess().id;
                }
                if (processId.constructor === Array) {
                    if (!processVersion || processVersion.constructor !== Array) {
                        processVersion = [];
                    }
                    recurse = {};
                    recurse.count = processId.length;
                    recurse.result = [];
                    for (i = 0; i < processId.length; i += 1) {
                        mc.db.getSubjectSummaries(processId[i], processVersion[i], summaryNames, filter, complete);
                    }
                    return;
                }
                processName = mc.db.makeProcessName({ id: processId, version: processVersion || mc.db.getLatestProcessVersion(processId) });
                process = mc.db.getProcess(processName);
                if (process && process.summaryMap && process.summaryMap.length) {
                    doTx('readTransaction', function(tx) {
                        var i, index, p, params, sql;
                        function success(tx, result) {
                            var a, c, i, o, prop, row;
                            tx = undefined;
                            a = [];
                            if (result && result.rows && result.rows.length) {
                                for (i = 0; i < result.rows.length; i += 1) {
                                    o = {};
                                    row = result.rows.item(i);
                                    o.guid = row.guid;
                                    o.processId = processId;
                                    for (prop in row) {
                                        if (prop.indexOf('col') === 0 && row.hasOwnProperty(prop)) {
                                            c = parseInt(prop.slice(3), 10);
                                            if (row[prop] === null) {
                                                o[process.summaryMap[c]] = "undefined - please fix your summary item formula";
                                            } else {
                                                o[process.summaryMap[c]] = row[prop];
                                            }
                                        }
                                    }
                                    a.push(o);
                                }
                                if (recurse === undefined) {
                                    // sort results on the summaryNames until we build this into the idb index
                                    a.sort(function(a, b) {
                                        for (i = 0; i < summaryNames.length; i++) {
                                            if (a[summaryNames[i]] === null) return -1;
                                            if (b[summaryNames[i]] === null) return 1;
                                            if (a[summaryNames[i]].toLowerCase() > b[summaryNames[i]].toLowerCase()) return 1;
                                            if (a[summaryNames[i]].toLowerCase() < b[summaryNames[i]].toLowerCase()) return -1;
                                        }
                                        return 0;
                                    });
                                }
                                
                            }
                            callback(a);
                        }
                        function error(tx, e) {
                            tx = undefined;
                            e = undefined;
                            callback([]);
                        }
                        params = [];
                        sql = 'SELECT guid';
                        where = '';
                        order = ' ORDER BY ';
                        orderCount = 0;
                        if (summaryNames !== undefined) {
                            for (i = 0; i < summaryNames.length; i += 1) {
                                index = process.summaryMap.indexOf(summaryNames[i]);
                                if (index >= 0) {
                                    sql += ',col' + index;
                                    if (orderCount < 3) {
                                        if (orderCount > 0) {
                                            order += ',';
                                        }
                                        order += 'col' + index;
                                        orderCount += 1;
                                    }
                                }
                            }
                        }
                        sql += ' FROM subject WHERE backupGuid IS NULL AND processId=?';
                        params.push(processId);
                        if (processVersion) {
                            sql += ' AND processVersion=?';
                            params.push(processVersion);
                        }
						
						// example filter - isHidden summary == 'yes' : { isHidden : "yes" } 
                        for (p in filter) {
                            if (filter.hasOwnProperty(p)) {
                                index = process.summaryMap.indexOf(p);
                                if (index >= 0) {
									////this does not work yet - 
									//// attempt to get the Answer from the current subject
									//// to the DATAID specified on the filter (in the case 
									//// of the example above this would be the dataid 'yes')
                                    //v = mc.db.getValue(filter[p]);
                                    //if (v !== undefined && v !== null && v !== '') {
                                    //}
									
                                        where += ' AND col' + index + '=?';
                                    params.push(filter[p]);
                                    }
                                }
                            }
                        sql += where;
                        if (orderCount) {
                            sql += order;
                        }
                        tx.executeSql(sql, params, success, error);
                    }, function() { callback([]); });
                } else {
                    callback([]);
                }
            } else {
                callback([]);
            }
        }
    }

    /**
    * Retrieve a named summary value from the subject with the supplied guid
    *
    * @param callback
    *					function to receive the summary value if found, otherwise undefined
    * @param	guid
    *					String containing guid of the subject or subject object
    * @param	name
    *					String containing the name of the summary value to retrieve
    * @param callback
    *					function called when the summary value has been retrieved. 1st param
    *					is value or undefined if not found
    */
    function getSummaryValue(guid, name, callback) {
        function gotSubject(subject) {
            var value;
            if (subject && subject._meta && subject._meta.summaries) {
                value = subject._meta.summaries[name];
            }
            if (value === undefined || value === null) {
                value = '';
            }
            callback(value);
        }
        mc.db.getSubject(guid, gotSubject);
    }

    /**
    * Retrieve many named summary values from the subject with the supplied guid
    *
    * @param callback
    *					function to receive the summary values
    * @param	guid
    *					String containing guid of the subject to get a summary value from
    * @param
    *					All further parameters are Strings containing the name of the summary
    *					value to retrieve
    */
    function getSummaryValues(callback, guid) {
        var i, names;
        function gotSubject(subject) {
            var i, values;
            values = [];
            if (subject && subject._meta && subject._meta.summaries) {
                for (i = 0; i < names.length; i += 1) {
                    values.push(subject._meta.summaries[names[i]]);
                }
            }
            callback.apply(window, values);
        }
        names = [];
        for (i = 2; i < arguments.length; i += 1) {
            names[i - 2] = arguments[i];
        }
        mc.db.getSubject(guid, gotSubject);
    }

    /**
    * Retrieve the saved user info object
    *
    * @return	saved user object
    */
    function getUserInfo() {
        return mc.db.getJsonItem('mSuiteUser') || { mSuiteUserName: '', mSuiteSerialNo: '0' };
    }

    /**
    * Determine whether the supplied process id is deployed or not
    *
    * @param processId
    *					String containing the process id to check the deployment flag
    */
    function isProcessDeployed(processId) {
        var deployed, i, n, processes;
        deployed = false;
        if (sessionStorage.deployedProcesses !== undefined) {
            processes = JSON.parse(sessionStorage.deployedProcesses);
            if (processes.constructor === Array) {
                n = processes.length;
                for (i = 0; i < n; i += 1) {
                    if (processId === processes[i]) {
                        deployed = true;
                        break;
                    }
                }
            }
        }
        return deployed;
    }

    /**
    * Determine whether any installed process version matching the supplied
    * process id has any existing subjects
    *
    * @param	processId
    *					String containing the process id to check
    *
    * @return	true if there are existing subjects for the supplied process id,
    *					false otherwise
    */
    function isProcessInUse(processId) {
        var inUse, usedProcesses;
        inUse = false;
        usedProcesses = mc.db.getCookie('usedProcessVersions');
        if (usedProcesses !== undefined) {
            usedProcesses = JSON.parse(usedProcesses);
            if (usedProcesses && usedProcesses[processId] !== undefined) {
                inUse = true;
            }
        }
        return inUse;
    }

    /**
    * Determine whether the geo location is required for the supplied process
    *
    * @param processInfo
    *					Object containing information of process
    *
    * @return	true if location is required
    *					false otherwise
    */
    function locationRequired(processInfo) {
        var b, i, q, p, processes; ;
        b = false;
        if (processInfo !== undefined) {
            if (processInfo.locationRequired === true) {
                b = true;
            } else if (processInfo.questions !== undefined) {
                for (q in processInfo.questions) {
                    if (processInfo.questions.hasOwnProperty(q) && ((processInfo.questions[q].stamps === true) || (processInfo.questions[q].myLocationRequired === true))) {
                        b = true;
                        break;
                    }
                }
            }
        }
        if (!b) {
            // if this is the home process and any other installed process requires position watch then b = true
            if (processInfo.home === true) {
                processes = getProcesses();
                if (processes && processes.length) {
                    for (i = 0; i < processes.length; i += 1) {
                        p = processes[i].value;
                        if (p && p.home !== true && locationRequired(p)) {
                            b = true;
                            break;
                        }
                    }
                }
            }
        }
        return b;
    }

    /**
    * Stop the current geolocation watch
    */
    function positionClearWatch() {
        if (navigator.geolocation && positionWatchId) {
            navigator.geolocation.clearWatch(positionWatchId);
            positionWatchId = undefined;
        }
    }

    /**
    * Start a new geolocation watch
    */
    function positionWatch() {
        var positionOptions, positionWatchIdLow, positionWatchIdHigh, positionWatchTimeout = 10000, positionWatchAge = 60000, positionWatchLowTried = false;
        function clearWatchLow() {
            if (positionWatchIdLow) {
                navigator.geolocation.clearWatch(positionWatchIdLow);
            }
        }
        function clearWatchHigh() {
            if (positionWatchIdHigh) {
                navigator.geolocation.clearWatch(positionWatchIdHigh);
            }
        }
        function getPositionHigh() {
            if (navigator.geolocation) {
                positionOptions = {};
                positionOptions.enableHighAccuracy = true;
                positionOptions.maximumAge = positionWatchAge;
                positionOptions.timeout = positionWatchTimeout;
                positionWatchIdHigh = navigator.geolocation.watchPosition(positionUpdate, positionError_high, positionOptions);
            }
        }
        function getPositionLow() {
            positionWatchLowTried = true;
            positionOptions = {};
            positionOptions.enableHighAccuracy = false;
            positionOptions.maximumAge = positionWatchAge;
            positionOptions.timeout = positionWatchTimeout;
            positionWatchIdLow = navigator.geolocation.watchPosition(positionUpdate, positionError_low, positionOptions);
        }
        function logPositionError(error) {
            var msg = "Failed to get GPS: " + error.message + " - ";
            if (error.code == 1)
                msg += "PERMISSION_DENIED";
            else if (error.code == 2)
                msg += "POSITION_UNAVAILABLE";
            else if (error.code == 3)
                msg += "TIMEOUT";

            log.error(msg);
        }
        var positionError_high = function(error) {
            logPositionError(error);
            if (error.code == error.TIMEOUT) {
                if (!positionWatchLowTried) {
                    log.info("Failed to receive high accuracy GPS within the timeout period.  Will try low accuracy");
                    getPositionLow();
                } else {
                    if (positionWatchTimeout < positionWatchAge) {
                        log.info("Failed to receive high accuracy GPS within the timeout period.  Will try higher timeout");
                        clearWatchHigh();
                        positionWatchTimeout = positionWatchTimeout + 10000;
                        getPositionHigh();
        }
                }
            } else {
                clearWatchHigh();
            }
        }
        var positionError_low = function(error) {
            clearWatchLow();
            logPositionError(error);
            if (error.code == error.TIMEOUT) {
                log.info("Failed to receive low accuracy GPS within the timeout perid.  Will try high accuracy");
                getPositionHigh();
            }
        }
        var positionUpdate = function (position) {
            var logEnabled = false, // Disabled logging to reduce logfile access
                cachedPosition;

            logEnabled && log.info("Caching new GPS position");

            //geolocation object will not get converted to a string with JSON.stringify because of the attributes
            //All platforms now implement the same as FF and Safari so we need to close into plain JavaScript
            //if ($.isIE) {
                // The IDB layer throws when it tries to clone position so we have tomanually clone it here
                cachedPosition = {
                    coords: {
                        accuracy: position.coords.accuracy,
                        altitude: position.coords.altitude,
                        altitudeAccuracy: position.coords.altitudeAccuracy,
                        heading: position.coords.heading,
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        speed: position.coords.speed
                    },
                    timestamp: position.timestamp
                };
            //} else {
            //    cachedPosition = position;
            //}
            if (cachedPosition !== undefined) {
                if (cachedPosition.coords !== undefined) {
                    if (cachedPosition.coords.latitude !== undefined) {
                        setCachedPosition(cachedPosition);
                        logEnabled && log.info("Cached location Lat:" + cachedPosition.coords.latitude + "Long:" + cachedPosition.coords.longitude)
                    } else {
                        logEnabled && log.info("new GPS latitude is undefined");
                    }
                } else {
                    logEnabled && log.info("new GPS coord is undefined");
                }
            } else {
                logEnabled && log.info("new GPS position is undefined");
            }
        }
        navigator.geolocation.getCurrentPosition(positionUpdate);
        getPositionHigh();
    }

    /**
    *
    */
    function querySummaries(processId, summaryNames, conditions, distinct, sort, limit, offset, callback) {
        var o, processName, process;
        o = {};
        o.id = processId;
        o.version = '';
        o.version += mc.db.getLatestProcessVersion(processId);
        processName = mc.db.makeProcessName(o);
        process = mc.db.getProcess(processName);
        if (callback && callback.constructor === Function) {
            if (process && db) {
                doTx('readTransaction', function(tx) {
                    var i, sql, params;
                    function success(tx, result) {
                        var a, c, i, j, o, r;
                        tx = undefined;
                        a = [];
                        if (result && result.rows) {
                            for (i = 0; i < result.rows.length; i += 1) {
                                r = result.rows.item(i);
                                o = { guid: r.guid };
                                for (j = 0; j < summaryNames.length; j += 1) {
                                    c = "col" + process.summaryMap.indexOf(summaryNames[j]);
                                    o[summaryNames[j]] = r[c];
                                }
                                a.push(o);
                            }
                        }
                        callback(a);
                    }
                    function error(tx, e) {
                        tx = undefined;
                        log.error('Exception in mc.db.querySummaries: ' + e.name + '. ' + e.message);
                        callback([]);
                    }
                    sql = "SELECT";
                    params = [];
                    if (distinct) {
                        sql += " DISTINCT";
                    }
                    sql += " guid";
                    for (i = 0; i < summaryNames.length; i += 1) {
                        sql += ", col" + process.summaryMap.indexOf(summaryNames[i]);
                    }
                    sql += " FROM subject WHERE backupGuid IS NULL AND processId = ?";
                    params.push(processId);
                    for (i = 0; i < conditions.length; i += 1) {
                        sql += " AND ";
                        switch (conditions[i].condition) {
                            case 'begins':
                                sql += "col" + process.summaryMap.indexOf(conditions[i].summaryName) + " LIKE ?";
                                params.push(conditions[i].value + "%");
                                break;
                            case 'ends':
                                sql += "col" + process.summaryMap.indexOf(conditions[i].summaryName) + " LIKE ?";
                                params.push("%" + conditions[i].value);
                                break;
                            case 'contains':
                                sql += "col" + process.summaryMap.indexOf(conditions[i].summaryName) + " LIKE ?";
                                params.push("%" + conditions[i].value + "%");
                                break;
                            default:
                                sql += "col" + process.summaryMap.indexOf(conditions[i].summaryName) + " = '" + conditions[i].value + "'";
                                break;
                        }
                    }
                    if (sort) {
                        if (sort.column) {
                            sql += " ORDER BY col" + process.summaryMap.indexOf(sort.column);
                            if (sort.order) {
                                sql += " " + sort.order;
                            }
                        }
                    }
                    sql += " LIMIT " + limit + " OFFSET " + offset;
                    tx.executeSql(sql, params, success, error);
                }, function() {
                    log.error('DB Transaction failed in mc.db.querySummaries');
                    callback([]);
                });
            } else if (process) {
                log.error('Database was not set up: mc.db.querySummaries');
                callback([]);
            } else {
                log.error('Process was not set up: mc.db.querySummaries');
                callback([]);
            }
        } else {
            log.error('Was not provided with a valid callback: mc.db.querySummaries');
            callback([]);
        }
    }

    /**
    *
    */
    function queryXmlSummaries(processId, xmlName, summaryNames, conditions, limit, offset, callback) {
        function dbCallback(results) {
            var a, doc, end, i, j, name, node, nodes, o, op, q, row, start, data, attrib, ATTRIB, search, realCaseConditionList, attribIndex, firstRow, realCaseSummaryNames, realCaseCond;
            a = [];
            
            for (row = 0; row < results.length; row += 1) {
                //create a XML DOM tree with the results xml
                doc = (new window.DOMParser()).parseFromString("<data>" + results[row][xmlName] + "</data>", "text/xml");
                
                if (!realCaseConditionList) {                    
                    //find a list of attributes/summary names to match on.
                    // the list comes from conditions, but we need to match 
                    // the case from the xml in results
                    
                    realCaseConditionList = [];
                    realCaseSummaryNames = [];
                    
                    firstRow = doc.getElementsByTagName("row")[0];
                    for (attribIndex=0; attribIndex < firstRow.attributes.length; ++attribIndex) { 
                        for (i = 0; i < conditions.length; i += 1) {
                            if (conditions[i].summaryName.toLowerCase() == firstRow.attributes[attribIndex].name.toLowerCase()) {
                                realCaseCond = {
                                    summaryName: firstRow.attributes[attribIndex].name,
                                    condition: conditions[i].condition,
                                    value: conditions[i].value
                                    };
                                
                                realCaseConditionList.push(realCaseCond);
                            }
                        }
                        
                        // build the list of output summary names
                        for (i = 0; i < summaryNames.length; i += 1) {
                            if (summaryNames[i].toLowerCase() == firstRow.attributes[attribIndex].name.toLowerCase()) {
                                realCaseSummaryNames.push(firstRow.attributes[attribIndex].name);
                            }
                        }

                    }
                }
            
                //now use jQuery to walk the DOM using a custom filter to do the
                // case insensative matching
                jQuery(doc).find('row').each(function() { 
                    //return true if we have a match
                    var rowTag, attrIdx, thisAttrib, condIdx, resultObj, resultIdx, isMatch, attribLower, valueLower;
                    
                    rowTag = this;
                    
                    for (condIdx = 0; condIdx < realCaseConditionList.length; condIdx += 1) {
                        //get the attrib for this condition
                        thisAttrib = rowTag.attributes[realCaseConditionList[condIdx].summaryName];
                        if (thisAttrib) {
                            attribLower = thisAttrib.value.toLowerCase();
                            isMatch = false;
                            valueLower = realCaseConditionList[condIdx].value.toLowerCase();
                            
                            switch (realCaseConditionList[condIdx].condition) {
                                case 'begins':
                                    if (valueLower == attribLower.substr(0,valueLower.length)) {
                                        //we have a match
                                        isMatch = true;
                                    }
                                    break;
                                case 'ends':
                                    if ((attribLower.length - valueLower.length) == attribLower.lastIndexOf(valueLower)) {
                                        //we have a match
                                        isMatch = true;
                                    }
                                    break;
                                case 'contains':
                                    if (-1 != attribLower.indexOf(valueLower)) {
                                        //we have a match
                                        isMatch = true;
                                    }
                                    break;
                                default:
                                    if (attribLower == valueLower) {
                                        //we have a match
                                        isMatch = true;
                                    }
                                    break;
                            }

                            if (isMatch) {
                                //create the result object for this match
                                resultObj = {};
                                
                                for (resultIdx = 0; resultIdx< realCaseSummaryNames.length; ++resultIdx) {
                                    resultObj[realCaseSummaryNames[resultIdx]] = rowTag.attributes[realCaseSummaryNames[resultIdx]].value;
                                }
                                
                                // push onto results list
                                a.push(resultObj);
                                return;// true;
                            }
                        }
                    }
                });
            }
            callback(a);
        }
        mc.db.querySummaries(processId, [xmlName], [], false, undefined, -1, 0, dbCallback);
    }

    /**
    *
    */
    function querySummaryData(processId, summaryItemName, filters, distinct, separator, callback) {
        var colName, o, processName, processObj;
        o = {};
        o.id = processId;
        o.version = '';
        o.version += mc.db.getLatestProcessVersion(processId);
        processName = mc.db.makeProcessName(o);
        processObj = mc.db.getProcess(processName);

        if (callback && typeof callback === 'function') {
            if (processObj && db) {
                colName = 'col' + processObj.summaryMap.indexOf(summaryItemName);
                doTx('readTransaction', function(tx) {
                    var params, sql;
                    function success(tx, result) {
                        var arr, i, item;
                        tx = undefined;
                        arr = [];
                        if (result && result.rows && result.rows.length) {
                            for (i = 0; i < result.rows.length; i += 1) {
                                item = result.rows.item(i)[colName];
                                if (item !== null) {
                                    arr.push(result.rows.item(i)[colName]);
                                }
                            }
                        }
                        callback(arr);
                    }
                    function error(tx, e) {
                        tx = undefined;
                        log.error('Exception in mc.db.querySummaryData: ' + e.name + '. ' + e.message);
                        callback([]);
                    }

                    params = [];
                    if (distinct) {
                        sql = 'SELECT DISTINCT(' + colName + ') FROM subject WHERE backupGuid IS NULL AND processId = ?';
                    } else {
                        sql = 'SELECT ' + colName + ' FROM subject WHERE backupGuid IS NULL AND processId = ?';
                    }
                    params.push(processId);
                    $.each(filters, function(index, item) {
                        if (index % 2 === 0) {
                            sql += ' AND ' + 'col' + processObj.summaryMap.indexOf(item);
                        } else {
                            if (separator !== undefined && separator.length === 1) {
                                sql += ' LIKE ?';
                                params.push('%' + separator + item);
                            } else {
                                sql += ' = ?';
                                params.push(item);
                            }
                        }
                    });
                    tx.executeSql(sql, params, success, error);
                }, function() {
                    log.error('DB Transaction failed in mc.db.querySummaryData');
                    callback([]);
                });
            } else if (processObj) {
                log.error('Database was not set up: mc.db.querySummaryData');
                callback([]);
            } else {
                log.error('Process was not set up: mc.db.querySummaryData');
                callback([]);
            }
        } else {
            log.error('Was not provided with a valid callback: mc.db.querySummaryData');
            callback([]);
        }
    }

    /**
    * Library initialization entry point
    *
    * @param processInfo
    *					Object containing information of process to open/create. Must contain at
    *					least id & version. Can optionally contain title, hidden & pages
    */
    function ready(visualizing, processInfo, callback) {
        function success() {
            var subjectGuid;
            function gotSubject(subject) {
                currentSubject = subject;
                if (currentProcess.value.currentSubjectGuid !== currentSubject.guid) {
                    currentProcess.value.currentSubjectGuid = currentSubject.guid;
                    mc.db.setProcess(currentProcess.name, currentProcess.value);
                }
                if (processInfo.home === true) {
                    mc.db.setJsonItem('HomeProcess', currentProcess.name);
                }
                if (locationRequired(processInfo)) {
                    positionWatch();
                }
                if (processInfo.revertable) {
                    mc.db.backupCurrentSubject(function(backup) {
                        backup = undefined;
                        callback();
                    });
                } else {
                    callback();
                }
            }
			if (!processInfo) {
				return callback();
			}
            mc.db.createProcess(processInfo, function(process) {
                function gotSubjectGuid(subjectGuid) {
                    mc.db.createSubject(processInfo.id, processInfo.version, subjectGuid, gotSubject);
                }
                currentProcess = process;
                if (visualizing) {
                    subjectGuid = currentProcess.value.visualizationSubjectGuid;
                    gotSubjectGuid(subjectGuid);
                } else {
                    subjectGuid = currentProcess.value.currentSubjectGuid;
                    if (!subjectGuid && currentProcess.value.singleSubject) {
                        mc.db.getSubjectGuids(processInfo.id, processInfo.version, function(guids) {
                            if (guids && guids.length) {
                                subjectGuid = guids[0];
                            }
                            gotSubjectGuid(subjectGuid);
                        });
                    } else {
                        gotSubjectGuid(subjectGuid);
                    }
                }
                //mc.db.createSubject(processInfo.id, processInfo.version, subjectGuid, gotSubject);
            });
        }
        function error(e) {
            log.error(e.message);
            callback(e);
        }
        mc.db.createDb(success, error);
    }

    /**
    * Restore the current subject to the state of backupSubject
    *
    * @param	callback
    *					function called back when subject has been restored. 1st parameter is
    *					object containing the restored subject
    */
    function restoreCurrentSubject(callback) {
        if (backupSubject) {
            mc.db.cloneSubject(backupSubject, true, function(subject) {
                currentSubject = {
                    value: subject,
                    guid: subject._meta.guid
                };
                callback(currentSubject.value);
            }, currentSubject.guid);
        } else {
            callback();
        }
    }

    /**
    * Save the supplied attachment with the supplied subject guid and name
    *
    * @param	transaction
    *					transaction object
    * @param	subjectGuid
    *					string containing unique guid of subject
    * @param	name
    *					name of attachment - must be unique for this subject
    * @param data
    *					data of attachment to save
    * @param callback
    *					optional function called on completion. 1st parameter is error object,
    *					if error object is undefined then the operation succeeded
    */
    function setAttachmentInTransaction(transaction, subjectGuid, name, data, markChanged, callback) {
        var params, sql;

        function success(tx, r) {
            tx = undefined;
            r = undefined;
            if (markChanged) {
                mc.replstore.store_attachment_date(subjectGuid, name, new Date());
            }
            if (callback) {
                callback();
            }
        }
        function error(tx, e) {
            tx = undefined;
            if (callback) {
                callback(e);
            }
        }

        function update(tx) {
            sql = 'UPDATE attachment SET data=? WHERE subjectGuid=? AND name=?';
            params = [data, subjectGuid, name];
            tx.executeSql(sql, params, success, error);
        }
        sql = 'INSERT INTO attachment (subjectGuid,name,data) VALUES(?,?,?)';
        params = [mc.db.getSubjectGuid(subjectGuid), name, data];
        transaction.executeSql(sql, params, function(tx, result) {
            if (result && result.rowsAffected === 1) {
                success(tx, result);
            } else {
                update(tx);
            }
        }, update);
    }

    /**
    * Persist a named value inside the _meta object of the current subject.
    *
    * @param name
    *					String containing the name of the property to set
    * @param value
    *					any type containing the value to save
    */
    function setMetaValue(name, value, noTouch, callback) {
        if (currentSubject) {
            if (!currentSubject.value._meta) {
                currentSubject.value._meta = { guid: currentSubject.guid };
            }
            if (currentSubject.value._meta[name] !== value) {
                currentSubject.value._meta[name] = value;
                if (noTouch === undefined) {
                    noTouch = true;
                }
                mc.db.setSubject(currentSubject.guid, currentSubject.value, noTouch, callback);
            } else {
                if (callback) {
                    callback();
                }
            }
        } else {
            if (callback) {
                callback(noCurrentSubject);
            }
        }
    }

    /**
    * Save the user info object
    *
    * @param user
    *					user info object
    */
    function setUserInfo(user) {
        mc.db.setJsonItem('mSuiteUser', user);
    }

    function startTransaction(callback, completed_callback) {
        function error(e) {
            log.error("Transaction Failed: " + e.code + ": " + e.message);
        }
        function success(tx) {
            log.debug("Transaction completed OK");
            completed_callback(tx);
        }
        doTx('transaction', function(transaction) {
            log.debug("Starting Transaction");
            callback(transaction);
        }, error, success);
    }

    /**
    * Query summaries in a compressed or uncompressed dataset
    *
    * @param processId
    * @param options object
    *			filters - an optional array of filters: ([{summaryName: 'x', summaryValue: 'y'},{...}])
    *			conditions - an optional array of conditions: ([{condition: 'contains', summaryName: 'x', value: 'y'},{...}])
    *		    summaryName - optional string: show only summaries that match this summaryName
    *			summaryNames - optional array: show only summaries that match one of these summaryNames
    *			unique/distinct - optional boolean, show only unique entries (non-compessed only atm)
    *			choices - optional boolean: provide results in the form expected by dynamic choices
    * @param callback
    *
    */
    function summaryQuery(processId, options, callback) {
        var proc,
    	compressed,
    	sql,
    	separator;

        function makeChoices(result) {
            var summaryNames = options.summaryNames;
            if (typeof summaryNames == 'string' || summaryNames instanceof String) {
                summaryNames = [summaryNames];
            }
            if (options.summaryName) {
                summaryNames = [options.summaryName];
            }

            var choicedResults = [];
            $.each(result, function(index, item) {
                var summaryValueLabel,
    			summaryValueValue,
    			choiceText;
                choiceText = item[summaryNames[0]];
                summaryValueLabel = choiceText;
                summaryValueValue = choiceText;
                if (separator !== undefined && separator.length > 0 && choiceText.indexOf(separator) >= 0 && choiceText.indexOf(separator) < choiceText.length) {
                    summaryValueLabel = choiceText.substring(0, choiceText.indexOf(separator));
                    summaryValueValue = choiceText.substring(1 + choiceText.indexOf(separator));
                }
                choicedResults.push({
                    label: summaryValueLabel,
                    value: summaryValueValue
                });
            });

            return choicedResults;
        }

        function decompressXML(xmlRaw) {
            var xml = '<xml>' + xmlRaw + '</xml>';
            var x2js = new X2JS();
            var jsonObj = x2js.xml_str2json(xml);
            // console.dir(jsonObj);

            var summaryNames = options.summaryNames;
            var sortCol, sortSeq;
            
            if (typeof summaryNames == 'string' || summaryNames instanceof String) {
                summaryNames = [summaryNames];
            }
            if (options.summaryName) {
                summaryNames = [options.summaryName];
            }

            var result = [];

            $.each(jsonObj.xml.row, function(index, row) {

                function strStartsWith(str, prefix) {
                    return str.indexOf(prefix) === 0;
                }

                function strEndsWith(str, suffix) {
                    return str.match(suffix + "$") == suffix;
                }

                function strContains(str, contained) {
                    return str.indexOf(contained) >= 0;
                }

                var filteredOut = false;

                if (options && options.filters && (typeof options.filters == 'array' || options.filters instanceof Array)) {
                    $.each(options.filters, function(index, filter) {
                        if (typeof filter.summaryValue == 'array' || filter.summaryValue instanceof Array) {
                            if (row['_' + filter.summaryName] !== filter.summaryValue[0]) {
                                filteredOut = true;
                            }
                        } else if (row['_' + filter.summaryName] !== filter.summaryValue) {
                            filteredOut = true;
                        }
                    });
                }

                if (options && options.conditions && (typeof options.conditions == 'array' || options.conditions instanceof Array)) {
                    $.each(options.conditions, function(key, condition) {
                        switch (condition.condition) {
                            case 'begins':
                                {
                                    if (!strStartsWith(row['_' + condition.summaryName], condition.value))
                                        filteredOut = true;
                                    break;
                                }
                            case 'ends':
                                {
                                    if (!strEndsWith(row['_' + condition.summaryName], condition.value))
                                        filteredOut = true;
                                    break;
                                }
                            case 'contains':
                                {
                                    if (!strContains(row['_' + condition.summaryName], condition.value))
                                        filteredOut = true;
                                    break;
                                }
                            default:
                                {
                                    if (row['_' + condition.summaryName] !== condition.value)
                                        filteredOut = true;
                                    break;
                                }
                        }
                    });
                }

                if (filteredOut)
                    return true; // continue

                var dataRow = {};
                if (!options || !options.summaryNames) {
                    $.each(row, function(key, summaryVal) {
                        dataRow[key.substring(1)] = summaryVal;
                    });
                } else if (typeof options.summaryNames == 'string' || options.summaryNames instanceof String) {
                    dataRow[options.summaryNames] = row['_' + options.summaryNames];
                } else if (typeof options.summaryNames == 'array' || options.summaryNames instanceof Array) {
                    $.each(options.summaryNames, function(idx, summaryName) {
                        dataRow[summaryName] = row['_' + summaryName];
                    });
                } else {
                    console.error('summaryNames option not valid');
                }
                var found = false;
                if (options.unique || options.distinct) {
                    $.each(result, function(index, res) {
                        var match = true;
                        $.each(summaryNames, function(idx, summName) {
                            if (dataRow[summName] !== res[summName])
                                match = false;
                        });
                        if (match)
                            found = true;
                    });
                }
                if (!found)
                    result.push(dataRow);
            });

            if (options.sort) {
                if (options.sort.column) {
                    sortCol = proc.summaryMap.indexOf(options.sort.column);
                    if (sortCol > -1) {
											sortCol = options.sort.column;
											if (options.sort.order) {
												sortSeq = options.sort.order.toLowerCase();
											} else {
												sortSeq = 'asc';
											}
											// sort results on the summaryName
											result.sort(function(a, b) {
	                      var va,vb;
	                      va=a[sortCol];
	                      vb=b[sortCol];
												if (va === null) return (sortSeq == 'desc' ? 1 : -1);
												if (vb === null) return (sortSeq == 'desc' ? -1 : 1);
												va=va.toLowerCase();
	                      vb=vb.toLowerCase();
												if (va > vb) return (sortSeq == 'desc' ? -1 : 1);
												if (va < vb) return (sortSeq == 'desc' ? 1 : -1);
												return 0;
			                });
                    } else {
                       log.error('Unknown sort column in summaryQueryCompressed: ' + options.sort.column + '. Must be summary item name!' );
                    }

                }
            }

            // console.dir(result);

            if (options.choices) {
                if (callback) {
                    callback(makeChoices(result));
                }
                return;
            }

            if (callback) {
                callback(result);
            }
        }

        function summaryQueryCompressed() {
            var colName;

            // Fetch the XML from the dataset
            colName = 'col' + proc.summaryMap.indexOf('__CD__Data');
            doTx('readTransaction', function(tx) {
                var params = [];
                function success(tx, result) {
                    var arr,
    				i,
    				item;
                    tx = undefined;
                    arr = [];
                    if (result && result.rows && result.rows.length) {
                        decompressXML(result.rows.item(0)[colName]);
                    } else {
                        log.warn('No results found in summaryQueryCompressed');
                        callback([]);
                    }
                }
                function error(tx, e) {
                    tx = undefined;
                    log.error('Exception in summaryQueryCompressed: ' + e.name + '. ' + e.message);
                    callback([]);
                }
                sql = 'SELECT ' + colName + ' FROM subject WHERE backupGuid IS NULL AND processId = ?';
                params.push(processId);
                tx.executeSql(sql, params, success, error);
            });

        }

        function summaryQueryUncompressed() {
            var sqlSeparator, summaryNames = options.summaryNames || options.summaryName;
            if (!summaryNames) {
                summaryNames = proc.summaryMap;
            }
            if (typeof summaryNames == 'string' || summaryNames instanceof String) {
                summaryNames = [summaryNames];
            }
            doTx('readTransaction', function(tx) {
                var i,
    			sql,
    			params;
                function success(tx, result) {
                    var a,
    				c,
    				i,
    				j,
    				o,
    				r;
                    tx = undefined;
                    a = [];
                    if (result && result.rows) {
                        for (i = 0; i < result.rows.length; i += 1) {
                            r = result.rows.item(i);
                            o = {
                                guid: r.guid
                            };
                            for (j = 0; j < summaryNames.length; j += 1) {
                                c = "col" + proc.summaryMap.indexOf(summaryNames[j]);
                                o[summaryNames[j]] = r[c];
                            }
                            a.push(o);
                        }
                    }
                    if (options.choices) {
                        if (callback) {
                            callback(makeChoices(a));
                        }
                        return;
                    }
                    callback(a);
                }
                function error(tx, e) {
                    tx = undefined;
                    log.error('Exception in mc.db.querySummaries: ' + e.name + '. ' + e.message);
                    callback([]);
                }
                sql = "SELECT";
                params = [];
                if (options.distinct || options.unique) {
                    sql += " DISTINCT";
                } else {
                    //can't be distinct if guid is included
                    sql += " guid,";
                }
                sqlSeparator = "";
                for (i = 0; i < summaryNames.length; i += 1) {
                    sql += sqlSeparator + " col" + proc.summaryMap.indexOf(summaryNames[i]);
		                sqlSeparator = ",";
                }
                sql += " FROM subject WHERE backupGuid IS NULL AND processId = ?";
                params.push(processId);

                if (options.conditions) {
                    for (i = 0; i < options.conditions.length; i += 1) {
                        sql += " AND ";
                        switch (options.conditions[i].condition) {
                            case 'begins':
                                sql += "col" + proc.summaryMap.indexOf(options.conditions[i].summaryName) + " LIKE ?";
                                params.push(options.conditions[i].value + "%");
                                break;
                            case 'ends':
                                sql += "col" + proc.summaryMap.indexOf(options.conditions[i].summaryName) + " LIKE ?";
                                params.push("%" + options.conditions[i].value);
                                break;
                            case 'contains':
                                sql += "col" + proc.summaryMap.indexOf(options.conditions[i].summaryName) + " LIKE ?";
                                params.push("%" + options.conditions[i].value + "%");
                                break;
                            default:
                                sql += "col" + proc.summaryMap.indexOf(options.conditions[i].summaryName) + " = '" + options.conditions[i].value + "'";
                                break;
                        }
                    }
                } else if (options.filters) {
                    $.each(options.filters, function(idx, filter) {
                        sql += " AND ";
                        sql += "col" + proc.summaryMap.indexOf(filter.summaryName) + " = '" + filter.summaryValue + "'";
                    });
                }

                if (options.sort) {
                    if (options.sort.column) {
                        sql += " ORDER BY col" + proc.summaryMap.indexOf(options.sort.column);
                        if (options.sort.order) {
                            sql += " " + options.sort.order;
                        }
                    }
                }
                if (options.limit)
                    sql += " LIMIT " + options.limit
                if (options.offset)
                    sql += " OFFSET " + options.offset;
                tx.executeSql(sql, params, success, error);
            }, function() {
                log.error('DB Transaction failed in mc.db.querySummaries');
                callback([]);
            });
        }

        proc = mCapture.db.getProcess(mCapture.db.makeProcessName({
            id: processId,
            version: getLatestProcessVersion(processId)
        }));
        if (!proc) {
            log.error("Couldn't find dataset: " + processId);
            callback();
            return;
        }
        compressed = !proc.isaprocess && proc.pages.DATA.qIdMap.__CD__Data && proc.pages.DATA.qIdMap.__CD__Data === '__CD__Data';
        separator = '';
        if (proc !== undefined && proc.separator !== undefined) {
            separator = proc.separator;
        }

        if (compressed) {
            summaryQueryCompressed();
        } else {
            summaryQueryUncompressed();
        }
    }
    var dbTestResults;
    function dbTest_iterator(transaction, index, max, processId, version, callback) {
        if (index >= max) {
            callback();
            return;
        }
        mc.profiler.clear(true);
        mc.db.createSubjectInTransaction(transaction, processId, version, undefined, function(result) {
            var guid, subject;
            guid = result.guid;
            subject = result.value;
            //dbTest_iterator(transaction, ++index, max, processId, version, callback);
            mc.db.setSubjectInTransaction(transaction, guid, subject, false, function(error) {
                if (error !== undefined) {
                    alert(error);
                }
                mc.db.getSubjectInTransaction(transaction, guid, function(tx3, newSubject) {
                    if (newSubject === undefined) {
                        alert("could not retrieve subject");
                    }
                    dbTestResults.push(mc.profiler.getResults());
                    dbTest_iterator(transaction, ++index, max, processId, version, callback);
                });
            });
        });
    }
    
    function valueChanging(subject, dataId, newValue, index, callback) {
        function getProcess() {
            var processName = makeProcessName({ 
                'id': subject._meta.processId,
                'version': subject._meta.processVersion
            });
            return mc.db.getProcess(processName);
        }
        function getSingleValue(val) {
            if (index !== null && index !== undefined) {
                if (index.constructor === String) {
                    index = parseInt(index, 10);
                }
                if (val === undefined || val === null || val.constructor !== Array) {
                    return undefined;
                } else {
                    return val[index];;
                }
            } else {
                return val;
            }
        }
        function isMediaQuestion(question) {
            function isPhotoQuestion() {
                return 'extraPhotoOptions' in question;
            }
            function isImageQuestion() {
                return question.type === 'att';
            }
            return isPhotoQuestion() || isImageQuestion();
        }
        function done() {
            callback && callback();
        }
        
        var process = getProcess();
        var data = process.dataIdMap[dataId];
        if (!data) {
            throw Error('No item exists with id ' + dataId);
        }
        var hasAttQs = data.qIds.map(function(qId) { return process.questions[qId]; })
            .some(function(question) { return question && isMediaQuestion(question)});        
        if (hasAttQs) {
            var oldSingleValue = getSingleValue(subject[dataId]),
                newSingleValue = getSingleValue(newValue);
            if (oldSingleValue && oldSingleValue !== newSingleValue) {
                mc.db.deleteAttachment(subject._meta.guid, oldSingleValue, function() { done() });
            } else {
                done();
            }
        } else {
            done();
        }
    }

    /**
    * Perform subject insertion test
    *
    * @param complete_callback
    *                      callback function(  ), called when test finishes
    *
    */
    function dbTest(complete_callback, max, batchSize) {
        var done, startTime, processId, version;
        function doBatch(size) {
            function batchDone() {
                var time, subjCount;
                done += size;
                if (done < max) {
                    doBatch(size);
                } else {
                    time = (new Date() - startTime) / 1000;
                    subjCount = mc.db.getProcesses()[0].value.subjectGuids.length;
                    alert(subjCount + " subjects in " + time);
                    mc.db.setJsonItem('dbTestResults', dbTestResults);
                    mc.profiler.clear(false);
                    updateUsedProcessVersionsCookie(function() {
                        complete_callback(true);
                    });
                }
            }
            doTx('transaction', function(transaction) {
                dbTest_iterator(transaction, 0, size, processId, version, batchDone);
            });
            /*
            doTx('transaction', function (transaction) {
            dbTest_iterator(transaction, 0, max, processId, version, function () {
            var time, subjCount;
            time = (new Date() - startTime) / 1000;
            subjCount = mc.db.getProcesses()[0].value.subjectGuids.length;
            alert(subjCount + " subjects in " + time);
            mc.db.setJsonItem('dbTestResults', dbTestResults);
            mc.profiler.clear(false);
            updateUsedProcessVersionsCookie(function () {
            complete_callback(true);
            });
            });
            });
            */
        }
        done = 0;
        dbTestResults = [];
        startTime = new Date(); // Get a process
        processId = mc.db.getProcesses()[0].value.id;
        version = mc.db.getProcessVersions(processId)[0];
        doBatch(batchSize || 100);
    }

    function deleteAllCookies() {
        var cookie, cookies, i, eqPos, name;
        cookies = document.cookie.split(";");
        for (i = 0; i < cookies.length; i++) {
            cookie = cookies[i];
            eqPos = cookie.indexOf("=");
            name = eqPos > -1 ? cookie.substr(0, eqPos) : cookie;
            while (name.substring(0, 1) === ' ') {
                name = name.substring(1, name.length);
            }
            document.cookie = name + "=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/";
        }
    }

    /* 
     * The following functions support the subject validation found in replicator_storage.
     * A fresh copy of the database is used, possibly due to WebSQL implementations on
     * some platforms.
     */

    function validate_openDatabase(callback) {
        try {
            callback(null, window.openDatabase('mDesign', '', 'mDesign', 1048576));
        } catch (error) {
            callback(error);
        }
    }

    function validate_getSubject(db, subjectGuid, columns, callback) {

        db.readTransaction(function (transaction) {
            var i, params, sql;
            function success(tx, result) {
                try {
                    var subject;
                    if (result && result.rows.length > 0) {
                        subject = $.jsonParse(result.rows.item(0).answers);
                        if (columns) {
                            columns = result.rows.item(0);
                            delete columns.answers;
                        }
                    }
                    callback(undefined, subject, columns);
                } catch (error) {
                    callback(error);
                }
            }
            function error(tx, error) {
                callback(error);
            }
            params = [subjectGuid];
            sql = 'SELECT answers ';
            if (columns) {
                for (i = 0; i < 50; i += 1) {
                    sql += ', col' + i.toString();
                }
            }
            sql += ' FROM subject WHERE guid = ?';
            transaction.executeSql(sql, params, success, error);
        });
    }

    function validate_deleteSubject(db, subjectGuid, callback) {
        db.transaction(function (transaction) {
            transaction.executeSql('DELETE FROM attachment WHERE subjectGuid=?;', [subjectGuid]);
            transaction.executeSql('DELETE FROM subject WHERE guid=?;', [subjectGuid]);
        }, function (error) {
            callback(error);
        }, function () {
            callback();
        });
    }

    noCurrentSubject = {
        code: -1,
        message: 'No current subject'
    };
    mc.db = {
        _currentSubject: _currentSubject,
        _deleteSubject: _deleteSubject,
        _deleteSubjectInTransaction: _deleteSubjectInTransaction,
        backupCurrentSubject: backupCurrentSubject,
        clear: clear,
        cloneSubject: cloneSubject,
        createDb: createDb,
        createProcess: createProcess,
        createSubject: createSubject,
        createSubjectInTransaction: createSubjectInTransaction,
        dbTest: dbTest,
        deleteAllCookies: deleteAllCookies,
        deleteAllSubjects: deleteAllSubjects,
        deleteAttachment: deleteAttachment,
        deleteAttachmentInTransaction: deleteAttachmentInTransaction,
        deleteBackup: deleteBackup,
        deleteJsonItem: deleteJsonItem,
        deleteSubject: deleteSubject,
        deleteSubjectInTransaction: deleteSubjectInTransaction,
        deleteValue: deleteValue,
        evaluateSummaryValues: evaluateSummaryValues,
        ensureReplDataPresent: ensureReplDataPresent,
        ensureValue: ensureValue,
        executeQuery: executeQuery,
        getAttachment: getAttachment,
        getAttachmentList: getAttachmentList,
        getCachedPosition: getCachedPosition,
        getCookie: getCookie,
        getCurrentProcess: getCurrentProcess,
        getCurrentSubject: getCurrentSubject,
        getCurrentSubjectGuid: getCurrentSubjectGuid,
        getExpansionError: getExpansionError,
        getHomeProcess: getHomeProcess,
        getJsonItem: getJsonItem,
        getLatestProcesses: getLatestProcesses,
        getLatestProcessById: getLatestProcessById,
        getLatestProcessVersion: getLatestProcessVersion,
        getMetaValue: getMetaValue,
        getOldProcesses: getOldProcesses,
        getProcess: getProcess,
        getProcesses: getProcesses,
        getProcessNames: getProcessNames,
        getProcessVersions: getProcessVersions,
        getSubject: getSubject,
        getSubjectGuid: getSubjectGuid,
        getSubjectGuidFromReplID: getSubjectGuidFromReplID,
        getSubjectGuids: getSubjectGuids,
        getSubjectInTransaction: getSubjectInTransaction,
        getSubjectSummaries: getSubjectSummaries,
        getSummaryValue: getSummaryValue,
        getSummaryValues: getSummaryValues,
        getUsedProcessVersions: getUsedProcessVersions,
        getUserInfo: getUserInfo,
        getValue: getValue,
        getValueArrayLength: getValueArrayLength,
        guid: guid,
        isProcessDeployed: isProcessDeployed,
        isProcessInUse: isProcessInUse,
        makeProcessName: makeProcessName,
        querySummaries: querySummaries,
        querySummaryData: querySummaryData,
        queryXmlSummaries: queryXmlSummaries,
        ready: ready,
        restoreCurrentSubject: restoreCurrentSubject,
        setAttachment: setAttachment,
        setAttachmentInTransaction: setAttachmentInTransaction,
        setCookie: setCookie,
        setDb: setDb,
        setJsonItem: setJsonItem,
        setMetaValue: setMetaValue,
        setSubject: setSubject,
        setSubjectInTransaction: setSubjectInTransaction,
        setProcess: setProcess,
        setUserInfo: setUserInfo,
        setValue: setValue,
        startTransaction: startTransaction,
        summaryQuery: summaryQuery,
        valueChanging: valueChanging,
        validate_openDatabase: validate_openDatabase,
        validate_getSubject: validate_getSubject,
        validate_deleteSubject: validate_deleteSubject
    };
} (window.jmfw, window.mCapture));
/*
** END OF MC2.DB.JS
*/
﻿(function($, mc) {

     var FileSystemState = {
            UNREQUESTED: 0,
            REQUESTED: 1,
            SUCCESS: 2,
            ERROR: 3
        },
        _fsState = FileSystemState.UNREQUESTED,
        _fsCallbacks = [],
        _fsResult = null, 
        _serverUri = null;

    function getFileSystem(successCallback, errorCallback) {
        
        function requestSuccess(fs) {
            _fsState = FileSystemState.SUCCESS;
            _fsResult = fs;
            for (var i = 0; i < _fsCallbacks.length; i++) {
                var callback = _fsCallbacks[i].success;
                callback && callback(_fsResult);
        }
        }
        
        function requestError(error) {
            _fsState = FileSystemState.ERROR;
            _fsResult = error;            
            for (var i = 0; i < _fsCallbacks.length; i++) {
                var callback = _fsCallbacks[i].error;
                callback && callback(_fsResult);
            }
        }
        
        switch (_fsState) {
        
            case FileSystemState.UNREQUESTED:                
                if (mc.fs.available) {
                    _fsState = FileSystemState.REQUESTED;
                    _fsCallbacks.push({
                        success: successCallback,
                        error: errorCallback
                    }); 
                    window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, requestSuccess, requestError);
                } else {
                    _fsState = FileSystemState.ERROR;
                    errorCallback({message: 'file system is not available - phonegap is not present'});
                }
                break;
            case FileSystemState.REQUESTED:
                _fsCallbacks.push({
                    success: successCallback,
                    error: errorCallback
                });            
                break;
                
            case FileSystemState.SUCCESS:
                successCallback(_fsResult);
                break;
                
            case FileSystemState.ERROR:
                errorCallback(_fsResult);
                break;
                
        }
    }

    /* exported */
    function moveTemporaryFile(fileUri, subjectGuid, name, successCallback, errorCallback) {
        getFileSystem(
            function(fs) {
                log.debug('moving temporary file...' + JSON.stringify([fileUri, subjectGuid, name]));
                function gotDirectory(directory) {
                    log.debug('got subject attachments directory... ' + directory.fullPath);
                    function gotMovedFileEntry(fileEntry) {
                        log.debug('got moved file entry... ' + fileEntry.fullPath);
                        successCallback(fileEntry.fullPath);
                    }
                    function gotFileEntry(fileEntry) {
                        log.debug('got file entry... ' + fileEntry.fullPath);
                        var filename = getAttachmentFilename(name);
                        fileEntry.moveTo(directory, filename, gotMovedFileEntry, errorCallback);
                    }
                    _resolveLocalFileSystemURL(fileUri, gotFileEntry, errorCallback);
                }
                getSubjectAttachmentsDirectory(fs, subjectGuid, true, gotDirectory, errorCallback);
            },
            errorCallback);
    }
    
    /* exported */
    function copyTemporaryFile(fileUri, subjectGuid, name, successCallback, errorCallback) {
        getFileSystem(
            function(fs) {
                log.debug('copying temporary file...' + JSON.stringify([fileUri, subjectGuid, name]));
                function gotDirectory(directory) {
                    log.debug('got subject attachments directory... ' + directory.fullPath);
                    function gotCopiedFileEntry(fileEntry) {
                        log.debug('got copied file entry... ' + fileEntry.fullPath);
                        successCallback(fileEntry.fullPath);
                    }
                    function gotFileEntry(fileEntry) {
                        log.debug('got file entry... ' + fileEntry.fullPath);
                        var filename = getAttachmentFilename(name);
                        fileEntry.copyTo(directory, filename, gotCopiedFileEntry, errorCallback);
                    }
                    _resolveLocalFileSystemURL(fileUri, gotFileEntry, errorCallback);
                }
                getSubjectAttachmentsDirectory(fs, subjectGuid, true, gotDirectory, errorCallback);
            },
            errorCallback);
    }

    /* exported */
    function getAttachmentPath(subjectGuid, name, successCallback, errorCallback) {
        getFileSystem(
            function(fs) {
                log.debug('getAttachmentPath ' + JSON.stringify([subjectGuid, name]));
                function gotDirectory(directory) {
                    var fullPath = directory.fullPath.replace(/\/*$/, '/' + getAttachmentFilename(name)); 
                    /* comment to stop VS from treating the regex as a comment */
                    log.debug('got attachment path: ' + fullPath);
                    successCallback(fullPath);
                }
                getSubjectAttachmentsDirectory(fs, subjectGuid, true, gotDirectory, errorCallback);
            },
            errorCallback);
    }

    function makeItemIdBin(subjectGuid, name) {
        var itemId = 'subjects\\' + subjectGuid + '\\' + name;
        itemId = window.makeBinary(itemId, true);
        return window.encode_base64(itemId);
    }

    function makeSyncDataBin(syncData) {
        syncData = window.makeBinary(syncData, true);
        return window.encode_base64(syncData);
    }

    function downloadSyncData(subjectGuid, name, successCallback, errorCallback) {
        function gotServerUri(serverUri) {
            var itemId, downloadUri, xhr;
            itemId = makeItemIdBin(subjectGuid, name);
            downloadUri = serverUri + '/download-sync-data?ItemId=' + encodeURIComponent(itemId);            
            log.debug('downloadUri: ' + downloadUri);
            
            var xhr = new XMLHttpRequest();
            xhr.onload = function() {
                var syncData = window.decode_utf8(xhr.responseText);
                successCallback(syncData);
            };
            xhr.onerror = function(e) {
                if( e && e.target ) {
                    errorCallback("Error " + e.target.statusText + " (" + e.target.status + ") occurred while receiving the document.");
                } else {
                    errorCallback(e);
                }
            };
            xhr.open("GET", downloadUri, true);
            xhr.send();
        }
        getServerUri(gotServerUri,errorCallback);
    }

    function getServerUri(callback,errorCallback) {
        if (_serverUri) {
            callback(_serverUri);
        } else {
            window.plugins.settings.getURL(function(uri) {
                callback(uri);
            }, function () { log.debug('mc.fs.getServerUri : Unable to get server URL'); errorCallback("Unable to get server url") });
        };
    }

    /* exported */
    function downloadAttachment(subjectGuid, name, successCallback, errorCallback) {
        getFileSystem(
            function(fs) {
                function gotServerUri(serverUri) {
                    function gotSyncData(syncData) {
                        function gotAttachmentPath(attachmentPath) {
                            var ft = new FileTransfer();
                            var itemIdBin = makeItemIdBin(subjectGuid, name);
                            var downloadUri = encodeURI(serverUri + '/download-attachment');
                            downloadUri += '?ItemId=' + encodeURIComponent(itemIdBin);
                            attachmentPath = _pathToURL(fs, attachmentPath);
					        if( $.isIE )
						        attachmentPath = attachmentPath.replace('/', '\\');
                            ft.download(downloadUri, attachmentPath, downloadSuccess, errorCallback);
                        }
                        function downloadSuccess(file) {
                            log.debug('downloaded attachment file: ' + file.fullPath);
                            successCallback(syncData);
                        }
                        getAttachmentPath(subjectGuid, name, gotAttachmentPath, errorCallback);
                    }
                    downloadSyncData(subjectGuid, name, gotSyncData, errorCallback);
                }
                getServerUri(gotServerUri,errorCallback);
            }, 
            errorCallback);
    }
    
    /* exported */
    function downloadAttachmentURL(subjectGuid, name, url, successCallback, errorCallback) {
        getFileSystem(
            function(fs) {  
                function gotAttachmentPath(attachmentPath) {
                    var ft = new FileTransfer();
                    var downloadUri = encodeURI(url);
                    attachmentPath = _pathToURL(fs, attachmentPath);
                    ft.download(downloadUri, attachmentPath, successCallback, errorCallback);
                }        
                log.debug('IN mc.fs.downloadAttachmentURL :' + url);
                getAttachmentPath(subjectGuid, name, gotAttachmentPath, errorCallback);
            },
            errorCallback);
    }
    
    /* exported */
    function downloadAttachmentResource(subjectGuid, name, res, successCallback, errorCallback) {    
        function gotAttachmentPath(attachmentPath) {        
            if (window.plugins && window.plugins.resource) {
                window.plugins.resource.copyAssetFromWWWFolder(res, attachmentPath, successCallback, errorCallback);
            } else {
                errorCallback('Download failed: the resource plugin is not available');
            }
        }
        log.debug('IN mc.fs.downloadAttachmentResource :' + res);
        getAttachmentPath(subjectGuid, name, gotAttachmentPath, errorCallback);
    }

    /* exported */
    function uploadAttachment(subjectGuid, name, syncData, successCallback, errorCallback) {
        getFileSystem(
            function(fs) {
                function gotDirectory(directory) {
                    function gotServerUri(serverUri) {
                        var fileName = getAttachmentFilename(name);
                        function gotFile(file) {
                            var options = new FileUploadOptions();
                            options.fileKey = 'file';
                            options.fileName = fileName;
                            options.mimeType = "application/octet-stream";
                            var ft = new FileTransfer();
                            var uploadUri = encodeURI(serverUri + '/upload-attachment');
                            var itemIdBin = makeItemIdBin(subjectGuid, name);
                            uploadUri += '?ItemId=' + encodeURIComponent(itemIdBin);
                            if (syncData) {
                                var syncDataBin = makeSyncDataBin(syncData);
                                uploadUri += '&SyncData=' + encodeURIComponent(syncDataBin);
                            }
                            var retryCount = 0;
                            function retryLoop() {
                                retryCount++;
                                var errorHandler = (retryCount == 3) ? errorCallback : retryLoop;
                                ft.upload(_entryToURL(file), uploadUri, uploadSuccess, errorHandler, options);
                            }
                            retryLoop();
                        }
                        directory.getFile(fileName, { create: false }, gotFile, errorCallback);
                    }
                    getServerUri(gotServerUri,errorCallback);
                }
                function uploadSuccess(result) {
                    result = window.decodeURIComponent(result.response);
                    successCallback(result);
                }
                getSubjectAttachmentsDirectory(fs, subjectGuid, true, gotDirectory, errorCallback);
            },
            errorCallback);
    }

    /* exported */
    function deleteAttachment(subjectGuid, name, successCallback, errorCallback) {
        getFileSystem(
            function(fs) {
                // log.trace('IN fs.deleteAttachment ' + subjectGuid + ' ' + name);
                function gotDirectory(directory) {
                    // log.trace('IN fs.deleteAttachment.gotDirectory');
                    var filename = getAttachmentFilename(name);
                    directory.getFile(filename, { create: false }, gotFileEntry, errorCallback);
                }
                function gotFileEntry(fileEntry) {
                    // log.trace('IN fs.deleteAttachment.gotFileEntry');
                    fileEntry.remove(successCallback, errorCallback);
                }
                getSubjectAttachmentsDirectory(fs, subjectGuid, false, gotDirectory, errorCallback);
            },
            errorCallback);
    }

    /* exported */
    function deleteAttachments(subjectGuid, successCallback, errorCallback) {
        getFileSystem(
            function(fs) {
                // log.trace('IN fs.deleteAttachments ' + subjectGuid);
                function gotDirectory(directory) {
                    // log.trace('IN fs.deleteAttachments.gotDirectory');
                    directory.removeRecursively(successCallback, errorCallback);
                }
                getSubjectAttachmentsDirectory(fs, subjectGuid, false, gotDirectory, errorCallback);
            },
            errorCallback);
    }

    /* exported */
    function duplicateAttachment(oldSubjectGuid, oldName, newSubjectGuid, newName, successCallback, errorCallback) {
        getFileSystem(
            function(fs) {
                function gotOldDirectory(oldDirectory) {
                    function gotOldFileEntry(oldFileEntry) {
                        function gotNewDirectory(newDirectory) {
                            var newFilename = getAttachmentFilename(newName);
                            fileEntry.copyTo(newDirectory, newName, gotNewFileEntry, errorCallback);
                        }
                        function gotNewFileEntry(fileEntry) {
                            successCallback();
                        }
                        getSubjectAttachmentsDirectory(fs, newSubjectGuid, true, gotNewDirectory, errorCallback);
                    }
                    var oldFilename = getAttachmentFilename(oldName);
                    oldDirectory.getFile(oldFilename, { create: false }, gotOldFileEntry, errorCallback);
                }
                getSubjectAttachmentsDirectory(fs, oldSubjectGuid, false, gotOldDirectory, errorCallback);
            },
            errorCallback);
    }
    
  /* exported */
    function getAttachmentData(subjectGuid, name, successCallback, errorCallback) {        
        getFileSystem(
            function(fs) {
		        function gotFile(file) {		
                    var reader = new FileReader();
                    reader.onload = function(evt) {
                        successCallback(evt.target.result);
                    };
			        reader.onerror = function(evt) {
                        errorCallback(evt.target.error);
			        };
                    reader.readAsDataURL(file);
		        }		
                function gotFileEntry(fileEntry) {
			        fileEntry.file(gotFile, errorCallback);
                }
		        function gotDirectory(directoryEntry) {
                    var filename = getAttachmentFilename(name);
                    directoryEntry.getFile(filename, { create: false }, gotFileEntry, errorCallback);
                }
                getSubjectAttachmentsDirectory(fs, subjectGuid, false, gotDirectory, errorCallback);
            },
            errorCallback);
    }
    
   /* exported */
    function saveUserData(filename, content, successCallback, errorCallback) {
        getFileSystem(
            function(fs) {
                function gotWriter(writer) {
                    writer.onwriteend = function() {
                        successCallback();
                    };
                    writer.write(content);
                }
                function gotFile(file) {
                    file.createWriter(gotWriter, errorCallback);
                }
                function gotDir(dir) {
                    dir.getFile(filename, {create: true, exclusive: false}, gotFile, errorCallback);
                }
                getUserDataDirectory(fs, true, gotDir, errorCallback);
            },
            errorCallback);
    }
    
    /* exported */
    function readUserData(filename, successCallback, errorCallback) {
        getFileSystem(
            function(fs) {
		        function gotFile(file) {
			        var reader = new FileReader();
                    reader.onload = function(evt) {
                        successCallback(evt.target.result);
                    };
			        reader.onerror = function(evt) {
				        errorCallback(evt.target.error);
			        };
                    reader.readAsText(file);
		        }
                function gotFileEntry(fileEntry) {			
			        fileEntry.file(gotFile, errorCallback);
                }
                function gotDir(dir) {
                    dir.getFile(filename, {create: false}, gotFileEntry, errorCallback);
                }
                getUserDataDirectory(fs, false, gotDir, errorCallback);
            },
            errorCallback);
    }
	/* exported */
    function copyFileAsAttachment(srcPath, subjectGuid, successCallback, errorCallback) {
		getFileSystem(
			function(fs) {
		        function gotAttachmentsDirectory(attDir) {
        		    function gotSrcFile(srcFile) {
                		var name = mc.db.guid();
		                srcFile.copyTo(attDir, name, function() { 
        		                successCallback(name);
                		    }, errorCallback);
		            }
        		    srcPath = srcPath.replace(/^\/*/, '');
                    /* comment to stop VS from treating the regex as a comment */
		            fs.root.getFile(srcPath, {create: false}, gotSrcFile, errorCallback);
		        }
		        getSubjectAttachmentsDirectory(fs, subjectGuid, true, gotAttachmentsDirectory, errorCallback);
			},
			errorCallback);
    }

    /* exported */
    function clear(successCallback, errorCallback) {
        getFileSystem(
            function(fs) {
                // log.trace('IN fs.clear');
                function gotDirectory(directory) {
                    // log.trace('IN fs.clear.gotDirectory');
                    directory.removeRecursively(successCallback, errorCallback);
                }
                getAttachmentsDirectory(fs, gotDirectory, errorCallback);
            },
            errorCallback);
    }

    function getSubjectAttachmentsDirectory(fs, subjectGuid, create, successCallback, errorCallback) {
        function gotDirectory(dir) {
            dir.getDirectory(subjectGuid, { create: create }, successCallback, errorCallback);
        }
        getAttachmentsDirectory(fs, gotDirectory, errorCallback);
    }

    function getAttachmentsDirectory(fs, successCallback, errorCallback) {
        function gotApplicationID(applicationID) {
            getDirectory(fs.root, ['mDesign', applicationID, 'attachments'], true, successCallback, errorCallback);
        }
        mc.getApplicationID(gotApplicationID);
    }
    
    function getUserDataDirectory(fs, create, successCallback, errorCallback) {
        function gotApplicationID(applicationID) {
            getDirectory(fs.root, ['mDesign', applicationID, 'userdata'], create, successCallback, errorCallback);
        }
        mc.getApplicationID(gotApplicationID);
    }

    function getDirectory(parent, parts, create, successCallback, errorCallback) {
        var current = parts.shift();
        if (current) {
            parent.getDirectory(current, { create: create }, function(dir) {
                getDirectory(dir, parts, create, successCallback, errorCallback);
            }, errorCallback);
        } else {
            successCallback(parent);
        }
    }

    function getAttachmentFilename(name) {
        // log.trace('IN fs.getAttachmentFilename ' + name);
        return name;
    }

    /* exported */
    function createNewAttachment(subjectGuid, attachmentName, dataId, mime, data, callback) {
        function fail(error) {
            log.error('Failed to create attachment. Error:' + JSON.stringify(error));
        }
        function gotFileWriter(writer) {
            writer.onwriteend = function(evt) {
                function answerSet() {
                    mc.att.setAttachment(subjectGuid, attachmentName, '', true, callback);
                }
                mc.fl.dsksetdata({ resume: answerSet }, subjectGuid, dataId, attachmentName);
            };
            writer.write(data);
        }
        function gotFileEntry(fileEntry) {
            fileEntry.createWriter(gotFileWriter, fail);
        }
        function gotDirectory(directory) {
            var fullPath = directory.fullPath + '/' + attachmentName;
            log.debug('got attachment path: ' + fullPath);
            directory.getFile(attachmentName, { create: true, exclusive: false }, gotFileEntry, fail);
        }
        if (mc.fs.availableForAtts) {
            getFileSystem(
				function(fs) {
					getSubjectAttachmentsDirectory(fs, subjectGuid, true, gotDirectory, fail);
				}, 
				fail);
        } else {
            function answerSet() {
                if (mime === undefined)
                    mime = 'application/octet-stream';
                var uri = 'data:' + mime + ';base64,' + btoa(data);
                mc.db.setAttachment(subjectGuid, attachmentName, uri, true, callback);
            }
            mc.fl.dsksetdata({ resume: answerSet }, subjectGuid, dataId, attachmentName);
        }
    }
    
    /* helper functions to adapt code to differences between cordova 2 & 3 */
    function _resolveLocalFileSystemURL(uri, onSuccess, onError) {
        if (window.resolveLocalFileSystemURL) {
            resolveLocalFileSystemURL(uri, onSuccess, onError);
        } else {
            window.resolveLocalFileSystemURI(uri, onSuccess, onError);
        }
        
    }
    
    function _entryToURL(entry) {
        if (entry.toURL) {
            return entry.toURL();
        } else {
            return entry.fullPath;
        }
    }
    
    function _pathToURL(fs, path) {
        if (fs.__format__) {
            return fs.__format__(path);
        } else {
            return path;
        }
    }
    
    function isAvailable() {
         return mc.phonegapPresent();
    }

    function isAvailableForAtts() {
         return isAvailable() && mc.getShellType() !== 'phonegap';
    }

    mc.fs = {
        available: isAvailable(),
        availableForAtts: isAvailableForAtts(),
        getAttachmentPath: getAttachmentPath,
        moveTemporaryFile: moveTemporaryFile,
        copyTemporaryFile: copyTemporaryFile,
        deleteAttachment: deleteAttachment,
        deleteAttachments: deleteAttachments,
        duplicateAttachment: duplicateAttachment,
        uploadAttachment: uploadAttachment,
        downloadAttachment: downloadAttachment,
        downloadAttachmentURL: downloadAttachmentURL,
        downloadAttachmentResource: downloadAttachmentResource,
        getAttachmentData: getAttachmentData,
        clear: clear,
        createNewAttachment: createNewAttachment,
        copyFileAsAttachment: copyFileAsAttachment,
        readUserData: readUserData,
        saveUserData: saveUserData
    };

} (window.jmfw, window.mCapture));
/*
** END OF MC2.FS.JS
*/
/*jslint browser: true, devel: true, bitwise: true, continue: true, es5: true, evil: true, forin: true, nomen: true, plusplus: true, regexp: true, sloppy: true, white: true */
(function ($, mc) {

    function baseNotificationService() {
        var that;

        /**
         * Add channel to persistent list of channels to subscribe to. Immediately
         * subscribe to this channel with push service.
         *
         * @param    channel
         *                    String containing the name of the channel to add/subscribe
         * @param    callback
         *                    Optional function receiving the name of the channel added. 1st
         *                    parameter is error, 2nd parameter is channel added.
         */
        function addChannel(channel, callback) {
        }

        /**
         * Remove channel from persistant list of channels to subscribe to. Immediately
         * unsubscribe to this channel with push service.
         *
         * @param    channel
         *                    String containing the name of the channel to remove/unsubscribe
         * @param    callback
         *                    Optional function receiving the name of the channel removed. 1st
         *                    parameter is error, 2nd parameter is channel removed.
         */
        function removeChannel(channel, callback) {
        }

        /**
         * Retrieve the persistent list of all added channels
         *
         * @param    callback
         *                    Function called when list has been fully retrieved. 1st parameter is
         *                    error, 2nd parameter is an array of strings, each containing the name
         *                    of an added channel.
         */
        function listChannels(callback) {
        }

        /**
         * Publish a message on message.channel
         *
         * @param    message
         *                    Object containing at least a channel string.
         * @param    callback
         *                    Optional function receiving the message id of the sent message
         */
        function sendMessage(message, callback) {
        }

        /**
         * Retrieve all messages for the supplied channel & subchannel
         *
         * @param    channel
         *                    String containing the name of the channel
         * @param    subChannel
         *                    String containing the name of the sub-channel
         * @param    callback
         *                    Function called when all messages have been fully retrieved. 1st
         *                    parameter error, 2nd parameter is an array of objects, each containing
         *                    the object as originally published.
         */
        function getMessages(channel, subchannel, callback) {
        }

        /**
         * Retrieve all unread messages for the supplied channel, subchannel &
         * receiver
         *
         * @param    receiver
         *                    String containing the name of the receiver
         * @param    channel
         *                    String containing the name of the channel
         * @param    subChannel
         *                    String containing the name of the sub-channel
         * @param    callback
         *                    Function called when all messages have been fully retrieved. 1st
         *                    parameter error, 2ns parameter is an array of objects, each containing
         *                    the object as originally published.
         */
        function getUnreadMessages(receiver, channel, subchannel, callback) {
        }

        /**
         * Delete message with the supplied id
         *
         * @param    id
         *                    String containing the id of the message to delete
         * @param    callback
         *                    Optional function receiving the message id of the deleted message
         */
        function deleteMessage(id, callback) {
        }

        /**
         * Register a callback to be called when new messages are received. When
         * receiveMessageNotification is first called, any undelivered messages on the
         * supplied channel will be delivered to the callback. If there are multiple
         * unread messages, the callback will be called once for each unread message.
         *
         * @param    receiver
         *                    String containing the name of the receiver
         * @param    channel
         *                    String containing the name of the channel
         * @param    subChannel
         *                    String containing the name of the sub-channel
         * @param    callback
         *                    Function called when an unread message has been received/detected.
         *                    1st parameter is error, 2nd parameter is the message object as it was
         *                    originally published.
         *
         * @return    Error string or undefined on success
         */
        function receiveMessageNotification(receiver, channel, subchannel, callback) {
        }

        /**
         * Acknowledge that the supplied messageid has been received by the
         * supplied receiver
         *
         * @param receiver
         *                    String containing the id of the receiver who received the message
         * @param messageid
         *                    String containing the id of the message received
         * @param    callback
         *                    Optional function receiving called when the ack has been processed
         */
        function messageReceivedAck(receiver, messageid, callback) {
        }

        /**
         * Stop receiving notifications associated with the supplied id
         *
         * @param    receiver
         *                    String containing receiver as previously supplied to
         *                    receiveMessageNotification
         * @param    callback
         *                    Optional function receiving the name of the receiver
         */
        function cancelMessageNotification(receiver, callback) {
        }

        /**
         * Stop receiving all notifications
         *
         * @param    callback
         *                    Optional function called when all notifications have been cancelled
         */
        function cancelAllMessageNotifications(callback) {
        }

        /**
         * Register for message store change notifications
         *
         * @param    receiver
         *                    String containing the name of the receiver
         * @param    callback
         *                    Function called whenever a message has been added, updated or deleted
         *                    from the message database. 1st parameter is the changed message.
         */
        function receiveInboxChanges(receiver, callback) {
        }

        /**
         * Stop receving message store change notifications
         *
         * @param    receiver
         *                    String containing the name of the receiver
         * @param    callback
         *                    Function called cancel has completed
         */
        function cancelInboxChanges(receiver, callback) {
        }

        that = {
            addChannel: addChannel,
            cancelAllMessageNotifications: cancelAllMessageNotifications,
            cancelInboxChanges: cancelInboxChanges,
            cancelMessageNotification: cancelMessageNotification,
            deleteMessage: deleteMessage,
            getMessages: getMessages,
            getUnreadMessages: getUnreadMessages,
            listChannels: listChannels,
            messageReceivedAck: messageReceivedAck,
            receiveMessageNotification: receiveMessageNotification,
            receiveInboxChanges: receiveInboxChanges,
            removeChannel: removeChannel,
            sendMessage: sendMessage
        };
        return that;
    }

    function cordovaNotificationService() {
        var available, that;
        function canNotify(calltype, callback) {
            if (typeof (window.plugins) !== 'undefined' && typeof (window.plugins.notify) !== 'undefined') {
                if (typeof (window.plugins.notify[calltype]) === 'function') {
                    return true;
                }
            }
            log.warn('Unable to use notifications system ' + calltype);
            if (typeof (callback) !== 'undefined') {
                callback('Notification system missing');
            }
            return false;
        }
        function addChannel(channel, callback) {
            if (canNotify('addChannel', callback)) {
                window.plugins.notify.addChannel(channel, callback);
            }
        }

        function removeChannel(channel, callback) {
            if (canNotify('removeChannel', callback)) {
                window.plugins.notify.removeChannel(channel, callback);
            }
        }

        function listChannels(callback) {
            if (canNotify('listChannels', callback)) {
                window.plugins.notify.listChannels(callback);
            }
        }

        function sendMessage(message, callback) {
            if (canNotify('sendMessage', callback)) {
                window.plugins.notify.sendMessage(message, callback);
            }
        }

        function getMessages(channel, subchannel, callback) {
            if (canNotify('getMessages', callback)) {
                window.plugins.notify.getMessages(channel, subchannel, callback);
            }
        }

        function getUnreadMessages(receiver, channel, subchannel, callback) {
            if (canNotify('getUnreadMessages', callback)) {
                window.plugins.notify.getUnreadMessages(receiver, channel, subchannel, callback);
            }
        }

        function deleteMessage(id, callback) {
            if (canNotify('deleteMessage', callback)) {
                window.plugins.notify.deleteMessage(id, callback);
            }
        }

        function receiveMessageNotification(receiver, channel, subchannel, callback) {
            if (canNotify('receiveMessageNotification', callback)) {
                return window.plugins.notify.receiveMessageNotification(receiver, channel, subchannel, callback);
            }
        }

        function messageReceivedAck(receiver, messageid, callback) {
            if (canNotify('messageReceivedAck', callback)) {
                return window.plugins.notify.messageReceivedAck(receiver, messageid, callback);
            }
        }

        function cancelMessageNotification(receiver, callback) {
            if (canNotify('cancelMessageNotification', callback)) {
                window.plugins.notify.cancelMessageNotification(receiver, callback);
            }
        }

        function cancelAllMessageNotifications(callback) {
            if (canNotify('cancelAllMessageNotifications', callback)) {
                window.plugins.notify.cancelAllMessageNotifications(callback);
            }
        }

        function receiveInboxChanges(receiver, callback) {
            if (canNotify('receiveInboxChanges', callback)) {
                window.plugins.notify.receiveInboxChanges(receiver, callback);
            }
        }

        function cancelInboxChanges(receiver, callback) {
            if (canNotify('cancelInboxChanges', callback)) {
                window.plugins.notify.cancelInboxChanges(receiver, callback);
            }
        }

        available = true; //window.PhoneGap && window.PhoneGap.available && window.plugins && window.plugins.notify;
        that = baseNotificationService();
        if (available) {
            that.addChannel = addChannel;
            that.cancelAllMessageNotifications = cancelAllMessageNotifications;
            that.cancelInboxChanges = cancelInboxChanges;
            that.cancelMessageNotification = cancelMessageNotification;
            that.deleteMessage = deleteMessage;
            that.getMessages = getMessages;
            that.getUnreadMessages = getUnreadMessages;
            that.listChannels = listChannels;
            that.messageReceivedAck = messageReceivedAck;
            that.receiveMessageNotification = receiveMessageNotification;
            that.receiveInboxChanges = receiveInboxChanges;
            that.removeChannel = removeChannel;
            that.sendMessage = sendMessage;
        }
        return that;
    }

    function browserNotificationService(webNotify) {
        var that = baseNotificationService(),
            available = true;

        function canNotify(calltype, callback) {
            if (typeof webNotify !== 'undefined') {
                if (typeof webNotify[calltype] === 'function') {
                    return true;
                }
            }
            log.warn('Unable to use notifications system ' + calltype);
            if (typeof (callback) === 'function') {
                callback('Notification system missing');
            }
            return false;
        }

        function addChannel(channel, callback) {
            if (canNotify('addChannel', callback)) {
                webNotify.addChannel(channel, callback);
            }
        }

        function removeChannel(channel, callback) {
            if (canNotify('removeChannel', callback)) {
                webNotify.removeChannel(channel, callback);
            }
        }

        function listChannels(callback) {
            if (canNotify('listChannels', callback)) {
                webNotify.listChannels(callback);
            }
        }

        function sendMessage(message, callback) {
            if (canNotify('sendMessage', callback)) {
                webNotify.sendMessage(message, callback);
            }
        }

        function getMessages(channel, subchannel, callback) {
            if (canNotify('getMessages', callback)) {
                webNotify.getMessages(channel, subchannel, callback);
            }
        }

        function getUnreadMessages(receiver, channel, subchannel, callback) {
            if (canNotify('getUnreadMessages', callback)) {
                webNotify.getUnreadMessages(receiver, channel, subchannel, function (messages) {
                    callback(undefined, messages);
                });
            }
        }

        function deleteMessage(id, callback) {
            if (canNotify('deleteMessage', callback)) {
                webNotify.deleteMessage(id, callback);
            }
        }

        function receiveMessageNotification(receiver, channel, subchannel, callback) {
            if (canNotify('receiveMessageNotification', callback)) {
                webNotify.receiveMessageNotification(receiver, channel, subchannel, callback);
            }
        }

        function messageReceivedAck(receiver, messageid, callback) {
            if (canNotify('messageReceivedAck', callback)) {
                return webNotify.messageReceivedAck(receiver, messageid, callback);
            }
        }

        function cancelMessageNotification(receiver, callback) {
            if (canNotify('cancelMessageNotification', callback)) {
                webNotify.cancelMessageNotification(receiver, callback);
            }
        }

        function cancelAllMessageNotifications(callback) {
            if (canNotify('cancelAllMessageNotifications', callback)) {
                webNotify.cancelAllMessageNotifications(callback);
            }
        }

        function receiveInboxChanges(receiver, callback) {
            if (canNotify('receiveInboxChanges', callback)) {
                webNotify.receiveInboxChanges(receiver, callback);
            }
        }

        function cancelInboxChanges(receiver, callback) {
            if (canNotify('cancelInboxChanges', callback)) {
                webNotify.cancelInboxChanges(receiver, callback);
            }
        }

        if (available) {
            that.addChannel = addChannel;
            that.cancelAllMessageNotifications = cancelAllMessageNotifications;
            that.cancelInboxChanges = cancelInboxChanges;
            that.cancelMessageNotification = cancelMessageNotification;
            that.deleteMessage = deleteMessage;
            that.getMessages = getMessages;
            that.getUnreadMessages = getUnreadMessages;
            that.listChannels = listChannels;
            that.messageReceivedAck = messageReceivedAck;
            that.receiveMessageNotification = receiveMessageNotification;
            that.receiveInboxChanges = receiveInboxChanges;
            that.removeChannel = removeChannel;
            that.sendMessage = sendMessage;
        }
        return that;
    }

    /**
     * Create a concrete notification from the supplied name
     *
     * @param    name
     *                    String containing the name of the concrete service to create
     *
     * @return    Object containing concrete notification service
     */
    function createNotificationService(callback) {
        var name, that;

        function created(service) {
            mc.notify.service = service;
            callback();
        }

        if ($.isCTTesting) {
            name = 'browser';
        } else if (mc.phonegapPresent() || $.isIphone || $.isIpad) {
            name = 'cordova';
        } else {
            name = 'browser';
        }

        switch (name) {
            case 'cordova':
                that = cordovaNotificationService();
                created(that);
                break;
            case 'browser':
                loadScripts(function () {
                    var platform = WebNotify.createDefaultPlatform(window, document),
                        webNotify = new WebNotify.Service(platform);
                    webNotify.start(function () {
                        that = browserNotificationService(webNotify);
                        created(that);
                    });
                });
                break;
        }

        function loadScripts(callback) {
        	var resourcePath, path = window.locationUtils.getURI().path().replace(/\/?(.*)/, '/$1');
        	if (path.indexOf('mdesign') >= 0) {
        		resourcePath = path.replace(/(.*\/mdesign\/[^/]+)\/.*/i, '$1/resources/' + localStorage.resourceVersion + '/');
        	} else {
        		resourcePath = '/';
        	}
        	loadScript(resourcePath + 'MobileServices.Web-1.2.8.js', function () {
                loadScript(resourcePath + 'web-notify.js', function () {
                    callback();
                });
            });
        }

        function loadScript(url, callback) {
            var script = document.createElement("script");
            script.src = url;
            script.onload = callback;
            document.querySelector('head').appendChild(script);
        }
    }

    /**
     * Attempt to JSON parse the supplied content. If it can't be parsed, return
     * the supplied raw content.
     *
     * @param    content
     *                    String containing content from received message.
     *
     * @return    Object got from JSON parsing the supplied string. If the supplied
     *                    String cannot be parsed then it is returned.
     */
    function parseMessageContent(content) {
        try {
            return $.jsonParse(content);
        } catch (ex) {
            return content;
        }
    }

    ///**
    // * JSON stringify the supplied message content ready for sending
    // *
    // * @param	content
    // *					Object to JSON stringify
    // *
    // * @return	String containing the JSON formmatted object
    // */
    //function stringifyMessageContent(content) {
    //	return $.jsonStringify(content);
    //}

    /**
     * Process the log change notification message content
     *
     * @param    content
     *                    Object containing message content received
     *
     * @return    true to indicate the message has been processed
     */
    function logChangeNotification(content) {
        var a, i, l, level;
        log.info('logchange notification: name: ' + content.name
            + '. logLevel: ' + content.level
            + '. removeAllAppenders: ' + content.removeAllAppenders
            + '. removeAppender: ' + content.removeAppender
            + '. addAppender: ' + content.addAppender);

        if (content.name === 'application') {
            l = window.applog;
        } else if (content.name === 'framework') {
            l = window.log;
        } else {
            log.error('Unable to resolve log name "' + content.name + '" during a log change notification');
        }
        if (l) {
            if (content.level && content.level.constructor === String) {
                level = content.level.toUpperCase();
                if (level === 'ALL' || level === 'TRACE' || level === 'DEBUG' || level === 'INFO' || level === 'WARN' || level === 'ERROR' || level === 'FATAL' || level === 'OFF') {
                    l.setLevel(log4javascript.Level[level]);
                } else {
                    log.error('Unable to set invalid log level "' + content.level + '" during a logchange notification');
                }
            }
            if (content.removeAllAppenders) {
                l.removeAllAppenders();
            }
            if (content.removeAppender && log4javascript.hasOwnProperty(content.removeAppender)) {
                try {
                    a = l.getEffectiveAppenders();
                    if (a && a.length) {
                        for (i = 0; i < a.length; i += 1) {
                            try {
                                if (a[i] instanceof log4javascript[content.removeAppender]) {
                                    l.removeAppender(a[i]);
                                }
                            } catch (ex) {

                            }
                        }
                    }
                } catch (ex) {
                    log.error('Unable to remove invalid appender "' + content.removeAppender + '" during a logchange notification');
                }
            }
            if (content.addAppender && log4javascript.hasOwnProperty(content.addAppender)) {
                try {
                    var appender = new log4javascript[content.addAppender]();
                    if (content.addAppender === 'NotifyLogAppender') {
                        appender.configure(content.responseChannel, content.responseSubchannel, content.responseNotification, content.responseTimeToLive);
                    }
                    l.addAppender(appender);
                } catch (ex) {
                    log.error('Unable to add invalid appender "' + content.addAppender + '" during a logchange notification. ' + ex.message);
                }
            }
        }
        return true;
    }

    /**
     * Process the log state request notification message content
     *
     * @param    content
     *                    Object containing message content received
     *
     * @return    true to indicate the message has been processed
     */
    function logStateRequestNotification(content) {
        var appenders, i, j, logs, message;
        log.info('logstaterequest notification: name: ' + content.name
            + '. responseChannel: ' + content.responseChannel
            + '. responseSubchannel: ' + content.responseSubchannel
            + '. responseNotification: ' + content.responseNotification
            + '. responseTimeToLive: ' + content.responseTimeToLive);
        if (content.responseChannel) {
            if (content.responseSubchannel) {
                if (content.responseNotification) {
                    if (content.responseTimeToLive) {
                        if (content.name === 'application') {
                            logs = [{name: content.name, log: window.applog}];
                        } else if (content.name === 'framework') {
                            logs = [{name: content.name, log: window.log}];
                        } else {
                            logs = [{name: 'application', log: window.applog}, {name: 'framework', log: window.log}];
                        }
                        for (i = 0; i < logs.length; i += 1) {
                            message = {};
                            message.channel = content.responseChannel;
                            message.subchannel = content.responseSubchannel;
                            message.notification = content.responseNotification;
                            message.expiry = (new Date()).addHours(content.responseTimeToLive).getTime();
                            message.content = {};
                            message.content.verb = 'logstateresponse';
                            message.content.name = logs[i].name;
                            message.content.appenders = [];
                            appenders = logs[i].log.getEffectiveAppenders();
                            for (j = 0; j < appenders.length; j += 1) {
                                message.content.appenders.push(appenders[j].toString());
                            }
                            message.content.level = logs[i].log.getEffectiveLevel().name;
                            // message.content = stringifyMessageContent(message.content);
                            mc.notify.service.sendMessage(message);
                        }
                    } else {
                        log.error('Unable to post a log state response due to a missing responseTimeToLive in a logstaterequest notification');
                    }
                } else {
                    log.error('Unable to post a log state response due to a missing responseNotification in a logstaterequest notification');
                }
            } else {
                log.error('Unable to post a log state response due to a missing responseSubchannel in a logstaterequest notification');
            }
        } else {
            log.error('Unable to post a log state response due to a missing responseChannel in a logstaterequest notification');
        }
        return true;
    }

    /**
     * Process the received notification message
     *
     * @param message
     *                    Object containing message received
     * @param    receiver
     *                    Optional string containing the name of the receiver. If not supplied
     *                    the mSute user name will be used if required.
     *
     * @return    true to indicate the message has been processed, otherwise false
     */
    function handleMessage(message, receiver) {
        var content, r;
        r = false;
        if (message.content && message.subchannel === 'system') {
            // content = mc.notify.parseMessageContent(message.content);
            content = message.content;
            if (content) {
                switch (content.verb) {
                    case 'logchange':
                        r = logChangeNotification(content);
                        break;
                    case 'logstaterequest':
                        r = logStateRequestNotification(content);
                        break;
                    default:
                        break;
                }
            }
        } else {
            // The subchannel should be a processId here.
            // No spec yet as to what we should do here.
        }
        if (r) {
            mc.notify.service.deleteMessage(message.id);
        }
        return r;
    }

    function sendLogMessage(logName, level, data, config) {
        var message;
        //console.log('mc.notify.sendLogMessage(' + logName + ', ' + level + ', ' + data + ', ' + JSON.stringify(config) + ')');
        if (config && config._channel && config._subchannel && config._notification && config._timeToLive) {
            message = {};
            message.channel = config._channel;
            message.subchannel = config._subchannel;
            message.notification = config._notification;
            message.expiry = (new Date()).addHours(config._timeToLive).getTime();
            message.content = {};
            message.content.verb = 'logmessage';
            message.content.name = logName;
            message.content.level = level;
            message.content.message = data;
            // message.content = stringifyMessageContent(message.content);
            mc.notify.service.sendMessage(message);
        }
    }

    mc.notify = mc.notify || {};
    mc.notify.createNotificationService = createNotificationService;
    mc.notify.handleMessage = handleMessage;
    mc.notify.parseMessageContent = parseMessageContent;
    mc.notify.sendLogMessage = sendLogMessage;
    // mc.notify.stringifyMessageContent: stringifyMessageContent

}(window.jmfw, window.mCapture));
/*
 ** END OF MC2.NOTIFY.JS
 */
﻿(function($, mc) {

    var maxThumbWidth = 320,
        maxThumbHeight = 200,
        thumbQuality = 50;

    function getThumbnail(fileUri, callback) {
        function error(e) {
            log.error('Error generating thumbnail: ' + JSON.stringify(e));
        }

        if (window.plugins && window.plugins.thumbnail) {
            window.plugins.thumbnail.getThumbnail(fileUri, maxThumbWidth, maxThumbHeight, thumbQuality, callback, error);
        } else {
            callback(fileUri);
        }
    }

    function getAttachmentData(subjectGuid, name, callback) {
        if (mc.fs.availableForAtts) {
            mc.fs.getAttachmentData(subjectGuid, name, callback);
        } else {
            mc.db.getAttachment(subjectGuid, name, callback);
        }
    }

    function getAttachment(subjectGuid, name, callback) {
        if (mc.fs.availableForAtts) {
            mc.fs.getAttachmentPath(subjectGuid, name, function(fileUri) {
                getThumbnail(fileUri, callback);
            });
        } else {
            mc.db.getAttachment(subjectGuid, name, callback);
        }
    }

    function setAttachment(subjectGuid, name, data, markChanged, callback) {
        if (mc.fs.availableForAtts) {
            data = '';
        }
        mc.db.setAttachment(subjectGuid, name, data, markChanged, callback);
    }
    
    function duplicateAttachment(oldSubjectGuid, oldName, newSubjectGuid, newName, callback) {
        if (mc.fs.availableForAtts) {
            function success() {
                callback();
            }
            function error(e) {
                callback('Failed to duplicate attachment: ' + e.toString());
            }
            mc.fs.duplicateAttachment(oldSubjectGuid, oldName, newSubjectGuid, newName, success, error);
        } else {
            mc.db.getAttachment(oldSubjectGuid, oldName, function(data) {
                mc.db.setAttachment(newSubjectGuid, newName, data, false, callback);
            });
        }
    }

    mc.att = {
        getThumbnail: getThumbnail,
        getAttachmentData: getAttachmentData,
        getAttachment: getAttachment,
        setAttachment: setAttachment,
        duplicateAttachment: duplicateAttachment
    };


} (window.jmfw, window.mCapture));/*jslint browser: true, devel: true, bitwise: true, continue: true, evil: true, forin: true, nomen: true, plusplus: true, regexp: true, sloppy: true, todo: true, white: true */
(function($, mc) {


    /**
    * Shows the activity indicator
    */
    function activityStart() {
        mc.showActivity();
    }

    /**
    * Hides the activity indicator if the internal activity count drops to 0 or
    * if the force parameter is true.
    *
    * @param force
    *         optional boolean indicating whether the hide activity should be
    *         forcefully removed
    */
    function activityStop(force) {
        mc.hideActivity(force);
    }

    /**
    * Returns a new Error object with the name & message properties set to the
    * supplied parameters
    * 
    * @param name
    *          text to set the name property of the created Error object to.
    * @param message
    *          text to set the message property of the created Error object to.
    * @return new Error object.
    */
    function makeError(name, message) {
        var e = new Error(message);
        e.name = name;
        return e;
    }

    /**
    * Returns a new Error object
    */
    function argumentCountError(message) {
        return makeError('argumentCountError', message);
    }

    /**
    * Returns a new Error object
    */
    function argumentTypeError(message) {
        return makeError('argumentTypeError', message);
    }

    /**
    * Returns a boolean indicating whether the supplied args array has the
    * correct number items in and optionally if they are of the correct type
    * 
    * @private
    * @param args
    *          array of arguments to be validated.
    * @param name
    *          name of function which will process supplied args once validated.
    * @param min
    *          the minimum number of arguments that should be in supplied args
    *          array.
    * @param max
    *          the maximum number of arguments that should be in supplied args
    *          array.
    * @param types
    *          optional array of constructors denoting the types of values which
    *          should be in the args array.
    * @return true if the supplied args array is valid, otherwise false.
    */
    function validateArgs(args, name, min, max, types) {
        var e, i;
        i = 0;
        if (args.length < min) {
            throw argumentCountError('Too few arguments in function "' + name
					+ '". Requires between ' + min + ' and ' + max);
        }
        if (args.length > max) {
            throw argumentCountError('Too many arguments in function "' + name
					+ '". Requires between ' + min + ' and ' + max);
        }
        if (types !== undefined) {
            for (i = 0; i < args.length; i += 1) {
                if (types[i] !== null && types[i] !== undefined) {
                    if (args[i] === undefined && i >= min) {
                        continue;
                    }
                    if (args[i] === null || args[i] === undefined ||
							args[i].constructor !== types[i]) {
                        e = 'Incorrect argument type in function "' + name + '". Argument: '
							+ (i + 1) + '  actual: ';
                        if (args[i] === null) {
                            e += 'null';
                        } else if (args[i] === undefined) {
                            e += 'undefined';
                        } else {
                            e += mc.getobjectclass(args[i]) + ' - object = ' + args[i].constructor;
                        }
                        e += '  expected: ' + types[i].name;
                        throw argumentTypeError(e);
                    }
                }
            }
        }
    }

    /**
    * Displays an alert or confirm box and returns user choice.
    * 
    * @param message
    *          message to be displayed.
    * @param title
    *          optional title of message box.
    * @param buttons
    *          optional, 0 for OK, 1 for OK & Cancel.
    * @param icon
    *          ignored.
    * @param defaultButton
    *          ignored.
    * @return true if user clicked OK, false otherwise.
    */
    function msgBox(message, title, buttons, icon, defaultButton) {
        var result, text, u;
        validateArgs(arguments, "msgBox", 1, 5, [String, String, Number, null,
				null]);
        text = (title !== undefined ? title : 'MDC') + '\n' + message;
        if (buttons === undefined || buttons === 0) {
            alert(text);
            return true;
        }
        result = confirm(text);
        switch (buttons) {
            case 0: //OK
                return 0; //OK
            case 1: //OKCANCEL
                if (result) {
                    return 0; //OK
                }
                return 2; //CANCEL
            case 2: //ABORTRETRYIGNORE
                alert("Unsupported ABORTRETRYIGNORE");
                return 3; //ABORT
            case 3: //YESNOCANCEL
                alert("Unsupported YESNOCANCEL");
                return 2; //CANCEL
            case 4: //YESNO
                if (result) {
                    return 6; //YES
                }
                return 7; //NO
            case 5: //RETRYCANCEL
                if (result) {
                    return 4; //RETRY
                }
                return 2; //CANCEL
        }
        u = icon;
        u = defaultButton;
    }

    /**
    * Returns the value of the answer of the supplied question.
    * 
    * @private
    * @param callback - object to receive the value of the answer
    * @param pageId
    *						string containing the pageId
    * @param questionId
    *						string containing questionId
    * @param index
    *						optional index for array answers
    * @param columnId
    *						optional string containing the column id for column answers
    * @param ignoreDefault
    *						optional boolean indicating whether the default answer should be
    *						obtained if the real answer is undefined.
    */
    function getAnswer(callback, dataId, pageId, questionId, index, columnId, ignoreDefault) {
        var designData, i, process, value;
        function gotValue(value) {
            if (value && columnId) {
                if (value.constructor === Array) {
                    designData = designData || process.questions[dataId];
                    if (designData && designData.columns && designData.columns.constructor === Array) {
                        for (i = 0; i < designData.columns.length; i += 1) {
                            if (designData.columns[i].id && designData.columns[i].id === columnId) {
                                value = value[i];
                                break;
                            }
                        }
                        if (i >= designData.columns.length) {
                            value = undefined;
                        }
                    } else {
                        value = undefined;
                    }
                } else {
                    value = undefined;
                }
            }
            callback.resume(value);
        }
        function gotDefaultValue(value) {
            if (value !== undefined) {
                mc.db.setValue(dataId, value, index, designData.stamps);
            }
            gotValue(value);
        }
        process = mc.db.getCurrentProcess();
        if (!dataId) {
            if (process.pages[pageId] === undefined) {
                msgBox('Page [' + pageId + "] not found (id's are case sensitive)", "Error", 0);
                return gotValue(undefined);
            }
            if (process.pages[pageId].qIdMap[questionId] === undefined) {
                msgBox('Question [' + questionId + '] on page [' + pageId + "] not found (id's are case sensitive)", "Error", 0);
                return gotValue(undefined);
            }
            dataId = process.pages[pageId].qIdMap[questionId];
        }
        value = mc.db.getValue(dataId, index);
        if (value === undefined && ignoreDefault !== true) {
            designData = process.questions[dataId];
            if (designData) {
                value = designData.defval;
                if (value && value.constructor === Function) {
                    value(gotDefaultValue);
                } else {
                    gotDefaultValue(value);
                }
            } else {
                gotValue(value);
            }
        } else {
            gotValue(value);
        }
    }

    /**
    * Returns a reference to a file containing the answer to an image/photo question
    * 
    * @private
    * @param callback - object to receive the value of the answer
    * @param subjectGuid
    *						string containing the subjectGuid
    * @param dataId
    *						string containing questions dataId
    * @param index
    *						optional index for array answers
    * @param columnId
    *						optional string containing the grid question's dataId for row answers
    */
    function getFileReference(callback, subjectGuid, dataId, index, columnId, context) {

        function done(result) {
            if (callback.constructor === Function) {
                callback(result);
            } else {
                callback.resume(result);
            }
        }

        function onSuccess(path) {
            /*
            * Internal Draft Spec V2.4
            * Internally, if the context is defined then the GetFileReference appends �#� 
            * and the stringified version of context to the return value.
            */
            var contextString;
            if (context === undefined) {
                done('#fileref:' + path);
            } else {
                try {
                    contextString = JSON.stringify(context);
                } catch (e) {
                    contextString = context.toString();
                }
                done('#fileref:' + path + '#' + contextString);
            }
        }

        function onError(error) {
            log.error('Unable to get file reference: ' + JSON.stringify(error));
            done(null);
        }

        function gotData(name) {
            if (name) {
                mc.fs.getAttachmentPath(subjectGuid, name, onSuccess, onError);
            } else {
                done(null);
            }
        }

        validateArgs(arguments, "getFileReference", 3, 6, [null, String, String, Number, String, null]);
        if (mc.fs.availableForAtts) {
            dskData(gotData, subjectGuid, dataId, index, columnId);
        } else {
            done(null);
        }
    }

    /**
    * Attaches the referenced file as the answer to an image/photo question
    * 
    * @private
    * @param callback - object to receive the value of the answer
    * @param fileReference
    *						string containing the fileReference
    * @param subjectGuid
    *						string containing the subjectGuid
    * @param dataId
    *						string containing questions dataId
    * @param index
    *						optional index for array answers
    * @param columnId
    *						optional string containing the grid question's dataId for row answers
    */
    function attachFileByReference(callback, fileReference, subjectGuid, dataId, index, columnId) {
        function done() {
            if (callback.constructor === Function) {
                callback();
            } else {
                callback.resume();
            }
        }

        function copySuccess(attachmentName) {
            function attachmentSet() {
                done();
            }
            function answerSet() {
                mc.db.setAttachment(subjectGuid, attachmentName, '', true, done);
            }
            dskSetData({ resume: answerSet }, subjectGuid, columnId || dataId, attachmentName, index, false);
        }

        function copyError(error) {
            log.error('failed to attach file reference ' + fileReference + ' - ' + JSON.stringify(error));
            done();
        }

        validateArgs(arguments, "attachFileByReference", 4, 6, [null, null, String, String, Number, String]);
        var fileRefPrefix = '#fileref:';
        if (typeof (fileReference) === 'string' && fileReference.indexOf(fileRefPrefix) === 0) {
            var filePath = fileReference.substr(fileRefPrefix.length);
            if (filePath) {
                var name = mc.db.guid();
                mc.fs.copyFileAsAttachment(filePath, subjectGuid, copySuccess, copyError);
            } else {
                done();
            }
        } else {
            done();
        }
    }
    /**
    * Execute the named JS function in the mc.fl object asynchronously 
    *
    * @param callback
    *					object to receive the value of the answer
    * @param name
    *					string containing the name of the mc.fl method
    * @params
    *					all further params get passed to the supplied function
    */
    function execJsAsync(callback, name) {
        var i, params;
        if (name && mc.fl[name] !== undefined && mc.fl[name].constructor === Function) {
            params = [];
            for (i = 2; i < arguments.length; i += 1) {
                params.push(arguments[i]);
            }
            mc.fl[name](callback, params);
        } else {
            callback.resume('Function ' + name + ' not found.');
        }
    }

    /**
    * Execute the named JS function in the mc.fl object synchronously 
    *
    * @param name
    *					string containing the name of the mc.fl method
    * @params
    *					all further params get passed to the supplied function
    * @return
    *					return value of supplied function name
    */
    function execJsSync(name) {
        var i, params;
        if (name && mc.fl[name] !== undefined && mc.fl[name].constructor === Function) {
            params = [];
            for (i = 1; i < arguments.length; i += 1) {
                params.push(arguments[i]);
            }
            return mc.fl[name](params);
        }
        return 'Function ' + name + ' not found.';
    }
    /**
    * Execute the JS text synchronously 
    *
    * @param script
    *					string containing the script method
    */
    function execJsText(script) {
        //debugger;
        if (script) {
            eval(script);
        }
    }

    /**
    * Returns the design data of the supplied question.
    * 
    * @private
    * @param page
    *          jQuery object wrapping the DOM page element OR dataId of question
    *          if 2nd param (question) is undefined
    * @param question
    *          jQuery object wrapping the DOM question element OR undefined,
    *          meaning that page is a dataId
    * @return the value of the answer.
    */
    function getDesignData(page, question) {
        var designData, q;
        if (question === undefined) {
            designData = mc.q.designData(page);
        } else {
            q = mc.q(page, question);
            if (q) {
                designData = q.designData();
            }
        }
        return designData;
    }

    /**
    * Returns the value of the answer of the supplied question.
    * 
    * @param callback - function to receive the value of the answer
    * @param pageId
    * @param id1 - questionId if id2 is undefined, columnId if id2 is not undefined
    * @param index
    * @param id2 - questionId or undefined
    * @param ignoreDefault
    */
    function ans(callback, pageId, id1, index, id2, ignoreDefault) {
        var pid, qid1, qid2, v;
        function ansCallback(value) {
            callback.resume(value);
        }
        validateArgs(arguments, "ans", 3, 6, [null, String, String, Number, String, Boolean]);
        pid = pageId.replace(' ', '_');
        qid1 = id1.replace(' ', '_');
        if (id2) {
            v = qid1;
            qid1 = id2.replace(' ', '_');
            qid2 = v;
        }
        getAnswer({ resume: ansCallback }, undefined, pid, qid1, index, qid2, ignoreDefault);
    }

    /**
    * Return the low subset from the supplied array
    *
    * @param	a
    *					array to extract from
    * @param	n
    *					number of elements to extract
    *
    * @return	array containing the extraction
    */
    function bottom(a, n) {
        validateArgs(arguments, "bottom", 2, 2, [Array, Number]);
        return a.slice(0, n);

    }

    /**
    * Checks of the supplied question has an answer.
    * 
    * @param pageId
    *          not required, legacy from Windows Mobile implementation.
    * @param id1
    * @param index
    * @param id2
    * @return true if the supplied question contains an answer, otherwise false.
    */
    function isAnswered(callback, pageId, id1, index, id2) {
        validateArgs(arguments, "isanswered", 3, 5, [null, String, String, Number, String]);
        function ansCallback(value) {
            if (value === undefined || value === null) {
                callback.resume(false);
                return;
            } else if (typeofObject(value) === "array") {
                //array returned if empty its not answered
                if (value.length === 0) {
                    callback.resume(false);
                    return;
                } else {
                    callback.resume(true);
                    return;
                }
            }
            callback.resume(value.toString() !== '');
        }
        ans({ resume: ansCallback }, pageId, id1, index, id2, true);
    }

    /**
    * Checks if the supplied argument is a boolean.
    * 
    * @param test
    *          item to test.
    * @return true if the supplied argument is a boolean, otherwise false.
    */
    function isBoolean(test) {
        validateArgs(arguments, "isBoolean", 1, 1);
        try {
            return test.constructor === Boolean;
        } catch (e) {
            return false;
        }
    }
    /**
    * Returns device orientation
    *
    * @return one of:
    *   "p"
    *   "l"    
    */
    function getOrientation() {

        if (window.orientation !== undefined && (window.orientation == 90 || window.orientation == -90))
            return "l";

        return "p";
    }
    /**
    * Returns whether device is connected on Wifi
    *
    * @return	true if device is on wifi, false if not
    */
    function canConnectViaWifi() {
        if (typeof navigator.network == 'undefined') {
            return navigator.onLine;
        }
        var networkState = navigator.connection.type;
        return networkState == Connection.WIFI;
    }

    /**
    * Returns a platform string
    *
    * @return one of:
    *   "android"
    *   "blackberry"
    *   "iphone"
    */
    function getPlatform() {
        var currentProcess = mc.db.getCurrentProcess();
        if (typeof currentProcess.devPlatform != 'undefined' && currentProcess.devPlatform != '') {
            return currentProcess.devPlatform.toLowerCase();
        }

        if (typeof device != 'undefined') {
            return device.platform.toLowerCase(); ;
        }

        var agent = navigator.userAgent.toLowerCase();

        if (agent.indexOf("iphone") >= 0) {
            return "iphone";
        }

        if (agent.indexOf("android") >= 0) {
            return "android";
        }

        if (agent.indexOf("blackberry") >= 0) {
            return "blackberry";
        }

        if (agent.indexOf("windows") >= 0) {
            return "windows";
        }

        return "unknown";
    }

    /**
    * Returns whether client is unrestricted
    *
    * @return "r" or "u"
    *
    */
    function getCodeType() {

        var currentProcess = mc.db.getCurrentProcess();
        if (typeof currentProcess.devClient != 'undefined' && currentProcess.devClient != '') {
            return currentProcess.devClient.toLowerCase();
        }
        if (typeof device != 'undefined') {
            //phonegap is present so must be unrestricted
            return "u";
        }

        var agent = navigator.userAgent.toLowerCase();

        if (agent.indexOf("ctshell") >= 0) {
            return "u";
        }

        return "r";
    }

    /**
    * Returns whether client is tablet or normal
    *
    * @return "t" or "n"
    *
    */
    function getFormatType() {
        var currentProcess = mc.db.getCurrentProcess();
        if (typeof currentProcess.devFormat != 'undefined' && currentProcess.devFormat != '') {
            return currentProcess.devFormat.toLowerCase();
        }

        var agent = navigator.userAgent.toLowerCase();

        // Special cases:
        if (agent.indexOf("xoom") >= 0)
            return "t";

        if (agent.indexOf("android") >= 0 && (agent.indexOf("sch-i") >= 0 || agent.indexOf("gt-") >= 0 || agent.indexOf("kindle fire")))
            return "t";

        if (agent.indexOf("ipad") >= 0)
            return "t";

        if (agent.indexOf("android") >= 0 && agent.indexOf("mobile") < 0)
            return "t";

        return "n";
    }

    /**
    * Returns whether the connection is as fast as specified
    * 
    * @param connectionType - minimum connection type (string from phonegap API, "3g", "wifi" etc.
    * @return	true if device is connected at at least the specified connection type.
    */
    function canConnectAtLeast(connectionType) {

        log.info('canConnectAtLeast : ' + connectionType);

        if (typeof navigator.connection == 'undefined') {
            log.info('canConnectAtLeast : navigator.connection undefined - returning online = ' + navigator.onLine);
            return navigator.onLine;
        }


        var networkState = navigator.connection.type;
        log.info('canConnectAtLeast : ' + networkState);

        if (networkState == Connection.ETHERNET)
            return true;

        if (connectionType == Connection.WIFI)
            if (networkState == Connection.WIFI)
            return true;

        if (Connection.CELL === undefined) {

            if (connectionType == Connection.CELL_4G)
                if (networkState == Connection.WIFI || networkState == Connection.CELL_4G)
                return true;

            if (connectionType == Connection.CELL_3G)
                if (networkState == Connection.WIFI || networkState == Connection.CELL_4G || networkState == Connection.CELL_3G)
                return true;

            if (connectionType == Connection.CELL_2G)
                if (networkState == Connection.WIFI || networkState == Connection.CELL_4G || networkState == Connection.CELL_3G || networkState == Connection.CELL_2G)
                return true;

        } else {
            //CELL: "cellular", is available in cordova, but only seems to be used by WP8 which doesnt know what level it is
            if (connectionType == Connection.CELL_4G)
                if (networkState == Connection.WIFI || networkState == Connection.CELL_4G || networkState == Connection.CELL)
                return true;

            if (connectionType == Connection.CELL_3G)
                if (networkState == Connection.WIFI || networkState == Connection.CELL_4G || networkState == Connection.CELL_3G || networkState == Connection.CELL)
                return true;

            if (connectionType == Connection.CELL_2G)
                if (networkState == Connection.WIFI || networkState == Connection.CELL_4G || networkState == Connection.CELL_3G || networkState == Connection.CELL_2G || networkState == Connection.CELL)
                return true;

            if (connectionType == Connection.CELL)
                if (networkState == Connection.WIFI || networkState == Connection.CELL_4G || networkState == Connection.CELL_3G || networkState == Connection.CELL_2G || networkState == Connection.CELL)
                return true;
        }

        log.info('canConnectAtLeast : no');
        return false;
    }

    /**
    * Tests whether the mDesign server is reachable
    * 
    * @param callback - callback function to call on completion (takes one boolean - true if reachable false if not.
    * @param timeout - time (ms) to wait before considering it a failiure.  (default 5 seconds)
    *
    */
    function isReachable(callback, timeout) {

        var url, finished;

        function success() {
            if (!finished) {
                finished = true;
                if (typeof (callback) == "function")
                    callback(true);
                else
                    callback.resume(true);
            }
        }

        function error() {
            if (!finished) {
                finished = true;
                if (typeof (callback) == "function")
                    callback(false);
                else
                    callback.resume(false);
            }
        }

        function connect(serverUrl) {

            if (timeout === undefined) {
                timeout = 5000;
            }

            if (serverUrl) {
                url = serverUrl.trim().replace(/\/+$/, '') + "/mdesign/0/iphone-shell/settings.plist";
            } else {
                url = "/mdesign/0/iphone-shell/settings.plist";
            }

            jQuery.ajax({
                url: url,
                timeout: timeout
            }).done(function() {
                success();
            }).fail(function() {
                error();
            });
        }

        finished = false;

        if (!canConnectAtLeast('2g')) {
            error();
        } else {
            if (window.plugins && window.plugins.settings) {
            	window.plugins.settings.getURL(connect, function () { log.debug('canConnectAtLeast : Unable to get url'); error("Unable to get server URL") });
            } else {
                connect();
            }
        }
    }

    /**
    * Tests whether there is a replication currently in progress
    *
    * @return	true if there is a replication currently in progress, false 
    *					otherwise
    */
    function isReplicating() {
        return mc.repl.isReplicating();
    }

    /**
    * Tests whether this instance of the client is restricted or unrestricted
    *
    * @return	true for restricted otherwise false
    */
    function isRestricted() {
        return !mc.unrestricted;
    }

    /**
    * Checks if the supplied argument is a Date
    * 
    * @param test
    *          item to test.
    * @return true if the supplied argument is a Date, otherwise false.
    */
    function isDateTime(test) {
        validateArgs(arguments, "isDateTime", 1, 1);
        try {
            return test.constructor === Date;
        } catch (e) {
            return false;
        }
    }

    /**
    * Checks if the supplied argument is a Error
    * 
    * @param test
    *          item to test.
    * @return true if the supplied argument is an Error, otherwise false.
    */
    function isError(test) {
        validateArgs(arguments, "isError", 1, 1);
        try {
            return test.constructor === Error;
        } catch (e) {
            return false;
        }
    }

    /**
    * Checks if the question matching the supplied pageId, questionId is hidden
    * 
    * @param pageId
    * @param questionId
    * @return true if the question is hidden
    */
    function isHidden(pageId, questionId) {
        validateArgs(arguments, "isHidden", 2, 2, [String, String]);
        return mc.q.isHidden(pageId + questionId);
    }

    /**
    * Checks if the supplied argument is an array
    * 
    * @param test
    *          item to test.
    * @return true if the supplied argument is an array, otherwise false.
    */
    function isList(test) {
        validateArgs(arguments, "isList", 1, 1);
        try {
            return test.constructor === Array;
        } catch (e) {
            return false;
        }
    }

    /**
    * Checks if the supplied argument is null
    * 
    * @param test
    *          item to test.
    * @return true if the supplied argument is null, otherwise false.
    */
    function isNull(test) {
        validateArgs(arguments, "isNull", 1, 1);
        try {
            return test === null;
        } catch (e) {
            return false;
        }
    }

    /**
    * Checks if the supplied argument is a number
    * 
    * @param test
    *          item to test.
    * @return true if the supplied argument is a number, otherwise false.
    */
    function isNumber(test) {
        validateArgs(arguments, "isNumber", 1, 1);
        try {
            return test.constructor === Number;
        } catch (e) {
            return false;
        }
    }

    /**
    * Checks if the supplied argument is a string
    * 
    * @param test
    *          item to test.
    * @return true if the supplied argument is a string, otherwise false.
    */
    function isText(test) {
        validateArgs(arguments, "isText", 1, 1);
        try {
            return test.constructor === String;
        } catch (e) {
            return false;
        }
    }

    /**
    * Checks if the question matching the supplied pageId, questionId is an xml
    * data set
    * 
    * @param dataId
    * @return true if the question is xml data set
    */
    function isXmlDataSet(dataId) {
        var b, designData;
        validateArgs(arguments, "isXmlDataSet", 1, 1, [String]);
        designData = getDesignData(dataId);
        if (designData !== undefined) {
            b = !!designData.xmlName;
        } else {
            b = false;
        }
        return b;

        /*
        pageId = pageId.replace(' ', '_');
        questionId = pageId + questionId.replace(' ', '_');
        q = mc.q(pageId, questionId);
        if (q) {
        b = !!q.getDesignValue('xmlName');
        } else {
        b = false;
        }
        return b;
        */
    }

    function calculate(callback, dataId) {
        execJsAsync(callback, 'fn_' + dataId.toLowerCase());
    }

    /**
    * Returns a string containing a comma separated list of the choice labels
    * from the answer to the supplied question
    * 
    * @param callback - function to receive the String containing a comma separated list of the choice labels
    * @param pageId
    * @param questionId
    */
    function choicesToText(pageId, questionId) {
        var answer, dataId, designData, i, j, n, result, question;
        pageId = pageId.replace(' ', '_');
        questionId = pageId + questionId.replace(' ', '_');
        result = '';
        question = mc.q(pageId, questionId);
        if (question) {
            dataId = question.getDataId();
            designData = getDesignData(dataId);
            if (designData !== undefined && designData.choices !== undefined && designData.choices.constructor === Array) {
                n = designData.choices.length;
                answer = mc.db.getValue(dataId);
                if (answer !== undefined && answer !== null) {
                    switch (answer.constructor) {
                        case Array:
                            result = [];
                            for (i = 0; i < answer.length; i += 1) {
                                for (j = 0; j < n; j += 1) {
                                    if (answer[i] === designData.choices[j].value) {
                                        result.push(designData.choices[j].label);
                                        break;
                                    }
                                }
                            }
                            result = result.join(', ');
                            break;
                        case String:
                            for (i = 0; i < n; i += 1) {
                                if (answer === designData.choices[i].value) {
                                    result = designData.choices[i].label;
                                    break;
                                }
                            }
                            break;
                    }
                }
            }
        }
        return result;
    }

    /**
    * Sets the value of the answer of the supplied question.
    * 
    * @private
    * @param dataId
    *          optional string containing the data Id. If this is missing, pageId
    *					questionId are used to calculate the dataId
    * @param pageId
    *          optional string containing the page Id. Ignored if dataId is supplied
    * @param questionId
    *          optional string containing the question Id. Ignored if dataId is supplied
    * @param answer
    *          the value of the answer.
    * @param index
    *          the index of the answer for array questions.
    */
    function setAnswer(dataId, pageId, questionId, answer, index) {
        var designData, process, stamp;
        process = mc.db.getCurrentProcess();
        if (!dataId) {
            dataId = process.pages[pageId].qIdMap[questionId];
        }
        stamp = false;
        designData = process.questions[dataId];
        if (designData !== undefined) {
            stamp = designData.stamps;
        }
        mc.db.setValue(dataId, answer, index, stamp);
    }
	
	/**
    * Sets the value of the answer of the supplied question, passes on the callback
    * 
    * @private
	* @param callback
	*			Callback to call on completion
    * @param dataId
    *          optional string containing the data Id. If this is missing, pageId
    *					questionId are used to calculate the dataId
    * @param pageId
    *          optional string containing the page Id. Ignored if dataId is supplied
    * @param questionId
    *          optional string containing the question Id. Ignored if dataId is supplied
    * @param answer
    *          the value of the answer.
    * @param index
    *          the index of the answer for array questions.
    */
    function setAnswerAsync(callback, dataId, pageId, questionId, answer, index) {
        var designData, process, stamp;
        process = mc.db.getCurrentProcess();
        if (!dataId) {
            dataId = process.pages[pageId].qIdMap[questionId];
        }
        stamp = false;
        designData = process.questions[dataId];
        if (designData !== undefined) {
            stamp = designData.stamps;
        }
        mc.db.setValue(dataId, answer, index, stamp, function() {
			if( callback && callback.constructor == Function )
				callback();
			if( callback && callback.resume )
				callback.resume();
		});
    }

    /**
    * Saves null as the value for the supplied question.
    * 
    * @param pageId
    * @param questionId
    * @return true
    */
    function clearAns(pageId, questionId, index) {
        var pid, qid;
        validateArgs(arguments, "ans", 2, 3, [String, String, Number]);
        pid = pageId.replace(' ', '_');
        qid = questionId.replace(' ', '_');
        setAnswer(undefined, pid, qid, null, index);
        return true;
    }

    /**
    * Saves null as the value for the supplied question.
    * 
    * @param dataId
    * @param index
    * @return true
    */
    function clearData(callback, dataId, index) {
        validateArgs(arguments, "cleardata", 2, 3, [null, String, Number]);
        setAnswerAsync(callback, dataId, undefined, undefined, null, index);
        return true;
    }

    /**
    * Initiate a replication
    *
    * @param	callback
    *					Object to perform asynchronous formula callbacks
    * @param	processId
    * @param profileAlias
    * @param title
    * @param	url
    * @param	timeout
    *
    * @return	The final return value will from the callback object
    */
    function replicateDialog(callback, processId, profileAlias, title, url, timeout) {
        var s;
        if (!mc.repl.isReplicating()) {
            if (!mc.getPreNotifyCount()) {
                mc.replInfo = {
                    callback: callback,
                    processId: processId,
                    profileAlias: profileAlias,
                    title: title,
                    url: url,
                    timeout: timeout,
                    page: mc.currentPage()
                };
                $.ui.gotoPage($('#replicatePage'), 'jmuiSlide');
            } else {
                s = 'Cannot start a replication while there are currently running pre-notifications';
                log.error(s);
                window.alert(s);
                callback.resume(false);
            }
        } else {
            s = 'Cannot start a replication while another replication is in progress';
            log.error(s);
            window.alert(s);
            callback.resume(false);
        }
    }

    /**
    * Perform a full replication
    * 
    * @param callback
    *          callback function to call when complete
    * 
    */
    function replicate(callback) {
        var s, title, url, timeout;
        function complete(success) {
            if (callback.constructor === Function) {
                callback(success);
            } else {
                callback.resume(success);
            }
            delete mc.replInfo;
        }
        if (!mc.repl.isReplicating()) {
            if (!mc.getPreNotifyCount()) {
                title = 'replicate';
                url = '';
                timeout = 120;

                mc.replInfo = {
                    callback: callback,
                    processId: 'all',
                    profileAlias: 'defaultRepProfile',
                    title: title,
                    url: url,
                    timeout: timeout
                };

                activityStart();
                mc.repl.replicate(function(success) {
                    activityStop();
                    if (success !== window.ReplicationResult.Completed) {
                        mc.msgBox(function() { complete(success); }, "Failed to complete replication", "Error:", 'OK');
                    }
                    else {
                        complete(success);
                    }
                }, mc.replInfo);
            } else {
                s = 'Cannot start a replication while there are currently running pre-notifications';
                log.error(s);
                window.alert(s);
                callback.resume(false);
            }
        } else {
            s = 'Cannot start a replication while another replication is in progress';
            log.error(s);
            window.alert(s);
            callback.resume(false);
        }
    }

    /**
    * Clear DB & localStorage then initiate a replication
    *
    * @param	callback
    *					Object to perform asynchronous formula callbacks
    * @param	processId
    * @param	profileAlias
    * @param	title
    * @param	url
    * @param	timeout
    */
    function clearDbAndReplicate(callback, processId, profileAlias, title, url, timeout) {
        var s, userInfo;
        if (!mc.repl.isReplicating()) {
            if (!mc.getPreNotifyCount()) {
                mc.msgBox(function(text) {
                    if (text === 'Yes') {
                        //should this use a call to isOurShell() ??
                        if (window.cordova && window.cordova.exec && window.plugins && window.plugins.settings) {
                            window.plugins.settings.getClearURL(function(clearUrl) {
                                var separator = clearUrl.indexOf('?') === -1 ? '?' : '&';
                                window.locationUtils.setHref(clearUrl + separator + "newGuid=yes&replicate=true&processId=" + processId + "&profileAlias=" + encodeURIComponent(profileAlias) + "&title=" + encodeURIComponent(title) + "&url=" + encodeURIComponent(url) + "&timeout=" + timeout);
                            });
                        } else {
                            window.locationUtils.setHref(mc.getRootPath() + "mdesign/0/procs/clear.html?replicate=true&newGuid=yes&processId=" + processId + "&profileAlias=" + encodeURIComponent(profileAlias) + "&title=" + encodeURIComponent(title) + "&url=" + encodeURIComponent(url) + "&timeout=" + timeout);
                        }
                    }
                }, 'Confirm', 'Clear all data?', 'Yes', 'No');
            } else {
                s = 'Cannot start a replication while there are currently running pre-notifications';
                log.error(s);
                window.alert(s);
                callback.resume(false);
            }
        } else {
            s = 'Cannot start a replication while another replication is in progress';
            log.error(s);
            window.alert(s);
            callback.resume(false);
        }
    }

    /**
    * Sets a named value on the current subject
    *
    * @param	name
    *					String containing the name of the item to set
    * @param	value
    *					String or Object containing the value of the item to set
    *
    */
    function setSubjectValue(callback, name, value, noTouch) {
        var dbCallback;
        if (noTouch !== true) {
            noTouch = false; // Default is to touch if noTouch is undefined or null, etc...
        }
        if (callback && callback.hasOwnProperty('resume')) {
            dbCallback = function() {
                callback.resume();
            };
        }
        mc.db.setMetaValue(name, value, noTouch, dbCallback);
    }

    /**
    * Empties  the page stack
    */
    function clearPageStack() {
        setSubjectValue(undefined, 'pageStack', [], true);
    }

    /**
    * Empties  the subject stack
    */
    function clearSubjectStack() {
        mc.db.setJsonItem('subjectStack', []);
    }

    /**
    * Clone the subject with the matching guid
    *
    * @param callback
    *					object to receive the cloned subject	 
    * @param	guid
    *					string containing the guid of the subject to clone OR object containing
    *					the subject to clone
    * @param	persist
    *					boolean indicating whether the cloned subject should persist or not
    */
    function cloneSubject(callback, guid, persist) {
        function cloned(subject) {
            callback.resume(subject);
        }
        mc.db.cloneSubject(guid, persist, cloned);
    }

    /**
    * Returns the current subject ID
    * 
    * @return current subject
    */
    function currentSubjectGuid() {
        var guid;
        guid = mc.db.getCurrentSubjectGuid();
        return guid;
    }

    /**
    * Clone the current subject
    *
    * @param callback
    *					object to receive the cloned subject	 
    * @param	persist
    *					boolean indicating whether the cloned subject should persist or not
    */
    function cloneCurrentSubject(callback, persist) {
        return cloneSubject(callback, currentSubjectGuid(), persist);
    }

    /**
    * Combine static & dynamic choices into a single array and optionally sort it
    *
    * @param callback - object called back to receive the combined choices array
    * @param	staticChoices - optional array of choice objects
    * @param dynamicChoices - optional function to retrieve dynamic choices or array of choices
    * @param	sort - boolean indicating whether to sort the combined choices array
    */
    function combineChoices(callback, staticChoices, dynamicChoices, sort) {
        var a;
        function returnChoices() {
            if (sort) {
                a.sort(function(l, r) {
                    var lhs, rhs;
                    lhs = l.label.toLowerCase();
                    rhs = r.label.toLowerCase();
                    if (lhs < rhs) {
                        return -1;
                    }
                    if (lhs === rhs) {
                        return 0;
                    }
                    return 1;
                });
            }
            callback.resume(a);
        }
        function gotDynamicChoices(choices) {
            a = a.concat(choices);
            returnChoices();
        }
        a = [];
        if (staticChoices && staticChoices.constructor === Array) {
            a = a.concat(staticChoices);
        }
        if (dynamicChoices && dynamicChoices.constructor === Function) {
            dynamicChoices(gotDynamicChoices);
        } else {
            if (dynamicChoices && dynamicChoices.constructor === Array) {
                a = a.concat(dynamicChoices);
            }
            returnChoices();
        }
    }

    /**
    * Create and return a choices array from the supplied labels & values arrays
    *
    * @param	labels
    *					array of strings to be used as choice labels
    * @param	values
    *					array of strings to be used as choice values
    * @return	array of choice objects
    */
    function createChoices(labels, values) {
        var a, i, n, o;
        a = [];
        n = Math.max(labels.length, values.length);
        for (i = 0; i < n; i += 1) {
            o = {};
            o.label = i < labels.length ? labels[i] : '';
            o.value = i < values.length ? values[i] : '';
            a.push(o);
        }
        return a;
    }

    /**
    * Create and return an object for a script. If there is no supplied json or
    * the supplied json will not parse, an empty object is returned
    *
    * @param	json
    *					optional string containing JSON formatted object.
    *
    * @return	object containing result ofr JSON.parse or an empty object
    */
    function createObject(json) {
        var o;
        validateArgs(arguments, "createObject", 0, 1, [null]);
        if (json) {
            try {
                o = $.jsonParse(json);
            } catch (ex) {
            }
        }
        if (!o || o.constructor !== Object) {
            o = {};
        }
        return o;
    }

    /**
    * @Private
    *
    * Create a new subject using the latest version of supplied process id.
    *
    * @param processId
    *					String containig the processId to use when creating a new subject
    * @param callback
    *					function to receive the subject	 
    */
    function createSubject(processId, callback) {
        var version, newProcess, message;
        version = mc.db.getLatestProcessVersion(processId);
        function createNewSubject() {
            mc.showActivity();
            mc.db.createSubject(processId, version, undefined, callback);
            mc.hideActivity();
        }
        if (!processId) {
            processId = mc.db.getCurrentProcess().id;
            newProcess = mc.db.getCurrentProcess();
        } else {
            newProcess = mc.db.getLatestProcessById(processId);
            if (newProcess !== undefined && newProcess.notClientCreatable && mc.fl.isclientsubject()) {
                message = "mc.fl.createSubject: Can't create subject, process is 'notClientCreatable'";
                log.error(message);
                msgBox(message);
                throw message;
            }
        }
        if (newProcess === undefined) {
            message = "mc.fl.createSubject: Can't create subject, process is not available";
            log.error(message);
            msgBox(message);
            throw message;
        }
        if (newProcess.deleteOnOpen) {
            log.info("mc.fl.createSubject: delete all subjects for single subject delete on open process " + processId);
            mc.showActivity();
            mc.db.deleteAllSubjects(processId, version, createNewSubject);
            mc.hideActivity();
        } else {
            createNewSubject();
        }

    }

    /**
    * Create a new subject using the latest version of supplied process id.
    *
    * @param callback
    *					object to receive the subject	 
    * @param processId
    *					String containig the processId to use when creating a new subject
    */
    function createSubjectGuid(callback, processId) {
        createSubject(processId, function(subject) {
            callback.resume(subject.guid);
        });
    }

    /**
    * Create a new subject using the latest version of supplied process id.
    *
    * @param callback
    *					object to receive the subject
    * @param processId
    *					String containig the processId to use when creating a new subject
    */
    function createSubjectObject(callback, processId) {
        createSubject(processId, function(subject) {
            callback.resume(subject.value);
        });
    }

    /**
    * Raise the default UI for composing emails
    *
    * @param to
    *					string containing a comma separated list of email addresses to send to
    * @param cc
    *					string containing a comma separated list of email addresses to cc to
    * @param subject
    *					string containing subject of email
    * @param body
    *					string containing text of body
    */
    function composeEmail(to, cc, subject, body) {
        var params, url;
        function appendParam(name, value) {
            if (value) {
                params.push(name + '=' + window.escape(value));
            }
        }
        url = 'mailto:';
        if (to) {
            url += to;
        }
        url += '?';
        params = [];
        appendParam('cc', cc);
        appendParam('subject', subject);
        appendParam('body', body);
        url += params.join('&');
        mc.gotoUrl(url, false);
    }

    /**
    * Returns a boolean indicating whether the first parameter contains the value
    * of the second parameter.
    * 
    * @param textOrList
    *          the string or list to search inside.
    * @param search
    *          the item to search for.
    * @return true if textOrList contains search, otherwise false.
    */
    function contains(textOrList, search) {
        var i;
        if (!textOrList) {
            return false;
        }
        validateArgs(arguments, 'contains', 2, 2);
        switch (textOrList.constructor) {
            case String:
                return textOrList.indexOf(search) !== -1;
            case Array:
                for (i = 0; i < textOrList.length; i += 1) {
                    if (textOrList[i] === search) {
                        return true;
                    }
                }
                return false;
            default:
                throw argumentTypeError('Incorrect argument type. Function: "contains" argument: "1" actual: "' + (mc.getobjectclass(textOrList) + ' object = ' + textOrList.constructor) + '" expected: "String" or "Array"');
                //break;
        }
        //return textOrList.indexOf(subString) !== -1;
    }

    /**
    * Returns the UTC creation date of the current subject
    * 
    * @return UTC creation date of the current subject
    */
    function created() {
        var meta;
        meta = mc.db.getValue('_meta');
        return meta.created;
    }

    /**
    * Returns the current page ID
    * 
    * @return current page ID
    */
    function currentPage() {
        return mc.currentPage();
    }
    /**
    * get the process id of the current process.
    *
    * @param processId
    *					String containig the processId to use when creating a new subject
    * @param callback
    *					function to receive the subject	 
    */
    function currentProcessId() {
        var version, processId;
        processId = mc.db.getCurrentProcess().id;
        if (processId !== undefined) {
            version = mc.db.getLatestProcessVersion(processId);
        }
        return processId;
    }

    /**
    * Returns the current row index of the current page
    *
    * @return number containing the current row index of the current page
    */
    function currentRowIdx() {
        var index, page;
        page = $('#' + currentPage());
        if (page.length === 1) {
            index = page.attr('rowIndex');
            if (index && index.constructor === String) {
                index = parseFloat(index);
            }
        }
        return index;
    }

    /**
    * Returns the current subject
    * 
    * @return current subject
    */
    function currentSubjectObject() {
        return mc.db.getCurrentSubject();
    }

    /**
    * Returns the value of the answer of the supplied question.
    * 
    * @param callback - function to receive the value of the answer
    * @param dataId
    * @param index
    * @param columnId
    * @param ignoreDefault
    */
    function data(callback, dataId, index, columnId, ignoreDefault) {
        validateArgs(arguments, "data", 2, 5, [null, String, Number, String, Boolean]);
        getAnswer(callback, dataId, undefined, undefined, index, columnId, ignoreDefault);
    }

    /**
    * Returns a Date parsed from the supplied string in the supplied format.
    * 
    * @param dateString
    *          text to parse.
    * @param format
    *          optional format specifier (only yyyyMMdd currently supported)
    * @return string in format mc.getDateFormat()
    */
    function date(dateString, format) {
        var d, day, month, year;
        validateArgs(arguments, "date", 1, 2, [String, String]);
        switch (format) {
            case undefined:
                if (dateString.length === 8) {
                    year = parseFloat(dateString.slice(0, 4));
                    month = parseFloat(dateString.slice(4, 6)) - 1;
                    day = parseFloat(dateString.slice(6, 8));
                    d = new Date(year, month, day);
                } else {
                    msgBox("date from string can only be yyyyMMdd", "Error", 0);
                }
                break;
            case 'd':
                try {
                    d = Date.parse(dateString);
                } catch (e) {
                    msgBox(dateString + ':' + e, "Date Conversion Error", 0);
                }
                break;
            default:
                try {
                    if (dateString.length === format.length) {
                        d = Date.parseExact(dateString, format);
                    }
                    if (d === undefined || d === null) {
                        d = Date.parse(dateString);
                    }
                } catch (ex) {
                    msgBox(dateString + ':' + ex, "Date Conversion Error", 0);
                }
                break;
        }
        if (d === null) {
            d = undefined;
        }

        return d;
    }

    /**
    * Calculate the julian date from the supplied date object
    *
    * @param	d
    *					date object to convert
    *
    * @return	number object containing julian date number
    */
    function julian(d) {
        var a, dd, ggg, hr, j1, jd, mm, mn, s, sc, yy;
        yy = d.getUTCFullYear();
        mm = d.getUTCMonth() + 1;
        dd = d.getUTCDate();
        hr = d.getUTCHours();
        mn = d.getUTCMinutes();
        sc = d.getUTCSeconds();
        hr += (mn / 60) + (sc / 3600);
        ggg = (yy <= 1585) ? 0 : 1;
        jd = -1 * Math.floor(7 * (Math.floor((mm + 9) / 12) + yy) / 4);
        s = ((mm - 9) < 0) ? -1 : 1;
        a = Math.abs(mm - 9);
        j1 = Math.floor(yy + s * Math.floor(a / 7));
        j1 = -1 * Math.floor((Math.floor(j1 / 100) + 1) * 3 / 4);
        jd += Math.floor(275 * mm / 9) + dd + (ggg * j1);
        jd += 1721027 + 2 * ggg + 367 * yy - 0.5;
        jd += hr / 24;
        return jd;
    }

    /**
    * Calculate the difference in supplied units between the supplied dates
    *
    * @param	d1
    *					date object
    * @param	d2
    *					date object
    * @param	units
    *					string object should be one of 'seconds', 'minutes', 'hours', 'days', 'weeks', 'months', 'years'
    *
    * @return	number containing the difference between d1 and d2
    */
    function dateDiff(d1, d2, units) {
        validateArgs(arguments, "dateDiff", 3, 3, [null, null, String]);
        if (d1 === undefined || d2 === undefined) {
            return 0;
        }
        var result, v1, v2;
        if (units === 'seconds') {
            result = julian(d1) - julian(d2);
            result = Math.round(result * 24 * 60 * 60);
        } else if (units === 'minutes') {
            result = julian(d1) - julian(d2);
            result = Math.round(result * 24 * 60);
        } else if (units === 'hours') {
            result = julian(d1) - julian(d2);
            result = Math.round(result * 24);
        } else if (units === 'days') {
            result = Math.floor(julian(d1) - julian(d2));
        } else if (units === 'weeks') {
            result = (d1.getUTCFullYear() - d2.getUTCFullYear()) * 52;
            v1 = d1.getWeekOfYear();
            v2 = d2.getWeekOfYear();
            if (v2 <= v1) {
                result += v1 - v2;
            } else {
                result -= v2 - v1;
            }
        } else if (units === 'months') {
            result = (d1.getUTCFullYear() - d2.getUTCFullYear()) * 12;
            v1 = d1.getUTCMonth();
            v2 = d2.getUTCMonth();
            if (v2 <= v1) {
                result += v1 - v2;
            } else {
                result -= v2 - v1;
            }
        } else if (units === 'years') {
            result = d1.getUTCFullYear() - d2.getUTCFullYear();
        } else {
            result = 0;
        }
        return result;
    }

    /**
    * Add the supplied components to the supplied date
    *
    * @param	date
    *					Date object to add components to
    * @param	years
    *					Number containing the number of years to add to date
    * @param	months
    *					Number containing the number of months to add to date
    * @param	days
    *					Number containing the number of days to add to date
    * @param	hours
    *					Number containing the number of hours to add to date
    * @param	minutes
    *					Number containing the number of minutes to add to date
    * @param	seconds
    *					Number containing the number of seconds to add to date
    *
    * @return	Date object containing result of date calculation
    */
    function dateAdd(date, years, months, days, hours, minutes, seconds) {
        validateArgs(arguments, "dateAdd", 7, 7, [null, Number, Number, Number, Number, Number, Number]);
        if (date === undefined) {
            return date;
        }
        var d;
        d = new Date(date);
        d.addYears(years)
			.addMonths(months)
			.addDays(days)
			.addHours(hours)
			.addMinutes(minutes)
			.addSeconds(seconds);
        return d;
    }

    /**
    * Add the supplied time to the supplied date
    *
    * @param	date
    *					Date object to add time to
    * @param	time
    *					Date object containing time to add
    *
    * @return	Date object containing result of date calculation
    */
    function dateAddTime(date, time) {
        validateArgs(arguments, "dateAddTime", 2, 2, [null, null]);
        if (date === undefined || time === undefined) {
            return date;
        }
        var d;
        d = new Date(date);
        d.addHours(time.getHours())
			.addMinutes(time.getMinutes())
			.addSeconds(time.getSeconds());
        return d;
    }


    /**
    * Return a Date object constructed from the supplied parts
    *
    * @param	year
    *					Number containing year
    * @param	month
    *					Number containing month - 0 = Jan, 1 = Feb, etc...
    * @param	day
    *					Number containing day of month
    * @param	hour
    *					Number containing hour
    * @param	minute
    *					Number containing minute
    * @param	second
    *					Number containing second
    *
    * @return	Date object contstructed from the supplied parts
    */
    function dateFromParts(year, month, day, hour, minute, second) {
        validateArgs(arguments, "dateFromParts", 6, 6, [Number, Number, Number, Number, Number, Number]);
        return new Date(year, month, day, hour, minute, second);
    }

    /**
    * Get the required components from the supplied date
    *
    * @param	date
    *					Date object to get components from
    *
    * @param	units
    *					string object should be one of 'seconds', 'minutes', 'hours', 'days', 'weeks', 'months', 'years'
    *
    * @return	number containing the date part
    */
    function dateParts(d1, units) {
        validateArgs(arguments, "dateParts", 2, 2, [null, String]);
        var result = 0;
        if (d1 !== undefined) {
            if (units === 'seconds') {
                result = d1.getUTCSeconds();
            } else if (units === 'minutes') {
                result = d1.getUTCMinutes();
            } else if (units === 'hours') {
                result = d1.getUTCHours();
            } else if (units === 'days') {
                result = d1.getUTCDate();
            } else if (units === 'weeks') {
                result = d1.getWeekOfYear();
            } else if (units === 'months') {
                result = d1.getUTCMonth();
            } else if (units === 'years') {
                result = d1.getUTCFullYear();
            } else {
                result = 0;
            }
        }
        return result;
    }
    /* Subtract the supplied time from the supplied date
    *
    * @param	date
    *					Date object to add time to
    * @param	time
    *					Date object containing time to subtract
    *
    * @return	Date object containing result of date calculation
    */
    function dateSubTime(date, time) {
        validateArgs(arguments, "dateSubTime", 2, 2, [null, null]);
        if (date === undefined || time === undefined) {
            return date;
        }
        var d;
        d = new Date(date);
        d.addHours(-time.getHours())
			.addMinutes(-time.getMinutes())
			.addSeconds(-time.getSeconds());
        return d;
    }

    function dateTimeCombine(date, time) {
        if (date === undefined) {
            return time;
        }
        if (time === undefined) {
            return date;
        }

        return dateFromParts(date.getFullYear(), date.getMonth(), date.getDate(), time.getHours(), time.getMinutes(), time.getSeconds())
    }

    function getDebugFlag() {
        return getEnvironment('$$debugFlag') === '1' ? true : false;
    }
    /**
    * Displays an alert or confirm box and returns user choice only if the debug
    * flag is set.
    * 
    * @param message
    *          message to be displayed.
    * @param title
    *          optional title of message box.
    * @param buttons
    *          optional, 0 for OK, 1 for OK & Cancel.
    * @param icon
    *          ignored.
    * @param defaultButton
    *          ignored.
    * @return true if user clicked OK, false otherwise.
    */
    function dbgMsgBox(message, title, buttons, icon, defaultButton) {
        if (getDebugFlag()) {
            return msgBox(message, title, buttons, icon, defaultButton);
        }
        return true;
    }


    /**
    * delete log files
    *
    * @param	callback
    *					Object to perform asynchronous formula callbacks
    *
    * @return true/false
    */
    function deleteLogFiles(callback) {
        var fail, success;
        success = function() {
            callback.resume(true);
        };
        fail = function(message) {
            if (message) {
                alert(message);
            }
            callback.resume(false);
        };

        if (navigator.hasOwnProperty('log')) {
            navigator.log.deleteLogFiles(success, fail);
        } else if (window.plugins.log !== undefined) {
            window.plugins.log.deleteLogFiles(success, fail);
        } else {
            fail('deleteLogFiles Not available in Restricted Client');
        }
    }

    /**
    * Delete the subject with the supplied guid.
    *
    * @param	callback
    *					object containing resume function called when deletion has completed.
    *					1st parameter is an error object, if it's undefined then no error occurred.
    * @param subjectGuid
    *					String containing guid of subject or subject object to delete
    */
    function deleteSubject(callback, subjectGuid) {
        validateArgs(arguments, 'deleteSubject', 2, 2, [null, String]);
        mc.db.deleteSubject(subjectGuid, function(e) {
            callback.resume(e);
        });
    }
    /**
    * Send a direct data request
    *
    * @param	callback
    *					object containing resume function called when deletion has completed.
    *					1st parameter is an error object, if it's undefined then no error occurred.
    * @param channel
    *					The channel that the request will be sent on
    * @param subchannel
    *					The subchannel that the request will be sent on
    * @param type
    *					The 'method' of the request operation
    * @param data
    *					JS object containing the data to send, response routing data etc
    * @param ttlHours
    *					Hours until msg expires
    * @param notifyResponse
    *					boolean do we want a response
    */
    function zumoRequest(callback, channel, subchannel, method, data, ttlHours, notifyResponse) {
        validateArgs(arguments, 'zumoRequest', 5, 7, [null, String, String, String, null, Number, Boolean]);
        dataProviderRequest(callback, 'ZumoRequest', channel, subchannel, method, data, ttlHours, notifyResponse);
    }
    /**
    * Send a direct data request
    *
    * @param	callback
    *					object containing resume function called when deletion has completed.
    *					1st parameter is an error object, if it's undefined then no error occurred.
    * @param channel
    *					The channel that the request will be sent on
    * @param subchannel
    *					The subchannel that the request will be sent on
    * @param type
    *					The 'method' of the request operation
    * @param data
    *					JS object containing the data to send, response routing data etc
    * @param ttlHours
    *					Hours until msg expires
    * @param notifyResponse
    *					boolean do we want a response
    */
    function dataRequest(callback, channel, subchannel, method, data, ttlHours, notifyResponse) {
        validateArgs(arguments, 'dataRequest', 5, 7, [null, String, String, String, null, Number, Boolean]);
        dataProviderRequest(callback, 'DataRequest', channel, subchannel, method, data, ttlHours, notifyResponse);
    }

    /**
    * Send a data provider request
    *
    * @param	callback
    *					object containing resume function called when deletion has completed.
    *					1st parameter is an error object, if it's undefined then no error occurred.
    * @param provider
    *					The provider that the request will be sent through
    * @param channel
    *					The channel that the request will be sent on
    * @param subchannel
    *					The subchannel that the request will be sent on
    * @param type
    *					The 'method' of the request operation
    * @param data
    *					JS object containing the data to send, response routing data etc
    * @param ttlHours
    *					Hours until msg expires
    * @param notifyResponse
    *					boolean do we want a response
    */
    function dataProviderRequest(callback, provider, channel, subchannel, method, data, ttlHours, notifyResponse) {
        validateArgs(arguments, 'dataProviderRequest', 6, 8, [null, String, String, String, String, null, Number, Boolean]);

        var content = {};
        content.data = data;

        var pushMessage = {};

        switch (provider) {
            case "DataRequest":
                {
                    pushMessage.provider = provider;
                    content.method = method;
                    break;
                }
            case "ZumoRequest":
                {
                    pushMessage.provider = 'zumo';
                    content.transport = {};
                    content.transport.type = 'zumoDirect';
                    content.transport.httpMethod = 'POST';
                    content.transport.api = method;
                    content.options = {};

                    break;
                }
            default:
                throw argumentTypeError("Invalid data service provider '" + provider + "'");
        }
        function addMinutes(date, minutes) {
            return new Date(date.getTime() + minutes * 60000);
        }

        if (!ttlHours)
            ttlHours = 0;

        var now = new Date();
        var then = addMinutes(now, ttlHours * 60);

        pushMessage.channel = notifyResponse ? channel : 'ignoreResponse';
        pushMessage.subchannel = notifyResponse ? subchannel : 'ignoreResponse';
        pushMessage.expiry = ttlHours === 0 ? 0 : then.getTime();


        pushMessage.content = content;

        mc.notify.service.sendMessage(pushMessage, function(error, messageId) {
            log.info("mc.fl.dataProviderRequest: " + provider + " message posted, id: " + messageId);
            callback.resume({ error: error, id: messageId });
        });
    }


    /**
    * Calls into the shell to remove zumo credentials
    * 
    */
    function zumoClearToken(callback) {
        //cope with differeces between platform cordova versions
        var authenticator = plugins.authenticator;
        if (authenticator === undefined) authenticator = plugins.authenticate;
        try {
            authenticator.clearZumoCredentials(function() {
                log.info("mc.fl.zumoClearToken: Zumo credentials clear has been requested");
				callback.resume();
            }, function(error) {
                log.info("mc.fl.zumoClearToken: Zumo credentials clear has failed: " + error);
				callback.resume();
            });
        } catch (error) {
            log.error("mc.fl.zumoClearToken: Zumo credentials clear has errored: " + error);
        }
    }
	
	/**
    * Calls into the shell to set zumo credentials
    * 
    */
	function setZumoToken( callback, token, userId ) {
		function successCallback() {
            if (callback.constructor === Function) {
                callback(null);
            } else {
                callback.resume(null);
            }
        }
		function errorCallback(error) {
            if (callback.constructor === Function) {
                callback(error);
            } else {
                callback.resume(error);
            }
        }
		validateArgs(arguments, "setZumoToken", 3, 3, [null, String, String]);
		plugins.settings.setPreference(function () {
		    plugins.settings.setPreference(successCallback, errorCallback, "zumoUserId", userId);
		}, errorCallback, "zumoUserToken", token);
	}

    /**
    * Returns the persistent value of the answer of the supplied question.
    * 
    * @param callback - function to receive the value of the answer
    * @param subjectId
    * @param pageId
    * @param id1 - questionId if id2 is undefined, columnId if id2 is not undefined
    * @param index
    * @param id2 - question id or undefined
    * @param dataId - dataId or undefined. If defined, pageId & questionId (id1 or id2) are ignored
    */
    function dskAns(callback, subjectId, pageId, id1, index, id2, dataId) {
        mc.db.getSubject(subjectId, function(subject, error) {
            var answer, designData, i, process, processName, v;
            try {
                processName = mc.db.makeProcessName({ 'id': subject._meta.processId,
                    'version': subject._meta.processVersion
                });
                if (id2) {
                    v = id1;
                    id1 = id2;
                    id2 = v;
                }
                process = mc.db.getProcess(processName);
                if (!dataId) {
                    dataId = process.pages[pageId].qIdMap[id1];
                }
                answer = subject[dataId];
                if (index !== undefined && index !== null) {
                    if (answer !== undefined && answer.constructor === Array) {
                        answer = answer[index];
                    } else {
                        answer = undefined;
                    }
                }
                if (answer && id2) {
                    if (answer.constructor === Array) {
                        designData = process.questions[dataId];
                        if (designData && designData.columns && designData.columns.constructor === Array) {
                            for (i = 0; i < designData.columns.length; i += 1) {
                                if (designData.columns[i].id && designData.columns[i].id === id2) {
                                    answer = answer[i];
                                    break;
                                }
                            }
                            if (i >= designData.columns.length) {
                                answer = undefined;
                            }
                        } else {
                            answer = undefined;
                        }
                    } else {
                        answer = undefined;
                    }
                }
            } catch (e) {
                answer = undefined;
            }
            if (callback.constructor === Function) {
                callback(answer);
            } else {
                callback.resume(answer);
            }
            error = undefined;
        });
        subjectId = undefined;
    }

    /**
    * Save the supplied subject ensuring summary columns are maintained
    * 
    * @param callback - object to call resume when complete
    * @param subjectId - String containing the GUID identifying the subject OR the subject object
    */
    function dskCloseSubject(callback, subjectId) {
        mc.db.getSubject(subjectId, function(subject, error) {
            var i, process, processName, summaries;
            try {
                processName = mc.db.makeProcessName({ 'id': subject._meta.processId, 'version': subject._meta.processVersion });
                process = mc.db.getProcess(processName);
                summaries = [];
                if (process.summaryMap) {
                    for (i = 0; i < process.summaryMap.length; i += 1) {
                        summaries[i] = subject._meta.summaries[process.summaryMap[i]];
                    }
                }
                mc.db.setSubject(subjectId, subject, true, function(e) {
                    callback.resume(e);
                }, summaries);
            } catch (e) {
                callback.resume(e);
            }
            error = undefined;
        });
    }

    /**
    * Retrieves the persistent current page id from the supplied subject 
    *
    * @param callback
    *					function to receive the persistent current page ID or undefined if not
    *					found
    * @param subjectId
    *					String containing the ID of the subject to check
    *
    */
    function dskCurrentPage(callback, subjectId) {
        mc.db.getSubject(subjectId, function(subject, error) {
            var pageId;
            try {
                pageId = subject._meta.currentPageId;
            } catch (e) {
                pageId = undefined;
            }
            callback.resume(pageId);
            error = undefined;
        });
    }

    /**
    * Returns the persistent value of the answer of the supplied question.
    * 
    * @param callback - function to receive the value of the answer
    * @param subjectId
    * @param dataId
    * @param index
    * @param columnId
    */
    function dskData(callback, subjectId, dataId, index, columnId) {
        validateArgs(arguments, "dskdata", 3, 5, [null, String, String, Number, String]);
        dskAns(callback, subjectId, undefined, columnId, index, 'dummyQuestionId', dataId);
    }

    /**
    * Retrieve a named summary value from the subject with the supplied guid
    *
    * @param callback
    *					function to receive the summary value if found, otherwise undefined
    * @param	guid
    *					String containing guid or subject object
    * @param name
    *					String containing the name of the summary item to get
    *
    * @return	summary value if found, otherwise undefined
    */
    function dskGetSummaryValue(callback, guid, name) {
        validateArgs(arguments, "summaryItem", 3, 3, [null, null, String]);
        mc.db.getSummaryValue(guid, name, function(value) {
            callback.resume(value);
        });
    }

    /**
    * Checks if the supplied question has a persistent answer.
    * 
    * @param callback
    *					function to receive true if the supplied question contains an answer, 
    *					otherwise false.
    * @param subjectId
    * @param dataId
    * @param index
    * @param columnId
    */
    function dskHasData(callback, subjectId, dataId, index, columnId) {
        validateArgs(arguments, "dskhasdata", 3, 5, [null, String, String, Number, String]);
        try {
            dskData(function(answer) {
                callback.resume(answer !== undefined && answer !== null && answer !== '');
            }, subjectId, dataId, index, columnId);
        } catch (e) {
            callback.resume(false);
        }
    }

    /**
    * Checks if the supplied question has a persistent answer.
    * 
    * @param callback
    *					function to receive true if the supplied question contains an answer, 
    *					otherwise false.
    * @param subjectId
    * @param pageId
    * @param id1
    * @param index
    * @param id2
    */
    function dskIsAnswered(callback, subjectId, pageId, id1, index, id2) {
        validateArgs(arguments, "dskisanswered", 4, 6, [null, String, String, String, Number, String]);
        try {
            dskAns(function(answer) {
                callback.resume(answer !== undefined && answer !== null && answer !== '');
            }, subjectId, pageId, id1, index, id2);
        } catch (e) {
            callback.resume(false);
        }
    }

    /**
    * Persists the value of the answer of the supplied question.
    * 
    * @param callback - object to call resume when complete
    * @param subjectId - String containg the GUID identifying the subject
    * @param pageId -  String containing the ID of the page
    * @param questionId - String containing the ID of the question
    * @param answer - Value to save
    * @param index - optional number identifying the index of the answer
    * @param cacheOnly - optional bool indicating whether subject should be saved.
    */
    function dskSetAns(callback, subjectId, pageId, questionId, answer, index, cacheOnly) {
        mc.db.getSubject(subjectId, function(subject, error) {
            function getDataId() {
                var processName = mc.db.makeProcessName({ 'id': subject._meta.processId,
                    'version': subject._meta.processVersion
                });
                var process = mc.db.getProcess(processName);
                pageId = pageId.replace(' ', '_');
                questionId = questionId.replace(' ', '_');
                return process.pages[pageId].qIdMap[questionId];
            }
            function createNewValue(dataId) {
                if (index !== undefined && index !== null) {
                    if (index.constructor === String) {
                        index = parseInt(index, 10);
                    }
                    var a = subject[dataId];
                    if (a === undefined || a === null || a.constructor !== Array) {
                        a = [];
                    }
                    a[index] = answer;
                    return a;
                } else {
                    return answer;
                }
            }
            try {
                var dataId = getDataId();
                newValue = createNewValue(dataId);
                if (!cacheOnly) {
                    mc.db.valueChanging(subject, dataId, newValue, index, function() {
                        subject[dataId] = newValue;
                        mc.db.setSubject(subjectId, subject, true, function(e) {
                            callback.resume(e);
                        });
                    });
                } else {
                    subject[dataId] = newValue;
                    callback.resume();
                }
            } catch (e) {
                callback.resume(e);
            }
            error = undefined;
        });
    }
    function dskCacheAns(callback, subjectId, pageId, questionId, answer, index) {
        dskSetAns(callback, subjectId, pageId, questionId, answer, index, true);
    }

    /**
    * Persists the value of the answer of the supplied question.
    * 
    * @param callback - object to call resume when complete
    * @param subjectId - String containg the GUID identifying the subject
    * @param dataId - String containing the ID of the data
    * @param answer - Value to save
    * @param index - optional number identifying the index of the answer
    * @param cacheOnly - optional bool indicating whether subject should be saved.
    */
    function dskSetData(callback, subjectId, dataId, answer, index, cacheOnly) {
        mc.db.getSubject(subjectId, function(subject, error) {
            function createNewValue() {
                if (index !== undefined && index !== null) {
                    if (index.constructor === String) {
                        index = parseInt(index, 10);
                    }
                    var a = subject[dataId];
                    if (a === undefined || a === null || a.constructor !== Array) {
                        a = [];
                    }
                    a[index] = answer;
                    return a;
                } else {
                    return answer;
                }
            }
            try {
                var newValue = createNewValue(dataId);
                if (!cacheOnly) {
                    mc.db.valueChanging(subject, dataId, newValue, index, function() {
                        subject[dataId] = newValue;
                        mc.db.setSubject(subjectId, subject, true, function(e) {
                            callback.resume(e);
                        });
                    });
                } else {
                    subject[dataId] = newValue;
                    callback.resume();
                }
            } catch (e) {
                callback.resume(e);
            }
            error = undefined;
        });
    }
    function dskCacheData(callback, subjectId, dataId, answer, index) {
        dskSetData(callback, subjectId, dataId, answer, index, true);
    }

    /**
    * Save the summary value for the supplied subject.
    * 
    * @param callback - object to call resume when complete
    * @param subjectId - String containing the GUID identifying the subject OR the subject object
    * @param name -  String containing the name of the summary item to set
    * @param value - Value to save
    * @param cacheOnly - optional bool indicating whether subject should be saved.
    */
    function dskSetSummaryValue(callback, subjectId, name, value, cacheOnly) {
        mc.db.getSubject(subjectId, function(subject, error) {
            var i, process, processName, summaries;
            try {
                subject._meta.summaries[name] = value;
                if (!cacheOnly) {
                    processName = mc.db.makeProcessName({ 'id': subject._meta.processId, 'version': subject._meta.processVersion });
                    process = mc.db.getProcess(processName);
                    summaries = [];
                    if (process.summaryMap) {
                        for (i = 0; i < process.summaryMap.length; i += 1) {
                            summaries[i] = subject._meta.summaries[process.summaryMap[i]];
                        }
                    }
                    mc.db.setSubject(subjectId, subject, true, function(e) {
                        callback.resume(e);
                    }, summaries);
                } else {
                    callback.resume();
                }
            } catch (e) {
                callback.resume(e);
            }
            error = undefined;
        });
    }
    function dskCacheSummaryValue(callback, subjectId, name, value) {
        dskSetSummaryValue(callback, subjectId, name, value, true);
    }

    /**
    * Returns a string containing a comma separated list of the choice labels
    * from the answer to the supplied question
    * 
    * @param pageId
    * @param questionId
    * @return String containing a comma separated list of the choice labels
    */
    function dynamicChoicesToText(callback, pageId, questionId) {
        var dataId, designData, question;
        function convertChoices(choices) {
            var answer, i, j, n, result;
            result = '';
            n = choices.length;
            answer = mc.db.getValue(dataId);
            if (answer !== undefined && answer !== null) {
                switch (answer.constructor) {
                    case Array:
                        result = [];
                        for (i = 0; i < answer.length; i += 1) {
                            for (j = 0; j < n; j += 1) {
                                if (answer[i] === choices[j].value) {
                                    result.push(choices[j].label);
                                    break;
                                }
                            }
                        }
                        result = result.join(', ');
                        break;
                    case String:
                        for (i = 0; i < n; i += 1) {
                            if (answer === choices[i].value) {
                                result = choices[i].label;
                                break;
                            }
                        }
                        break;
                }
            }
            callback.resume(result);
        }
        pageId = pageId.replace(' ', '_');
        questionId = pageId + questionId.replace(' ', '_');
        question = mc.q(pageId, questionId);
        if (question) {
            dataId = question.getDataId();
            designData = getDesignData(dataId);
            if (designData !== undefined && designData.choices !== undefined) {
                switch (designData.choices.constructor) {
                    case Array:
                        convertChoices(designData.choices);
                        break;
                    case Function:
                        designData.choices(convertChoices);
                        break;
                    default:
                        callback.resume('');
                }
            } else {
                callback.resume('');
            }
        } else {
            callback.resume('');
        }
    }

    /**
    * Returns the nth element of an array.
    * 
    * @param list
    *          array to search in.
    * @param index
    *          index of item to return.
    * @return indexth item in list.
    */
    function element(list, index) {
        validateArgs(arguments, 'element', 2, 2, [Array, Number]);
        return list[index];
    }

    /**
    * N.B. Not intended for use with formulas
    *
    * Execute the named formula in the mc.fl object asynchronously 
    *
    * @param name
    *					string containing the name of the mc.fl method
    * @param success
    *					optional function called back when async method has completed
    * @param error
    *					optional function called back when async method has failed
    * @param async
    *					optional boolean indicating whether the formula should be executed asynchronously
    */
    function execFormula(name, success, error, async) {
        var formula, i, params;
        function complete(result) {
            if (async) {
                mc.hideActivity();
            }
            if (success && success.constructor === Function) {
                success(result);
            }
        }
        function fail(e) {
            if (async) {
                mc.hideActivity();
            }
            if (error && error.constructor === Function) {
                error(e);
            }
        }
        if (name && mc.fl[name] !== undefined && mc.fl[name].constructor === Function) {
            if (async) {
                mc.showActivity();
                formula = window.make_formula(mc.fl[name]);
                params = [complete, fail];
                for (i = 4; i < arguments.length; i += 1) {
                    params.push(arguments[i]);
                }
                formula.execute.apply(formula, params);
                //make_formula(mc.fl[name]).execute(complete, fail);
            } else {
                complete(mc.fl[name]());
            }
        } else if (error && error.constructor === Function) {
            error('Invalid formula name: ' + name);
        }
    }

    /**
    * Navigate to the home process
    */
    function exitApp() {
        mc.goHome();
    }

    /**
    * Returns an array of strings splitting the supplied string with the supplied
    * separator
    *
    * @param	s
    *					string to split
    * @param	separator
    *					delimiter used to split s with
    *
    * @return	array of strings
    */
    function explode(s, separator) {
        validateArgs(arguments, "explode", 2, 2, [String, String]);
        return s.split(separator);
    }

    /**
    * Returns a new Error object
    */
    function formulaError(message) {
        return makeError('formulaError', message);
    }

    /**
    * Returns a new Error containing the supplied string
    * 
    * @param errorString
    *          text to be contained in error object
    * @return Error
    */
    function error(errorString) {
        validateArgs(arguments, "error", 1, 1, [String]);
        return formulaError(errorString);
    }

    /**
    * Returns the message property of the supplied Error parameter
    * 
    * @param e
    *          Error object to get message from
    * @return message property
    */
    function errorText(e) {
        validateArgs(arguments, "text", 1, 1, [Error]);
        return e.message;
    }

    /**
    * Formats the supplied number or date according to the supplied format
    * specifier string.
    * 
    * @param numberOrDate
    *          Number or Date to be formatted.
    * @param formatString
    *          format specifier for dates currently on 'd', 'D', 't' or 'T' is
    *          supported
    * @return string
    */
    function format(numberOrDate, formatString) {
        var f, n;
        validateArgs(arguments, "format", 2, 2, [null, String]);
        if (numberOrDate === undefined || numberOrDate === null) {
            return '';
        }
        if (isNumber(numberOrDate) === true) {
            return numberOrDate.toString();
        }
        if (numberOrDate.constructor === String) {
            n = new Date(numberOrDate);
        } else if (numberOrDate.constructor === Date) {
            n = numberOrDate;
        }
        if (isDateTime(n)) {
            if (Date.hasOwnProperty('CultureInfo')) {
                switch (formatString) {
                    case 'd':
                        f = Date.CultureInfo.formatPatterns.shortDate;
                        break;
                    case 'D':
                        f = Date.CultureInfo.formatPatterns.longDate;
                        break;
                    case 'F':
                        f = Date.CultureInfo.formatPatterns.fullDateTime;
                        break;
                    case 'm':
                        f = Date.CultureInfo.formatPatterns.monthDay;
                        break;
                    case 'r':
                        f = Date.CultureInfo.formatPatterns.rfc1123;
                        break;
                    case 's':
                        f = Date.CultureInfo.formatPatterns.sortableDateTime;
                        break;
                    case 't':
                        f = Date.CultureInfo.formatPatterns.shortTime;
                        break;
                    case 'T':
                        f = Date.CultureInfo.formatPatterns.longTime;
                        break;
                    case 'u':
                        f = Date.CultureInfo.formatPatterns.universalSortableDateTime;
                        break;
                    case 'y':
                        f = Date.CultureInfo.formatPatterns.yearMonth;
                        break;
                    default:
                        f = formatString;
                        break;
                }
                return n.toString(f);
            }
            if (formatString === 'd') {
                return n.toLocaleDateString();
            }
            if (formatString === 'D') {
                return n.toLocaleDateString();
            }
            if (formatString === 't') {
                return n.getHours().toString() + ':' + n.getMinutes().toString();
            }
            if (formatString === 'T') {
                return n.getHours().toString() + ':' + n.getMinutes().toString() + ':' + n.getSeconds().toString();
            }
            throw argumentTypeError('No date/time culture info to convert to "' + formatString + '". Use d|D|t|T');
        }
        throw argumentTypeError('Incorrect argument type function: "format" argument: "1" actual: "' + (mc.getobjectclass(n) + ' - object = ' + args[i].constructor) + '" expected: "Number" or "Date"');
    }

    /**
    *Return the current location information
    *
    * @public
    * @param options
    *			array of strings of the location items to retrieve
    *			i.e. 'lat', 'long', 'velocity'
    * @return
    *			array of requested items
    */
    function getCurrentLocation(options) {
        var i, ret, position;

        if (options === undefined) {
            return undefined;
        }
        ret = {};
        position = mc.db.getCachedPosition();
        if (typeof (position) == 'undefined' || typeof (position.coords) == 'undefined') {
            return undefined;
        }
        if (options.length == 1 && options[0] == '') {
            return position;
        }
        for (i = 0; i < options.length; i += 1) {
            switch (options[i]) {

                case 'lat': {
                    ret.latitude = position.coords.latitude;
                    //copy to requested item name for people who can't read documentation
                    ret.lat = position.coords.latitude;
                    break;
                }
                case 'long': {
                    ret.longitude = position.coords.longitude;
                    //copy to requested item name for people who can't read documentation
                    ret.long = position.coords.longitude;
                    break;
                }
                case 'time': {
                    ret.timestamp = position.timestamp;
                    //copy to requested item name for people who can't read documentation
                    ret.time = position.timestamp;
                    break;
                }
                case 'timestamp': {
                    ret.timestamp = position.timestamp;
                    break;
                }
                default: {
                    ret[options[i]] = position.coords[options[i]];
                    break;
                }
            }
        }

        return ret;
    }

    /**
    * Raise the default UI for getting directions
    *
    * @param source
    *					string containing the source address
    * @param destination
    *					string containing the destination address
    */
    function getDirections(source, destination) {
        var params, url;
        function appendParam(name, value) {
            if (value) {
                params.push(name + '=' + window.escape(value));
            }
        }
        url = 'http://maps.google.com/?';
        params = [];
        appendParam('sensor', 'true');
        appendParam('saddr', source);
        appendParam('daddr', destination);
        url += params.join('&');
        mc.gotoUrl(url, false);
    }

    /**
    * Retrieves the value of a named item on the current subject
    * 
    * @param name
    *					String containing the name of the item to get
    *
    * @return value of the named item on the current subject
    */
    function getSubjectValue(name) {
        return mc.db.getMetaValue(name);
    }

    /**
    * Retrieves the value of a named summary item on the supplied subject
    * 
    * @param subject
    *					Subjet object
    * @param name
    *					String containing the name of the summary item to get
    *
    * @return value of the named item on the current subject
    */
    function getSummaryValue(subject, name) {
        var value;
        validateArgs(arguments, "getSummaryValue", 2, 2, [null, String]);
        if (!subject || subject.constructor !== Object) {
            log.error('mc.fl.getSummaryValue: Parameter 1 is not a valid subject object');
        } else if (subject._meta && subject._meta.constructor === Object && subject._meta.summaries && subject._meta.summaries.constructor === Object) {
            value = subject._meta.summaries[name] || '';
        }
        if (typeof value !== 'string') {
            value = '';
        }
        return value;
    }

    /**
    * Retrieves the value of a named item in the syncInfo object on the current
    * subject
    *
    * @param name
    *					String containing the name of the item to get
    *
    * @return value of the named item in the syncInfo object on the current subject
    */
    function getSyncInfo(name) {
        var syncInfo, value;
        syncInfo = getSubjectValue('syncInfo');
        if (syncInfo) {
            value = syncInfo[name];
            if (value === undefined) {
                value = syncInfo[name.toLowerCase()];
                if (value === undefined) {
                    try {
                        syncInfo = JSON.parse(JSON.stringify(syncInfo).toLowerCase());
                        value = syncInfo[name.toLowerCase()];
                    }
                    catch (e) {
                        log.error("Duplicate lowercase item in subject _meta : " + JSON.stringify(syncInfo));
                    }
                }
            }
        }
        return value;
    }

    /**
    * Get the mSuite user name
    *
    * @return	String containing the mSuite user name
    */
    function getUserName() {
        return mc.db.getUserInfo().mSuiteUserName || '';
    }

    /**
    * Get the android service user name
    *
    * @return	String containing the service user name
    */
	function getServiceUserName(callback, service) {            

        function fail(e) {
            log.error("getServiceUsername failed: " + e);
        }

        function success(username) {
            if (typeof (callback) === "function") {
                callback(username);
            } else if (typeof (callback["resume"]) === "function") {
                callback.resume(username);
            } else {
                log.error("Unable to exit from getServiceUserName: invalid callback");
            }
        }

        validateArgs(arguments, "getserviceusername", 2, 2, [null, String]);
        plugins.settings.getServiceUsername(success, fail, service);   
    }

    /**
    * Get the mSuite user info object
    *
    * @return	Object containing the user info object
    */
    function getUserInfo() {
        return mc.db.getUserInfo() || {};
    }

    /**
    * Retrieves the parent subject guid from the syncInfo object on the current
    * subject
    *
    * @return value of the parent subject guid in the syncInfo object on the current subject
    */
    function getParentSubject() {
        return getSyncInfo('parentguid') || '';
    }

    /**
    * Retrieves the base url to re provision the app including the query string parameters
    * if this is being hosted in a shell
    *
    * @return value of the parent subject guid in the syncInfo object on the current subject
    */
    function gotoProvisioningUrl(callback) {
        //debugger;
        function exit(provisioningURL) {
            if (typeof (callback) === "function") {
                callback(provisioningURL)
            } else if (typeof (callback["resume"]) === "function") {
                callback.resume(provisioningURL);
            } else {
                log.error("Unable to exit from provisioning url reason: invalid callback");
            }
        }
        mc.gotoProvisioningUrl(exit);

    }

    function getObjectValue(o, n) {
        if (o[n] !== undefined) {
            return o[n];
        }
        return '';
    }

    /**
    * Returns the index of every selected row for the supplied question
    *
    * @return	array containing index of every selected row
    */
    function getSelectedRows(pageId, questionId) {
        var i, pid, q, qid, rows, selected;
        validateArgs(arguments, "getSelectedRows", 2, 2, [String, String]);
        pid = pageId.replace(' ', '_');
        qid = pid + questionId.replace(' ', '_');
        selected = [];
        q = $('#' + qid);
        rows = q.find('.jmuiSelected');
        rows.each(function() {
            i = parseInt($(this).attr('rowIndex'), 10);
            if (typeof i === 'number' && isFinite(i) && i >= 0) {
                selected.push(i);
            }
        });
        return selected;
    }

    /**
    * Retrieve the guid of the supplied subject regardless of whether the supplied
    * subject is a guid or a subject object
    *
    * @param	subjectGuid
    *					String containing the guid to return or Object containing the subject
    *					_meta block containing the subject guid
	 
	* @return	String containing the subject guid
    */
    function getSubjectGuid(guid) {
        var s;
        s = mc.db.getSubjectGuid(guid);
        return s;
    }

    /**
    * Retrieve the subject object matching the supplied guid regardless of whether
    * the supplied guid is a subject object or a guid string
    *
    * @param callback
    *					Object to receive subject object
    * @param	guid
    *					subject object to retrieve or guid of the subject object to retrieve
    */
    function getSubjectObject(callback, guid) {
        function gotSubject(subject) {
            if (subject && subject.hasOwnProperty('_meta')) {
                callback.resume(subject);
            } else {
                throw 'Subject not found. Guid: ' + guid;
            }
        }
        mc.db.getSubject(guid, gotSubject);
    }

    function guidFromSyncID(callback, processId, syncId) {
        mc.db.getSubjectGuidFromReplID(processId, syncId, function(guid) {
            if (guid === undefined) {
                callback.resume('');
            } else {
                callback.resume(guid);
            }
        });
    }

    /**
    * Show the page corresponding to the supplied page id in the current subject
    *
    * @param pageId
    *					String containing the page id to go to
    * @param backwards
    *					Optional boolean indicating the direction of the slide animation		
    */
    function gotoPage(pageId, backwards) {
        function popSubject() {
            var guid, processId;
            processId = mc.db.getCurrentProcess().id;
            function openSubjectFailed() {
                mc.goHome();
            }
            guid = mc.fl.popsubject();
            if (guid) {
                mc.fl.opensubject({ resume: openSubjectFailed }, guid);
            } else {
                mc.goHome();
            }
        }
        validateArgs(arguments, 'gotoPage', 1, 2, [String, Boolean]);
        if (pageId) {
            $.ui.gotoPage($('#' + pageId), 'jmuiSlide', backwards);
        } else {
            popSubject();
        }
    }

    /**
    * Show the url corresponding to the supplied url
    *
    * @param url
    *					String containing the page id to go to
    * @param popup window
    *					Optional boolean indicating the page should open in a popup window		
    */
    function gotoUrl(url, popup) {
        var u;
        validateArgs(arguments, 'gotoUrl', 1, 2, [String, Boolean]);
        if (url) {
            mc.gotoUrl(url, false);
        }
        u = popup;
    }

    /**
    * Checks if the supplied question has any data
    * 
    * @param callback - function to receive boolean
    * @param dataId
    * @param index
    * @param columnId
    * @param ignoreDefault
    */
    function hasData(callback, dataId, index, columnId) {
        validateArgs(arguments, "hasdata", 2, 4, [null, String, Number, String]);
        function dataCallback(value) {
            callback.resume(value !== undefined && value !== null && value !== '');
        }
        data({ resume: dataCallback }, dataId, index, columnId, true);
    }

    /**
    * Returns a delimited string containing each element in the supplied array.
    *
    * @param	list
    *					array of strings to join
    * @param	separator
    *					string to delimit the returned string with
    *
    * @return	string containing each element of the supplied array delimited with
    *					the supplied separator
    */
    function implode(list, separator) {
        validateArgs(arguments, "implode", 2, 2, [Array, String]);
        return list.join(separator);
    }

    /**
    * Checks if the current subject is client created
    *
    * @return	true if the current subject is client created, false otherwise
    */
    function isClientSubject() {
        var serverId;
        serverId = getSyncInfo('ServerId');
        return serverId === null || serverId === undefined || serverId === '';
    }

    /**
    * Checks if the current subject is server created
    *
    * @return	true if the current subject is server created, false otherwise
    */
    function isServerSubject() {
        return !isClientSubject();
    }

    /**
    * Returns the length of the supplied string or array
    * 
    * @param stringOrList
    *          string or array to get the length of
    * @return string or array length
    */
    function length(stringOrList) {
    	validateArgs(arguments, "length", 1, 1);
    	if (stringOrList !== undefined) {
    		if (stringOrList.constructor === String
					|| stringOrList.constructor === Array) {
    			return stringOrList.length;
    		}
    	} else {
    		return 0;
    	}
        throw argumentTypeError('Incorrect argument type function: "length" argument: "1" actual: "' + (mc.getobjectclass(stringOrList) + ' - object = ' + stringOrList.constructor) + '" expected: "String" or "List"');
    }

    /**
    * Return the leftmost supplied number of characters from the supplied string
    *
    * @param	s
    *					string to extract from
    * @param	n
    *					number of characters to extract
    *
    * @return	string containing the extraction
    */
    function left(s, n) {
        validateArgs(arguments, "left", 2, 2, [String, Number]);
        return s.slice(0, n);
    }

    /**
    * Returns the supplied parameter as an array.
    * 
    * @param any
    * @return arguments array.
    */
    function list() {
        return Array.prototype.slice.call(arguments);
    }

    /**
    * Log4 stuff
    * 
    * @param message
    *          text to append to the log
    */
    function logTrace(message) {
        applog.trace(message);
    }
    function logDebug(message) {
        applog.debug(message);
    }
    function logInfo(message) {
        applog.info(message);
    }
    function logWarn(message) {
        applog.warn(message);
    }
    function logError(message) {
        applog.error(message);
    }
    function logFatal(message) {
        applog.fatal(message);
    }

    /**
    * Log4 maintenance stuff
    */
    function logGetLevel() {
        return applog.getLevel().name;
    }
    function enableLogging(level) {
        window.plugins.log.enableLogging();
    }
    function disableLogging(level) {
        window.plugins.log.disableLogging();
    }
    function logRemoveAllAppenders() {
        applog.removeAllAppenders();
    }
    function logRemoveAppender(name) {
        var a, i;
        if (name && log4javascript.hasOwnProperty(name)) {
            try {
                a = applog.getEffectiveAppenders();
                if (a && a.length) {
                    for (i = 0; i < a.length; i += 1) {
                        try {
                            if (a[i] instanceof log4javascript[name]) {
                                applog.removeAppender(a[i]);
                            }
                        } catch (ex) {

                        }
                    }
                }
            } catch (ex) {
                log.error('Unable to remove invalid appender "' + name + '" in mc.fl.logRemoveAppender');
            }
        }
    }
    function logAddAppender(name, channel, subchannel, notification, timeToLive) {
        var appender;
        validateArgs(arguments, "logAddAppender", 1, 5, [String, String, String, String, Number]);
        if (name && log4javascript.hasOwnProperty(name)) {
            try {
                appender = new log4javascript[name]();
                if (name === 'NotifyLogAppender') {
                    validateArgs(arguments, "logAddAppender", 5, 5, [String, String, String, String, Number]);
                    appender.configure(channel, subchannel, notification, timeToLive);
                }
                applog.addAppender(appender);
            } catch (ex) {
                log.error('Unable to add invalid appender "' + name + '" in mc.fl.logAddAppender');
            }
        }
    }

    /**
    * Perform some sort of lookup thing (datagrid?)
    * 
    * @param callback
    *          callback function to call when complete
    * @param processId
    *          the process Id of the process
    * @param replicationProfile
    *          the replication profile to use
    * @param timeout
    *          timeout to use
    * 
    */
    function lookup(callback, processId, profileAlias, timeout) {
        mc.db.setSubject(mc.db.getCurrentSubjectGuid(), mc.db.getCurrentSubject(), false, function() {
            function complete(success) {
                delete mc.replInfo;
                callback.resume(success);
            }
            var title, url;
            title = 'lookup';
            url = '';

            mc.replInfo = {
                callback: callback,
                processId: processId,
                profileAlias: profileAlias,
                title: title,
                url: url,
                timeout: timeout
            };
            activityStart();
            mc.repl.replicate(function(success) {
                activityStop();
                if (success !== window.ReplicationResult.Completed) {
                    complete(success);
                }
                else {
                    complete(success);
                }
            }, mc.replInfo);
        });
    }

    /**
    * Converts a string to lower case letters.
    * 
    * @param text
    *          text to convert to lower case.
    * @return the supplied string converted to lower case.
    */
    function lowerCase(text) {
        validateArgs(arguments, "lowerCase", 1, 1, [String]);
        return text.toLowerCase();
    }

    /**
    * Mail the shell log files
    * 
    * @Calling convention	ASYNC
    *
    * @param callback
    *					Object to perform asynchronous formula callbacks.
    * @param recipient
    *					String containing the recipient
    */
    function mailLogs(callback, recipient) {
        validateArgs(arguments, "mailLogs", 2, 2, [null, String]);

        if (window.plugins.log.mailLogs) {
            function success(result) {
                if (callback) {
                    callback.resume(result);
                }
            }
            function failure() {
                if (callback) {
                    callback.resume(false);
                }
            }
            window.plugins.log.mailLogs(success, failure, recipient);
        } else {
            log.error('Missing function: window.plugins.log.mailLogs');
        }
    }

    /**
    * Initiate a phone call
    *
    * @param numberString
    *					string containing the number to dial
    */
    function makePhoneCall(numberString) {
        mc.gotoUrl('tel:' + numberString, false);
    }

    /**
    * Returns a boolean indicating whether the supplied text matches the supplied
    * regular expression.
    * 
    * @param text
    *          string to be tested.
    * @param exp
    *          string to be used as the regular expression.
    * @return true if text matches exp, otherwise false.
    */
    function matchRegEx(text, exp) {
        validateArgs(arguments, "matchRegEx", 2, 2, [String, String]);
        return new RegExp(exp).test(text);
    }

    /**
    * Returns the path to the supplied media file
    * 
    * @param value
    *          media file name to get the path of
    * @return String containing the pathe of the supplied media file.
    */
    function media(value) {
        validateArgs(arguments, "media", 1, 1, [String]);
        return '../' + mc.db.getCurrentProcess().version + '/resources/' + value;
    }

    /**
    * Saves the supplied value in the supplied question.
    * 
    * @param callback
    *					Object to receive success/failure
    * @param guid
    *					String containing guid of the subject or the subject object to modify
    * @param pageId
    *					String containing the page Id on which the question resides
    * @param questionId
    *					String containing the questionId in which to save the value
    * @param value
    *					value to save in the question
    */
    function modifySubject(callback, guid, pageId, quesitonId, value) {
        function gotSubject(subject) {
            var dataId, process, processName;
            try {
                processName = mc.db.makeProcessName({ 'id': subject._meta.processId,
                    'version': subject._meta.processVersion
                });
                process = mc.db.getProcess(processName);
                dataId = process.pages[pageId].qIdMap[quesitonId];
                mc.db.valueChanging(subject, dataId, value, undefined, function() {
                    subject[dataId] = value;
                    mc.db.setSubject(guid, subject, false, function(e) {
                        callback.resume(e);
                    });
                });
            } catch (e) {
                callback.resume(false);
            }
        }
        validateArgs(arguments, "modifySubject", 5, 5, [null, null, String, String, null]);
        mc.db.getSubject(guid, gotSubject);
    }

    /**
    * Saves the supplied value in the supplied question.
    * 
    * @param callback
    *					Object to receive success/failure
    * @param guid
    *					String containing guid of the subject or the subject object to modify
    * @param name
    *					String containing the name of the syncInfo member to modify
    * @param value
    *					value to save in the syncInfo
    */
    function modifySubjectSyncInfo(callback, guid, name, value) {
        function gotSubject(subject) {
            try {
                if (!subject._meta.syncInfo) {
                    subject._meta.syncInfo = {};
                }
                subject._meta.syncInfo[name] = value;
                mc.db.setSubject(guid, subject, false, function(e) {
                    callback.resume(!e);
                });
            } catch (e) {
                callback.resume(false);
            }
        }
        validateArgs(arguments, "modifySubjectSyncInfo", 4, 4, [null, null, String, null]);
        mc.db.getSubject(guid, gotSubject);
    }

    /**
    * Mirror Win32 MessageBox functionality
    *
    * @param callback
    *					object containing resume method to call on completion
    * @param message
    *          message to be displayed.
    * @param title
    *          optional title of message box.
    * @param buttons
    *          optional, 0 for OK, 1 for OK & Cancel, etc...
    * @param icon
    *          ignored.
    * @param defaultButton
    *          ignored.
    */
    function msgBoxAsync(callback, message, title, buttons, icon, defaultButton) {
        var u;
        function complete(btnText) {
            var button;
            button = 0;
            switch (btnText.toLowerCase()) {
                case 'ok':
                    button = 0;
                    break;
                case 'cancel':
                    button = 2;
                    break;
                case 'abort':
                    button = 3;
                    break;
                case 'retry':
                    button = 4;
                    break;
                case 'ignore':
                    button = 5;
                    break;
                case 'yes':
                    button = 6;
                    break;
                case 'no':
                    button = 7;
                    break;
            }
            if (callback.constructor === Function) {
                callback(button);
            } else {
                callback.resume(button);
            }
        }
        validateArgs(arguments, "msgBoxAsync", 1, 6, [null, String, String, Number, null, null]);
        switch (buttons) {
            case 0: //OK
                mc.msgBox(complete, title, message, 'OK');
                break;
            case 1: //OKCANCEL
                mc.msgBox(complete, title, message, 'OK', 'Cancel');
                break;
            case 2: //ABORTRETRYIGNORE
                mc.msgBox(complete, title, message, 'Abort', 'Retry', 'Ignore');
                break;
            case 3: //YESNOCANCEL
                mc.msgBox(complete, title, message, 'Yes', 'No', 'Cancel');
                break;
            case 4: //YESNO
                mc.msgBox(complete, title, message, 'Yes', 'No');
                break;
            case 5: //RETRYCANCEL
                mc.msgBox(complete, title, message, 'Retry', 'Cancel');
                break;
            default:
                if (title === undefined)
                    mc.msgBox(complete, '', message, 'OK');
                else
                    mc.msgBox(complete, title, message, 'OK');
                break;

        }
        u = icon;
        u = defaultButton;
    }

    /**
    * Sets the persistent current page id in the current subject
    *
    * @param	pageId
    *					String containing the page id to save
    */
    function newCurrentPageOnClose(pageId) {
        validateArgs(arguments, 'newCurrentPageOnClose', 1, 1, [String]);
        mc.currentPage(pageId);
        setSubjectValue(undefined, 'pageStack', [], true);
    }

    /**
    * Add and subscribe to a notification channel
    * 
    * @Calling convention	ASYNC
    *
    * @param callback
    *					Object to perform asynchronous formula callbacks. 1st parameter will be
    *					either an error object or a string containing the name of the added
    *					channel
    * @param channel
    *					String containing the name of the channel to subscribe to
    */
    function notifyAddChannel(callback, channel) {
        validateArgs(arguments, "notifyAddChannel", 2, 2, [null, String]);
        mc.notify.service.addChannel(channel, function(error, channel) {
            callback.resume(error ? { message: error} : channel);
        });
    }

    /**
    * Cancel all message reception
    * 
    * @Calling convention	ASYNC
    *
    * @param callback
    *					Object to perform asynchronous formula callbacks. 1st parameter will be
    *					either an error object or undefined on success
    */
    function notifyCancelAllMessageNotifications(callback) {
        validateArgs(arguments, "notifyCancelAllMessageNotifications", 1, 1, [null]);
        mc.notify.service.cancelAllMessageNotifications(function(error) {
            callback.resume(error ? { message: error} : undefined);
        });
    }

    /**
    * Cancel message reception for the supplied receiver
    * 
    * @Calling convention	ASYNC
    *
    * @param callback
    *					Object to perform asynchronous formula callbacks. 1st parameter will be
    *					either an error object or a string containing the receiver for which
    *					message reception has been cancelled.
    * @param receiver
    *					String containing the receiver on which to cancel message reception
    */
    function notifyCancelMessageNotification(callback, receiver) {
        validateArgs(arguments, "notifyCancelMessageNotification", 2, 2, [null, String]);
        mc.notify.service.cancelMessageNotification(receiver, function(error, receiver) {
            callback.resume(error ? { message: error} : receiver);
        });
    }

    /**
    * Delete the message with the supplied id
    * 
    * @Calling convention	ASYNC
    *
    * @param callback
    *					Object to perform asynchronous formula callbacks. 1st parameter will be
    *					either an error object or a string containing the id of the deleted 
    *					message.
    * @param messageId
    *					String containing the id of the message to delete
    */
    function notifyDeleteMessage(callback, messageId) {
        validateArgs(arguments, "notifyDeleteMessage", 2, 2, [null, String]);
        log.debug("notifyDeleteMessage - msgid: " + messageId);
        mc.notify.service.deleteMessage(messageId, function(error, id) {
            if (error) {
                log.debug("notifyDeleteMessage - msgid: " + id + " error: " + error);
            } else {
                log.debug("notifyDeleteMessage - msgid: " + id + " deleted");
            }
            callback.resume(error ? { message: error} : id);
        });
    }


    /**
    * Retrieve all messages matching the supplied channel and subchannel
    * 
    * @Calling convention	ASYNC
    *
    * @param callback
    *					Object to perform asynchronous formula callbacks. 1st parameter will be
    *					either an error object or an array where each element contains a message
    *					object. To get values out of the message use mc.fl.getobjectvalue
    * @param channel
    *					String containing the name of the channel to get messages for
    * @param subchannel
    *					String containing the name of the subchannel to get messages for
    */
    function notifyGetMessages(callback, channel, subchannel) {
        validateArgs(arguments, "notifyGetMessages", 3, 3, [null, String, String]);
        log.debug("notifyGetMessages - channel: " + channel + " subchannel: " + subchannel);
        mc.notify.service.getMessages(channel, subchannel, function(error, messages) {
            if (error) {
                log.debug("notifyGetMessages - channel: " + channel + " subchannel: " + subchannel + " error: " + error);
            } else {
                log.debug("notifyGetMessages - channel: " + channel + " subchannel: " + subchannel + " count: " + messages.length);
            }
            callback.resume(error ? { message: error} : messages);
        });
    }

    /**
    * Retrieve all unread messages matching the supplied channel and subchannel
    * and receiver
    *
    * @Calling convention	ASYNC
    *
    * @param callback
    *					Object to perform asynchronous formula callbacks. 1st parameter will be
    *					either an error object or an array where each element contains a message
    *					object. To get values out of the message use mc.fl.getobjectvalue
    * @param channel
    *					Optional string containing the name of the channel to get messages for
    * @param subchannel
    *					Optional string containing the name of the subchannel to get messages for
    * @param receiver
    *					Optional string containing the potential receiver of the message. If 
    *					this is not supplied, mc.db.getUserInfo().mSuiteUserName will be used 
    *					instead.
    */
    function notifyGetUnreadMessages(callback, channel, subchannel, receiver) {
        validateArgs(arguments, "notifyGetUnreadMessages", 1, 4, [null, String, String, String]);
        log.debug("notifyGetUnreadMessages - rcv: " + receiver + " channel: " + channel + " subchannel: " + subchannel);
        if (!receiver) {
            receiver = mc.db.getUserInfo().mSuiteUserName;
        }
        log.debug("notifyGetUnreadMessages - rcv: " + receiver + " channel: " + channel + " subchannel: " + subchannel);
        mc.notify.service.getUnreadMessages(receiver, channel, subchannel, function(error, messages) {
            if (error) {
                log.debug("notifyGetUnreadMessages - rcv: " + receiver + " channel: " + channel + " subchannel: " + subchannel + " error: " + error);
            } else {
                log.debug("notifyGetUnreadMessages - rcv: " + receiver + " channel: " + channel + " subchannel: " + subchannel + " count: " + messages.length);
            }
            callback.resume(error ? { message: error} : messages);
        });
    }

    /**
    * Retrieve a count of all unread messages matching the supplied channel,
    * subchannel and receiver
    *
    * @Calling convention	ASYNC
    *
    * @param callback
    *					Object to perform asynchronous formula callbacks. 1st parameter will be
    *					either an error object or a Number containing the count of unread
    *					messages.
    * @param channel
    *					Optional string containing the name of the channel to get messages for
    * @param subchannel
    *					Optional string containing the name of the subchannel to get messages for
    * @param receiver
    *					Optional string containing the potential receiver of the message. If 
    *					this is not supplied, mc.db.getUserInfo().mSuiteUserName will be used 
    *					instead.
    */
    function notifyGetUnreadMessageCount(callback, channel, subchannel, receiver) {
        validateArgs(arguments, "notifyGetUnreadMessageCount", 1, 4, [null, String, String, String]);
        log.debug("notifyGetUnreadMessageCount - rcv: " + receiver + " channel: " + channel + " subchannel: " + subchannel);
        if (!receiver) {
            receiver = mc.db.getUserInfo().mSuiteUserName;
        }
        log.debug("notifyGetUnreadMessageCount - rcv: " + receiver + " channel: " + channel + " subchannel: " + subchannel);
        mc.notify.service.getUnreadMessages(receiver, channel, subchannel, function(error, messages) {
            if (error) {
                log.debug("notifyGetUnreadMessageCount - rcv: " + receiver + " channel: " + channel + " subchannel: " + subchannel + " error: " + error);
            } else {
                log.debug("notifyGetUnreadMessageCount - rcv: " + receiver + " channel: " + channel + " subchannel: " + subchannel + " count: " + messages.length);
            }
            callback.resume(error ? { message: error} : messages.length);
        });
    }

    /**
    * Retrieve a list of all current channels
    * 
    * @Calling convention	ASYNC
    *
    * @param callback
    *					Object to perform asynchronous formula callbacks. 1st parameter will be
    *					either an error object or an array where each element is a string
    *					containing the name of a current channel
    */
    function notifyListChannels(callback) {
        validateArgs(arguments, "notifyListChannels", 1, 1, [null]);
        mc.notify.service.listChannels(function(error, channels) {
            callback.resume(error ? { message: error} : channels);
        });
    }

    /**
    * Mark the message with the supplied id as received by the supplied receiver
    *
    * @Calling convention	ASYNC
    *
    * @param callback
    *					Object to perform asynchronous formula callbacks. 1st parameter will be
    *					either an error object or undefined on success.
    * @param messageId
    *					String containing the id of the message to mark as received
    * @param receiver
    *					Optional string containing the receiver of the message. If this is not
    *					supplied, mc.db.getUserInfo().mSuiteUserName will be used instead.
    */
    function notifyMessageReceived(callback, messageId, receiver) {
        var receivedOn = receiver;
        log.debug("notifyMessageReceived - rec: " + receiver + " id: " + messageId);
        validateArgs(arguments, "notifyMessageReceived", 2, 3, [null, String, String]);
        if (!receiver) {
            userInfo = mc.db.getUserInfo();
            receivedOn = userInfo.mSuiteUserName;
        }
        log.debug("notifyMessageReceived - by: " + receivedOn + " id: " + messageId);
        mc.notify.service.messageReceivedAck(receivedOn, messageId, function(error) {
            mc.refreshNotificationIndicator();
            callback.resume(error ? { message: error} : undefined);
        });
    }

    /**
    * Register to receive messages as and when they arrive on the supplied
    * channel/subchannel pair
    *
    * @Calling convention	ASYNC
    *
    * @param callback
    *					Object to perform asynchronous formula callbacks. 1st parameter will be
    *					either an error object or undefined on success.
    *
    * @param	formulaName
    *					String containing the name of the formula to execute when a message is
    *					received. The formula must be attached to mc.fl and will be executed in
    *					an asynchronous manner. The formula can use this.getvar('_arg1') to get
    *					an error object. error.message contains the error message string. The
    *					formula can use this.getvar('_arg2') to get the message object. Use
    *					mc.fl.getobjectvalue to extract data from the message. e.g.
    *					mc.fl.getobjectvalue(msg, 'content') will extract the content string
    *					from the object msg.
    * @param	receiver
    *					String containing the receiver. This should be a unique string or a name
    * @param	channel
    *					String containing the name of the channel to receive messages on
    * @param	subchannel
    *					String containing the name of the subchannel to receive messages on
    * @return	Object containing an error message or undefined on success
    */
    function notifyReceiveMessageNotification(callback, formulaName, receiver, channel, subchannel) {
        var e;
        log.debug("notifyReceiveMessageNotification - rec: " + receiver + " channel: " + channel + " sub: " + subchannel + "call: " + formulaName);
        validateArgs(arguments, "notifyReceiveMessageNotication", 5, 5, [null, String, String, String, String]);
        if (formulaName && mc.fl[formulaName] === undefined || typeof mc.fl[formulaName] !== 'function') {
            throw argumentTypeError('notifyReceiveMessageNotication : invalid function parameter "' + formulaName + '"');
        }
        e = mc.notify.service.receiveMessageNotification(receiver, channel, subchannel, function(error, message) {
            log.debug("notifyReceiveMessageNotification - rec: " + receiver + " channel: " + channel + " sub: " + subchannel + " id: " + message.id);
            log.debug('error = ' + JSON.stringify(error));
            log.debug('message = ' + JSON.stringify(message));
            function markAsRead(result) {
                log.debug("notifyReceiveMessageNotification - rec: " + receiver + " channel: " + channel + " sub: " + subchannel + " id: " + message.id + " call: " + formulaName + " result: " + result);
                if (result === 'success') {
                    try {
                        mc.notify.service.messageReceivedAck(receiver, message.id);
                        mc.refreshNotificationIndicator();
                    } catch (e) {
                        log.error("notifyReceiveMessageNotificationAck - rec: " + receiver + " channel: " + channel + " sub: " + subchannel + " id: " + message.id + " call: " + formulaName + " error: " + e);
                    }
                }
            }
            function success() {
                markAsRead("success");
            }
            function fail() {
                markAsRead("fail");
            }
            if (!error && message) {
                log.debug("notifyReceiveMessageNotification - rec: " + receiver + " channel: " + channel + " sub: " + subchannel + " id: " + message.id + " call: " + formulaName);
                mc.fl.execFormula(formulaName, success, fail, true, error, message);
                // call notificationMessageStoreChange ??
            } else {
                log.error("notifyReceiveMessageNotification id: " + message.id + " error: " + JSON.stringify(error));
            }
        });
        if (e !== undefined) {
            callback.resume({ message: e });
            //return { message: e };
        } else {
            callback.resume(undefined);
        }
    }

    function notifyReceiveOutboxNotification(formulaName, receiver, channel, subchannel) {

    }

    /**
    * Remove and unsubscribe from a notification channel
    * 
    * @Calling convention	ASYNC
    *
    * @param callback
    *					Object to perform asynchronous formula callbacks. 1st parameter will be
    *					either an error object or a string containing the name of the removed
    *					channel
    * @param channel
    *					String containing the name of the channel to unsubscribe from
    */
    function notifyRemoveChannel(callback, channel) {
        validateArgs(arguments, "notifyRemoveChannel", 2, 2, [null, String]);
        mc.notify.service.removeChannel(channel, function(error, channel) {
            callback.resume(error ? { message: error} : channel);
        });
    }

    /**
    * Send a message on a specific channel and subchannel.
    * 
    * @Calling convention	ASYNC
    *
    * @param callback
    *					Object to perform asynchronous formula callbacks. 1st parameter will be
    *					either an error object or a string containing the id of the sent message
    * @param channel
    *					String containing the name of the channel to send on
    * @param subchannel
    *					String containing the name of the subchannel to send on
    * @param content
    *					String containing the content of the message
    * @param notification
    *					String containing the notification message to display
    * @param ttlHours
    *					Number or String containing the time-to-live for the message, in hours
    * @param provider
    *					String containing the text "post" to use the direct data write otherwise undefined
    */
    function notifySendMessage(callback, channel, subchannel, content, notification, ttlHours, provider) {
        var message, expiry;
        validateArgs(arguments, "notifySendMessage", 6, 7, [null, String, String, null, String, null]);
        if (ttlHours.constructor !== Number) {
            ttlHours = parseInt(ttlHours, 10);
        }
        if (!ttlHours || ttlHours === '') {
            ttlHours = 0;
        }
        if (ttlHours === 0) {
            expiry = 0;
        } else {
            expiry = (new Date()).addHours(ttlHours).getTime();
        }
        message = {
            channel: channel,
            subchannel: subchannel,
            content: content,
            notification: notification,
            expiry: expiry
        };
        if (provider) {
            message.provider = provider;
        }
        mc.notify.service.sendMessage(message, function(error, messageId) {
            callback.resume(error ? { message: error} : messageId);
        });
    }

    /**
    * Returns & pops the last pushed pageId off the page stack
    * 
    * @return the last pushed pageId off the page stack
    */
    function popPage() {
        var pageId, pageStack;
        pageStack = getSubjectValue('pageStack');
        if (pageStack && pageStack.constructor === Array && pageStack.length > 0) {
            pageId = pageStack.pop();
            setSubjectValue(undefined, 'pageStack', pageStack, true);
        } else {
            pageId = '';
        }
        return pageId;
    }

    /**
    * Navigate to the next / previous page
    *
    * @param	backwards
    *					Boolean indicating direction of animation
    */
    function nextPage(backwards) {
        var formulaName, prevpage;
        function popSubject() {
            var guid;
            function openSubjectFailed() {
                mc.goHome();
            }
            guid = mc.fl.popsubject();
            if (guid) {
                mc.fl.opensubject({ resume: openSubjectFailed }, guid);
            } else {
                mc.goHome();
            }
        }
        function success(result) {
            var processId;
            if (result && typeof result === 'string' && result !== 'Start') {
                $.ui.gotoPage($('#' + result), 'jmuiSlide', backwards);
            } else {
                processId = mc.db.getCurrentProcess().id;
                popSubject();
            }
        }
        function error(e) {
            alert(e);
            popSubject();
        }
        if (backwards === true) {
            prevpage = popPage();
            return success(prevpage);
        }
        formulaName = 'action_' + mc.currentPage() + '_pageForward';
        mc.fl.execFormula(formulaName, success, error, true);
    }

    /**
    * Returns a Date set to Now
    * 
    * @return date
    */
    function now() {
        return new Date();
    }

    /**
    * Parses a string and returns a floating point number.
    * 
    * @param numberString
    *          text to parse and convert into a Number.
    * @return the supplied string converted to a number.
    */
    function number(numberString) {
        validateArgs(arguments, "number", 1, 1, [String]);
        return parseFloat(numberString);
    }

    /**
    * Opens the subject corresponding to the supplied guid
    *
    * @param callback
    *					callback function to call when failed
    * @param guid
    *					string containing the guid of the subject or the subject object to open
    * @param pageId
    *					optional string containing the id of the page to open the subject at
    */
    function openSubject(callback, guid, pageId) {
        function gotSubject(subject) {
            var process, processName;
            if (subject) {
                processName = mc.db.makeProcessName({ 'id': subject._meta.processId,
                    'version': subject._meta.processVersion
                });
                process = mc.db.getProcess(processName);
                process.currentSubjectGuid = getSubjectGuid(guid);
                mc.db.setProcess(processName, process);
                mc.gotoUrl(process.url, !process.urlProcess);
            } else if (callback) {
                callback.resume();
            }
        }
        function getSubject() {
            mc.db.getSubject(guid, function(subject) {
                if (pageId && subject._meta.currentPageId !== pageId) {
                    subject._meta.currentPageId = pageId;
                    mc.db.setSubject(guid, subject, true, function() {
                        gotSubject(subject);
                    });
                } else {
                    gotSubject(subject);
                }
            });
        }
        validateArgs(arguments, "openSubject", 2, 3, [null, String, String]);
        mc.db.evaluateSummaryValues(mc.db.getCurrentProcess().summaryMap, mc.fl.summaries, getSubject);
    }

    /**
    * Navigate back one page
    */
    function pageBack() {
        nextPage(true);
    }

    /**
    * Navigate to home process
    */
    function pageHome() {
        mc.goHome();
    }

    /**
    * Navigate forware one page
    */
    function pageNext() {
        nextPage(false);
    }

    function getLog() {
        return log;
    }

    /**
    * Returns & pops the last item from the list
    * 
    * @return the last item
    */
    function popList(list) {
        return list.pop();
    }

    /**
    * Returns & pops the last pushed subjectId off the subject stack
    * 
    * @return the last pushed subjectId off the subject stack
    */
    function popSubject() {
        var subjectId, subjectStack;
        subjectStack = mc.db.getJsonItem('subjectStack') || [];
        if (subjectStack && subjectStack.constructor === Array && subjectStack.length > 0) {
            subjectId = subjectStack.pop();
            mc.db.setJsonItem('subjectStack', subjectStack);
        } else {
            subjectId = '';
        }
        return subjectId;
    }

    /**
    * Adds a new element to the end of an existing list
    * 
    * @return the new length
    */
    function pushList(list, newItem) {
        return list.push(newItem);
    }

    /**
    * Pushes the current pageId on to the page stack
    */
    function pushPage() {
        var pageStack;
        pageStack = getSubjectValue('pageStack');
        if (!pageStack || pageStack.constructor !== Array) {
            pageStack = [];
        }
        pageStack.push(currentPage());
        setSubjectValue(undefined, 'pageStack', pageStack, true);
    }

    /**
    * Pushes the current subjectId on to the subject stack
    */
    function pushSubject(guid) {
        var subjectStack;
        guid = getSubjectGuid(guid);
        subjectStack = mc.db.getJsonItem('subjectStack') || [];
        if (!subjectStack || subjectStack.constructor !== Array) {
            subjectStack = [];
        }
        subjectStack.push(guid || currentSubjectGuid());
        mc.db.setJsonItem('subjectStack', subjectStack);
    }



    /**
    * Fetch query summary data for a dynamic choice
    *
    * @param	callback
    *					Callback function( array[] ) containing the list of unique summary values
    * @param   processId
    *                  The processId of the dataset
    * @param   processVersion
    *                  The version of the dataset
    * @param   summaryItemName
    *                  The summary item that we want to obtain the list of possible values
    * @param   [filterSummaryItemName]
    *                  optional string, the first summary item name to filter on
    * @param   [filterCompareValue]
    *                  optional string, the value to compare the first summary item filter value to
    * @param   [filterSummaryItemName...]
    *                  optional string, the second summ...	 	 
    */
    function querySummaryData(callback, processId, processVersion, summaryItemName) {
        var filters, o, processName, processObj, realArguments, separator, u;
        function finish(result) {
            if (callback.constructor === Function) {
                callback(result);
            } else {
                callback.resume(result);
            }
        }

        separator = '';
        o = {};
        o.id = processId;
        o.version = '';
        o.version += mc.db.getLatestProcessVersion(processId);
        processName = mc.db.makeProcessName(o);
        processObj = mc.db.getProcess(processName);

        if (processObj !== undefined && processObj.separator !== undefined) {
            separator = processObj.separator;
        }
        realArguments = Array.prototype.slice.call(arguments);
        filters = realArguments.slice(4);

        mc.db.querySummaryData(processId, summaryItemName, filters, true, separator, function(arr) {
            var results;
            results = [];
            $.each(arr, function(index, item) {
                var summaryValueLabel, summaryValueValue;
                summaryValueLabel = item;
                summaryValueValue = item;
                if (separator !== undefined && separator.length > 0 && item.indexOf(separator) >= 0 && item.indexOf(separator) < item.length) {
                    summaryValueLabel = item.substring(0, item.indexOf(separator));
                    summaryValueValue = item.substring(1 + item.indexOf(separator));
                }
                results.push({ label: summaryValueLabel, value: summaryValueValue });
                index = undefined;
            });

            finish(results);
        });
        u = processVersion;
    }


    /**
    * Fetch query summary data for a dynamic choice, but don't return it as Choice objects, and allow 
    * duplicates to be returned in the list.
    *
    * @param	callback
    *					Callback function( array[] ) containing the list of unique summary values
    * @param   processId
    *                  The processId of the dataset
    * @param   processVersion
    *                  The version of the dataset
    * @param   summaryItemName
    *                  The summary item that we want to obtain the list of possible values
    * @param   [filterSummaryItemName]
    *                  optional string, the first summary item name to filter on
    * @param   [filterCompareValue]
    *                  optional string, the value to compare the first summary item filter value to
    * @param   [filterSummaryItemName...]
    *                  optional string, the second summ...	 	 
    */
    // Helper function for querysummaryvalues
    function querySummaryValues2(callback, processId, processVersion, summaryItemName, unique, filters) {
        var o, processName, processObj, separator;
        function finish(results) {
            var finalResult = [];
            $.each(results, function(index, item) {
                finalResult.push(item.value);
                index = undefined;
            });

            if (callback.constructor === Function) {
                callback(finalResult);
            } else {
                callback.resume(finalResult);
            }
        }

        separator = '';
        o = {};
        o.id = processId;
        o.version = '';
        o.version += mc.db.getLatestProcessVersion(processId);
        processName = mc.db.makeProcessName(o);
        processObj = mc.db.getProcess(processName);

        if (processObj.separator !== undefined) {
            separator = processObj.separator;
        }
        //        var realArguments = Array.prototype.slice.call(arguments);    
        //        var filters = realArguments.slice(4);                   
        //        copy & paste error - confuses debugger        
        mc.db.querySummaryData(processId, summaryItemName, filters, unique, separator, function(arr) {

            var results = [];
            $.each(arr, function(index, item) {
                var summaryValueLabel, summaryValueValue;
                summaryValueLabel = item;
                summaryValueValue = item;
                if (separator !== undefined && separator.length > 0 && item.indexOf(separator) >= 0 && item.indexOf(separator) < item.length) {
                    summaryValueLabel = item.substring(0, item.indexOf(separator));
                    summaryValueValue = item.substring(1 + item.indexOf(separator));
                }
                results.push({ label: summaryValueLabel, value: summaryValueValue });
                index = undefined;
            });

            finish(results);
        });
        processVersion = undefined;
    }

    function querySummaryValuesNonUnique(callback, processId, processVersion, summaryItemName) {
        var realArguments = Array.prototype.slice.call(arguments);
        querySummaryValues2(callback, processId, processVersion, summaryItemName, false, realArguments.slice(4));
    }

    /**
    * Fetch query summary data for a dynamic choice, but don't return it as Choice objects
    *
    * @param	callback
    *					Callback function( array[] ) containing the list of unique summary values
    * @param   processId
    *                  The processId of the dataset
    * @param   processVersion
    *                  The version of the dataset
    * @param   summaryItemName
    *                  The summary item that we want to obtain the list of possible values
    * @param   [filterSummaryItemName]
    *                  optional string, the first summary item name to filter on
    * @param   [filterCompareValue]
    *                  optional string, the value to compare the first summary item filter value to
    * @param   [filterSummaryItemName...]
    *                  optional string, the second 2932
    ...
    */
    function querySummaryValues(callback, processId, processVersion, summaryItemName) {
        var realArguments = Array.prototype.slice.call(arguments);
        querySummaryValues2(callback, processId, processVersion, summaryItemName, true, realArguments.slice(4));
    }
    /*
    * Refresh the current page
    * Don't allow the app developer to cause a stack overflow by calling it recursively
    * Found on ECM where a calculated answer called refresh
    * That cauised anothe calculated answer to fire
    * That called refresh and so we ended up recursively calling refresh
    * until the stack overflowed
    */
    var inRefreshCurrentPage = false;
    function refreshCurrentPage() {
        if (!inRefreshCurrentPage) {
            inRefreshCurrentPage = true;
            $('.jmuiLayout.jmuiCurrent .jmuiPage.jmuiCurrent').bind('jmuiPageAnimationStart', function(e) {
                inRefreshCurrentPage = true;
            });
            $('.jmuiLayout.jmuiCurrent .jmuiPage.jmuiCurrent').bind('jmuiPageAnimationEnd', function(e) {
                inRefreshCurrentPage = false;
            });
            $('.jmuiLayout.jmuiCurrent .jmuiPage.jmuiCurrent').removeAttr('rowindex');
            $('.jmuiLayout.jmuiCurrent .jmuiPage.jmuiCurrent')
			.trigger('jmuiPageAnimationStart', { direction: 'in' })
			.trigger('jmuiPageAnimationEnd', { direction: 'in' });
        }
    }

    /**
    * Trigger the hide formulas for the current page
    */
    function refreshHidden() {
        var formula, formulaName;
        function hidden() {
            setTimeout(function() {
                var page;
                page = $('#' + currentPage());
                $.ui.refreshScroller(page);
            }, 0);
        }
        formulaName = 'pageHide_' + currentPage();
        formula = mc.fl[formulaName];
        if (formula !== undefined && formula.constructor === Function) {
            formula(hidden);
        }
    }

    /**
    * Refresh the UI of the question corresponding to the supplied question id
    *
    * @param questionId
    *					string containing the question id of the question to be refreshed
    */
    function refreshQuestion(questionId) {
        var pageId, q, qid;
        validateArgs(arguments, "refreshQuestion", 1, 1, [String]);
        pageId = currentPage();
        qid = pageId + questionId.replace(' ', '_');
        q = mc.q(pageId, qid);
        if (q) {
            q.load();
        }
        execFormula('questionId_' + qid);
    }

    /**
    * Refresh the iScroll content
    *
    * @param timeout
    *					How long to wait before refreshing the iScroll container's content
    *                   It will have 500ms added onto it by $.ui.refreshScroller
    */
    function refreshiScroll(timeout) {
        validateArgs(arguments, "refreshiScroll", 1, 1, [Number]);
        setTimeout(function() {
            $('.jmuiPage.jmuiCurrent').each(function() {
                $.ui.refreshScroller($(this));
            });
        }, timeout);
    }

    /**
    * Initiate a replication
    *
    * @param	callback
    *					Object to perform asynchronous formula callbacks
    * @param	processId
    * @param profileAlias
    * @param title - title display in replicate dialog title bar
    * @param	url - url to go to after replication
    * @param	timeout
    *
    * @return	The final return value will from the callback object
    */
    function replicatePage(callback, processId, profileAlias, title, url, timeout) {
        var replInfo, s;
        if (!mc.repl.isReplicating()) {
            if (!mc.getPreNotifyCount()) {
                replInfo = {
                    processId: processId,
                    profileAlias: profileAlias,
                    title: title,
                    timeout: timeout,
                    url: url || location.href
                };
                mc.db.setJsonItem('mcReplInfo', replInfo);
                mc.db.evaluateSummaryValues(mc.db.getCurrentProcess().summaryMap, mc.fl.summaries, function() {
                    mc.gotoUrl('../../replicate.html', false);
                    //mc.gotoUrl('replicate.html');
                });
                callback = undefined;
            } else {
                s = 'Cannot start a replication while there are currently running pre-notifications';
                log.error(s);
                window.alert(s);
                callback.resume(false);
            }
        } else {
            s = 'Cannot start a replication while another replication is in progress';
            log.error(s);
            window.alert(s);
            callback.resume(false);
        }
    }

    /**
    * Revert the current subject to the state when it was opened
    *
    * @param callback
    *					object to call back when revert is complete
    */
    function revert(callback) {
        mc.db.restoreCurrentSubject(function(e) {
            refreshCurrentPage();
            callback.resume(e);
        });
    }

    /**
    * Return the rightmost supplied number of characters from the supplied string
    *
    * @param	s
    *					string to extract from
    * @param	n
    *					number of characters to extract
    *
    * @return	string containing the extraction
    */
    function right(s, n) {
        validateArgs(arguments, "right", 2, 2, [String, Number]);
        return s.slice(-n);
    }

    /**
    * Initiate a barcode/QR scan
    *
    * @param	callback
    *					Object to perform asynchronous formula callbacks
    * @param successMessage
    *					optional string containing message to alert on successful barcode scan
    * @param failMessage
    *					optional string containing message to alert on failed barcode scan
    *
    * @return The text result of the scan or an empty string for failure
    */
    function scan(callback, successMessage, failMessage) {
        var fail, success;
        success = function(data) {
            if (successMessage) {
                alert(successMessage);
            }
            callback.resume(data);
        };
        fail = function(message) {
            if (failMessage) {
                alert(failMessage + ': ' + message);
            }
            callback.resume('');
        };
        if (navigator.hasOwnProperty('barcodeScanner')) {
            navigator.barcodeScanner.scanBarcode(success, fail);
        } else if (window.plugins.barcodeScanner !== undefined) {
            window.plugins.barcodeScanner.scan(success, fail);
        } else if (cordova.plugins.barcodeScanner !== undefined) {
            cordova.plugins.barcodeScanner.scan(success, fail);
        } else {
            fail('Not available in Restricted Client');
        }
    }

    /**
    * Saves the value of the answer for the supplied question.
    * 
    * @param pageId
    * @param questionId
    * @param answer
    * @param index
    */
    function setAns(pageId, questionId, answer, index) {
        var pid, qid;
        validateArgs(arguments, "ans", 3, 4, [String, String, null, Number]);
        pid = pageId.replace(' ', '_');
        qid = questionId.replace(' ', '_');
        return setAnswer(undefined, pid, qid, answer, index);
    }

    /**
    * Saves the value of the answer for the supplied question.
    * 
    * @param dataId
    * @param answer
    * @param index
    */
    function setData(dataId, answer, index) {
        validateArgs(arguments, "setdata", 2, 3, [String, null, Number]);
        return setAnswer(dataId, undefined, undefined, answer, index);
    }

    /**
    * Set the input focus to the question with the supplied questionId
    *
    * @param	questionId
    *					String containing the questionId of the question to set the focus to
    */
    function setFocus(questionId) {
        var id, question;
        function removePseudoFocus() {
            question.removeClass('jmuiPseudoFocus');
            question.unbind('click', removePseudoFocus);
        }
        id = currentPage() + questionId;
        id = id.replace(' ', '_');
        question = $('#' + id);
        if (question.length) {
            if (question[0].previousElementSibling && question[0].previousElementSibling.nodeName === 'H2') {
                $.ui.scrollToElement(question[0].previousElementSibling);
            } else {
                $.ui.scrollToElement(question[0]);
            }
            //question.find('input:first-of-type').focus(); Can't be done on iPhone and screws scrolling on desktop
            // First check if this question already has the focus
            $(':focus').blur();
            $('.jmuiPseudoFocus').removeClass('jmuiPseudoFocus');
            question.addClass('jmuiPseudoFocus').bind('click', removePseudoFocus);
        }
    }

	/**
    * Sets the persistent current page id in the current subject.
	* This is like newCurrentPageOnClose except this is asyncronous
	* and so waits for completion of the database operation.
    *
	* @param	callback
    *					Object to perform asynchronous formula callbacks
    * @param	pageId
    *					String containing the page id to save
    * @param	clearStack
    *					Optional boolean (default true). Indicates whether
	*                   the page stack should be cleared.
    */
    function setReturnPage(callback,pageId,clearStack) {
        validateArgs(arguments, 'setReturnPage', 2, 3, [null, String, Boolean]);
        mc.currentPage(pageId);
		if (clearStack === undefined) {
			clearStack = true;
		}
		mc.db.setMetaValue('currentPageId', pageId, true, function() {
			if (clearStack) {
				setSubjectValue(callback, 'pageStack', [], true);
			} else {
				callback.resume();
			}
		});
    }
	
    /**
    * Sets the text in the title bar of the current page
    *
    * @param	title
    *					String containing the new page title
    **/
    function setTitleBarText(title) {
        var pageId;
        pageId = mc.currentPage();
        setPageTitleBarText(pageId, title);
    }

    /**
    * Sets the text in the title bar of the requested page
    *
    * @param	pageId
    *					String containing the pageId for the new title
    *
    * @param	title
    *					String containing the new page title
    **/
    function setPageTitleBarText(pageId, title) {
        var headerTitle;
        headerTitle = $('#' + pageId + ' .jmuiHeader > h1');
        if (headerTitle) {
            headerTitle.item(0).html(title);
        }
    }

    function setObjectValue(o, n, v) {
        validateArgs(arguments, 'setObjectValue', 3, 3, [null, String, null]);
        o[n] = v;
    }

    /**
    * Sets a named value in the syncInfo object on the current subject
    *
    * @param	name
    *					String containing the name of the item to set
    * @param	value
    *					String or Object containing the value of the item to set
    *
    */
    function setSyncInfo(callback, name, value) {
        var syncInfo;
        function clone(o) {
            var p, c;
            c = {};
            for (p in o) {
                if (o.hasOwnProperty(p)) {
                    c[p] = o[p];
                }
            }
            return c;
        }
        syncInfo = getSubjectValue('syncInfo');
        //if (!syncInfo || syncInfo[name.toLowerCase()] !== value) {
        if (!syncInfo || syncInfo[name] !== value) {
            syncInfo = clone(syncInfo);
            //syncInfo[name.toLowerCase()] = value;
            syncInfo[name] = value;
            setSubjectValue(callback, 'syncInfo', syncInfo, false);
        } else if (callback && callback.hasOwnProperty('resume')) {
            callback.resume();
        }
    }

    /**
    * Returns the supplied parameter as an array.
    * 
    * @param string
    * @param separator
    * @return arguments array.
    */
    function split(str, sep) {
        validateArgs(arguments, "split", 2, 2, [String, String]);
        log.warn('using deprecated function split - consider changing to explode');
        return list(str.split(sep));
    }

    /**
    * Initiate a gps heartbeat
    *
    * @param	callback
    *					Object to perform asynchronous formula callbacks
    * @param successMessage
    *					optional string containing message to alert on successful start
    * @param failMessage
    *					optional string containing message to alert on failed start
    *
    * @return true/false
    */
    function startGpsHeartBeat(callback, successMessage, failMessage) {
        var fail, success;
        success = function() {
            if (successMessage) {
                alert(successMessage);
            }
            callback.resume(true);
        };
        fail = function(message) {
            if (failMessage) {
                alert(failMessage + ': ' + message);
            }
            callback.resume(false);
        };

        validateArgs(arguments, "startGpsHeartBeat", 1, 3, [null, String, String]);
        if (navigator.hasOwnProperty('statusUpdater')) {
            navigator.statusUpdater.start(success, fail);
        } else if (window.plugins.statusUpdater !== undefined) {
            window.plugins.statusUpdater.start(success, fail);
        } else {
            fail('GPS Heartbeat Not available in Restricted Client');
        }
    }

    /**
    * Initiate a geofence scan
    *
    * @param	callback
    *					Object to perform asynchronous formula callbacks
    * @param	region
    *					Object defining the region
    * @param successMessage
    *					optional string containing message to alert on successful start
    * @param failMessage
    *					optional string containing message to alert on failed start
    *
    * @return true/false
    */
    function startMonitoringRegion(callback, region, successMessage, failMessage) {
        var fail, success;
        success = function() {
            if (successMessage) {
                alert(successMessage);
            }
            callback.resume(true);
        };
        fail = function(message) {
            if (failMessage) {
                alert(failMessage + ': ' + message);
            }
            callback.resume(false);
        };

        validateArgs(arguments, "startMonitoringRegion", 2, 4, [null, null, String, String]);
        if (navigator.hasOwnProperty('location')) {
            navigator.location.startMonitoringRegion(region, success, fail);
        } else if (window.plugins.location !== undefined) {
            window.plugins.location.startMonitoringRegion(region, success, fail);
        } else if (window.geofence !== undefined) {
	    window.geofence.addOrUpdate({
		id:             region.identifier,
		latitude:       region.latitude, 
		longitude:      region.longitude, 
		radius:         region.radius, 
		transitionType: 3, 
		notification: {       			
		    title:          "Geofence", 
		    text:           region.enteredNotification,			
	            openAppOnClick: true,
		    data:           {}  //Custom object associated with notification
		}
	    }).then(function () {
		console.log('Geofence successfully added');
		callback.resume(true);
	    }, function (reason) {
	        console.log('Adding geofence failed', reason);		
		callback.resume(false);
	    });
	} else {
            fail('Geofence Not available in Restricted Client');
        }
    }

    /**
    * terminate a gps heartbeat
    *
    * @param	callback
    *					Object to perform asynchronous formula callbacks
    * @param successMessage
    *					optional string containing message to alert on successful start
    * @param failMessage
    *					optional string containing message to alert on failed start
    *
    * @return true/false
    */
    function stopGpsHeartBeat(callback, successMessage, failMessage) {
        var fail, success;
        success = function() {
            if (successMessage) {
                alert(successMessage);
            }
            callback.resume(true);
        };
        fail = function(message) {
            if (failMessage) {
                alert(failMessage + ': ' + message);
            }
            callback.resume(false);
        };

        validateArgs(arguments, "stopGpsHeartBeat", 1, 3, [null, String, String]);
        if (navigator.hasOwnProperty('statusUpdater')) {
            navigator.statusUpdater.stop(success, fail);
        } else if (window.plugins.statusUpdater !== undefined) {
            window.plugins.statusUpdater.stop(success, fail);
        } else {
            fail('GPS Heartbeat Not available in Restricted Client');
        }
    }

    /**
    * cancel a geofence scan
    *
    * @param	callback
    *					Object to perform asynchronous formula callbacks
    * @param	identifier
    *					string identifing the region to cancel
    * @return true/false
    */
    function stopMonitoringRegion(callback, identifier) {
        var fail, success;
        success = function() {
            callback.resume(true);
        };
        fail = function(message) {
            if (message) {
                alert(message);
            }
            callback.resume(false);
        };

        validateArgs(arguments, "stopMonitoringRegion", 2, 2, [null, String]);
        if (navigator.hasOwnProperty('location')) {
            navigator.location.stopMonitoringRegion(identifier, success, fail);
        } else if (window.plugins.location !== undefined) {
            window.plugins.location.stopMonitoringRegion(identifier, success, fail);
	} else if (window.geofence !== undefined) {
	    window.geofence.remove(identifier, success, fail)
        } else {
            fail('Geofence Not available in Restricted Client');
        }
    }


    /**
    * Returns the subject context supplied to the formula. Assumes the subject
    *	context was the first extra parameter passed to the formula
    */
    function subjectContext(callback) {
        callback.resume(callback.getvar('_arg1'));
    }

    /**
    * Extracts the characters from a string, between two specified indices, and
    * returns the new sub string.
    * 
    * @param text
    *          super string to extract from.
    * @param startIndex
    *          index in superString where to start the extraction from. First
    * @param endIndex
    *          optional index in superString where to stop the extration. If
    *          omitted, it extracts the rest of the string.
    * @return the new sub string.
    */
    function subString(text, startIndex, endIndex) {
        validateArgs(arguments, "subString", 2, 3, [String, Number, Number]);
        return text.substring(startIndex, endIndex);
    }

    /**
    * Query summaries in a compressed or uncompressed dataset
    *
    * @param processId
    * @param options object
    *			filters - an optional array of filters: ([{summaryName: 'x', summaryValue: 'y'},{...}])
    *			conditions - an optional array of conditions: ([{condition: 'contains', summaryName: 'x', value: 'y'},{...}])
    *		    summaryName - optional string: show only summaries that match this summaryName
    *			summaryNames - optional array: show only summaries that match one of these summaryNames
    *			unique/distinct - optional boolean, show only unique entries (non-compessed only atm)
    *			choices - optional boolean: provide results in the form expected by dynamic choices
    * @param callback
    *
    */
    function summaryQuery(callback, processId, options) {
        mc.db.summaryQuery(processId, options, function(result) {
            if (callback.constructor === Function) {
                callback(result);
            } else {
                callback.resume(result);
            }
        });
    }

    /**
    * Switch the href attribute of the css link with the supplied id to the value
    * in the process.css object with the supplied name.
    *
    * @param	id
    *					String containing the id of the link tag to change
    * @param	name
    *					String containing the name of the value in the process.css object
    *
    * @return	true if the supplied id & name was found & used, false otherwise
    */
    function switchCss(title) {
        var b;
        b = false;
        validateArgs(arguments, "switchCss", 1, 1, [String]);
        $('link[rel*=style][title]').each(function(i) {
            this.disabled = true;
            if (this.getAttribute('title') == title) {
                this.disabled = false;
                b = true;
                mc.db.setMetaValue('currentCss', title);
            }
        });
        return b;
    }

    /**
    * Converts an object to text
    * 
    * @param item
    *          item to be converted to text.
    * @return supplied item converted to text.
    */
    function text(item) {
        validateArgs(arguments, "text", 1, 1, [null]);
        if (item === null || item === undefined) {
            return 'null';
        }
        switch (item.constructor) {
            case String:
                return item;
            case Number:
                return item.toString();
            case Boolean:
                return item ? 'true' : 'false';
            case Date:
                return item.toString();
            case Object:
                return JSON.stringify(item);
        }
        return 'Unknown type';
    }

    /**
    * Returns a Date parsed from the supplied string in the supplied format.
    * 
    * @param timeString
    *          text to parse.
    * @param format
    *          optional format specifier (only HHmm currently supported)
    * @return date
    */
    function time(timeString, format) {
        var d, h, m;
        validateArgs(arguments, "time", 1, 2, [String, String]);
        switch (format) {
            case undefined:
            case null:
            case '':
                if (timeString.length === 4) {
                    h = parseFloat(timeString.slice(0, 2));
                    m = parseFloat(timeString.slice(2, 4));
                    d = new Date(); // Local TZ
                    d.setHours(h, m, 0, 0);
                } else {
                    msgBox("time from string can only be HHmm", "Error", 0);
                }
                break;
            case 't':
                try {
                    d = Date.parse(timeString);
                    if (isDateTime(d)) {
                        h = d.getHours();
                        m = d.getMinutes();
                        d.setHours(h, m, 0, 0);
                    }
                } catch (e) {
                    msgBox(timeString + ':' + e, "Time Conversion Error", 0);
                }
                break;
            default:
                try {
                    d = Date.parseExact(timeString, format);
                    if (isDateTime(d)) {
                        h = d.getHours();
                        m = d.getMinutes();
                        d.setHours(h, m, 0, 0);
                    }
                } catch (ex) {
                    msgBox(timeString + ':' + ex, "Time Conversion Error", 0);
                }
                break;
        }

        return d;
    }

    /**
    * Calculate the difference in supplied units between the supplied times, MOD 1 day
    *
    * @param	t1
    *					date object 
    * @param	t2
    *					date object 
    * @param	units
    *					string object should be one of 'seconds', 'minutes', 'hours'
    *
    * @return	number containing the difference between t1 and t2 MOD 1 Day
    */
    function timeDiff(t1, t2, units) {
        var diff, result;
        diff = dateDiff(t1, t2, units);

        if (units === 'seconds') {
            result = diff % (24 * 60 * 60)
            result = Math.round(result);
        } else if (units === 'minutes') {
            result = diff % (24 * 60)
            result = Math.round(result);
        } else if (units === 'hours') {
            result = diff % (24)
            result = Math.round(result);
        } else {
            result = 0;
        }

        return result;
    }

    /**
    * Returns a Date set to Today
    * 
    * @return Date
    */
    function today() {
        return now();
    }

    /**
    * Return the high subset from the supplied array
    *
    * @param	a
    *					array to extract from
    * @param	n
    *					number of elements to extract
    *
    * @return	array containing the extraction
    */
    function top(a, n) {
        validateArgs(arguments, "top", 2, 2, [Array, Number]);
        return a.slice(-n);
    }

    /**
    * Trims the supplied string or array
    *
    * @param	v
    *					Array or String to trim
    *
    * @return	trimmed array or string
    */
    function trim(v) {
        function trimString(s) {
            return s.trim();
        }
        function trimArray(a) {
            var i, r, v;
            r = [];
            for (i = 0; i < a.length; i += 1) {
                v = a[i];
                if (v && v.constructor === String) {
                    v = trimString(v);
                }
                if (r.length) {
                    r.push(v);
                } else if (v !== null && v !== undefined && v !== '' && !(v.constructor === Number && isNaN(v))) {
                    r.push(v);
                }
            }
            for (i = r.length - 1; i >= 0; i -= 1) {
                v = r[i];
                if (v === null || v === undefined || v === '' || (v.constructor === Number && isNaN(v))) {
                    r.pop();
                } else {
                    break;
                }
            }
            return r;
        }
        validateArgs(arguments, "trim", 1, 1, [null]);
        switch (v.constructor) {
            case Array:
                v = trimArray(v);
                break;
            case String:
                v = trimString(v);
                break;
        }
        return v;
    }

    /**
    * Return the name of the type of the supplied object
    *
    * @param	o
    *					object to test
    *
    * @return	string containing the name of the type of the supplied object
    */
    function typeofObject(o) {
        var type;
        validateArgs(arguments, "typeofObject", 1, 1, [null]);
        return mc.getobjectclass(o);
    }

    /**
    * Converts a string to upper case letters.
    * 
    * @param text
    *          text to convert to upper case.
    * @return the supplied string converted to upper case.
    */
    function upperCase(text) {
        validateArgs(arguments, "upperCase", 1, 1, [String]);
        return text.toUpperCase();
    }

    // TODO Implement the following functions
    //    function aboutBox() {
    //    }
    //    function getStatusBarText() {
    //    }
    //    function setStatusBarText(text) {
    //        text = undefined;
    //    }
    function setDebugFlag(debugFlag) {
        validateArgs(arguments, 'setDebugFlag', 1, 1, [Boolean]);
        setEnvironment('$$debugFlag', debugFlag ? '1' : '0');
    }
    function getEnvironment(name) {
        validateArgs(arguments, 'getEnvironment', 1, 1, [String]);
        return localStorage.getItem(name) || '';
    }
    function setEnvironment(name, value) {
        validateArgs(arguments, 'setEnvironment', 2, 2, [String, null]);
        try {
            localStorage.setItem(name, value);
        } catch (e) {
            if (e.code === 22) { // QUOTA_EXCEEDED_ERR - iPad bug workaround
                localStorage.removeItem(name);
                localStorage.setItem(name, value);
            } else {
                throw (e);
            }
        }
    }


    /**
    * set gps heartbeat options
    *
    * @param	callback
    *					Object to perform asynchronous formula callbacks
    * @param options
    *					json object containing configuration
    * @param successMessage
    *					optional string containing message to alert on successful start
    * @param failMessage
    *					optional string containing message to alert on failed start
    *
    * @return true/false
    */
    function setGpsHeartBeatOptions(callback, options, successMessage, failMessage) {
        var fail, success;
        success = function() {
            if (successMessage) {
                alert(successMessage);
            }
            callback.resume(true);
        };
        fail = function(message) {
            if (failMessage) {
                alert(failMessage + ': ' + message);
            }
            callback.resume(false);
        };

        if (navigator.hasOwnProperty('statusUpdater')) {
            navigator.statusUpdater.setOptions(options, success, fail);
        } else if (window.plugins.statusUpdater !== undefined) {
            window.plugins.statusUpdater.setOptions(options, success, fail);
        } else {
            fail('GPS Heartbeat Not available in Restricted Client');
        }
    }

    // Ideally this function will be overriden by the running process
    function defaultPostNotification($$result) {
        switch (this.state) {
            case 1:
                this.state = 2;
                mc.fl.notifygetunreadmessagecount(this, mc.fl.getusername());
                return this.async();
            case 2:
                this.state = 3;
                mc.fl.msgbox(this, 'There are ' + $$result + ' notifications pending. This process is unable to deal with these notifications.');
                return this.async();
            case 3: // msgbox return
                break;
        }
        return this.done(true); // True hides the notification indicator
    }

    /**
    * Opens the requested attachment in an appropriate viewer on the device.
    * 
    * @param subjectGuid
    *          Subject Guid to open
    * @param name 
    *          The name of the attachment to open (typically a guid)
    * @param launcher.app (opt)
    *          The app to use to open the attachment (eg. com.android.browser)
    * @param launcher.activity (opt)
    *          The activity to start (eg. com.android.browser.BrowserActivity)
    * @param launcher.mime (opt)
    *          MIME type to override detector
    */
    function viewDocument(subjectGuid, name, launcher, activity, mimeType) {
        validateArgs(arguments, "viewDocument", 2, 5, [String, String, null, String, String]);
        var launchObj;
        function success() {
            mc.hideActivity(true);
        }
        function fail(e) {
            mc.hideActivity(true);
        }

        if (mc.fs.availableForAtts) { //&& getPlatform() === 'android'
            //validateArgs(arguments, "viewDocument", 2, 3, [String, String, Object]);
            if (typeof launcher === "object") {
                launchObj = launcher;
            } else {
                launchObj = {};
                launchObj.app = launcher;
                launchObj.activity = activity;
                launchObj.mime = mimeType;
            }
            window.plugins.viewDocument.viewDocumentDirect(subjectGuid, name, success, fail, launchObj);
        } else {
            validateArgs(arguments, "viewDocument", 2, 5, [String, String, String, String, String]);
            function gotAttachment(data) {
                var dataParts, mimeParts;
                dataParts = data.split(';');
                mimeParts = dataParts[0].split(':');
                if (mimeParts[1] === '*/*') {
                    if (mimeType) {
                        mimeParts[1] = mimeType;
                        dataParts[0] = mimeParts.join(':');
                        data = dataParts.join(';');
                    }
                }
                window.plugins.viewDocument.viewDocument(data, success, fail, launcher, activity, mimeType);
            }

            mc.showActivity();
            mc.att.getAttachmentData(subjectGuid, name, gotAttachment);
        }
    }

    /**
    * Create a new attachment on the supplied subject with the supplied name and data
    *
    * @param callback
    *          callback to call on complete.
    * @param subjectGuid
    *          Subject Guid to save to
    * @param dataId 
    *          The name of the attachment to save
    * @param data 
    *          The data to store in the attachment        
    * @param mime (opt)
    *          Mime type to use in generating Data URI if neccessary.
    * @return
    *          The new attachment Name
    *       
    */
    function createDocument(callback, subjectGuid, dataId, data, mime) {
        var attachmentName = mc.db.guid();
        mc.fs.createNewAttachment(subjectGuid, attachmentName, dataId, mime, data, function(result) {
            if (typeof (callback) == "function")
                callback(attachmentName);
            else
                callback.resume(attachmentName);
        });
    }

    /**
    * Opens the requested attachment in an appropriate viewer on the device, directly from the attachments folder.
    * 
    * @param subjectGuid
    *          Subject Guid to open
    * @param name 
    *          The name of the attachment to open (typically a guid)
    * @param launcher.app (opt)
    *          The app to use to open the attachment (eg. com.android.browser)
    * @param launcher.activity (opt)
    *          The activity to start (eg. com.android.browser.BrowserActivity)
    * @param launcher.mime (opt)
    *          MIME type to override mime detection
    */
    function viewDocumentDirect(subjectGuid, name, launcher) {
        validateArgs(arguments, "viewDocumentDirect", 2, 3, [String, String, Object]);
        if (launcher) {
            if (mc.fs.availableForAtts) { // && getPlatform() === 'android'
                viewDocument(subjectGuid, name, launcher);
            } else {
                viewDocument(subjectGuid, name, launcher.app, launcher.activity, launcher.mime);
            }
        }
    }
    /**
    * Upload the shell log files
    * 
    * @Calling convention	ASYNC
    *
    * @param callback
    *					Object to perform asynchronous formula callbacks.
    * @param uri [optional]
    *					String containing the recipient
    */
    function uploadLogs(callback, uri) {
        validateArgs(arguments, "uploadLogs", 1, 2, [null, String]);

        if (window.plugins.log.uploadLogs) {
            function success(result) {
                if (callback) {
                    callback.resume(result);
                }
            }
            function failure() {
                if (callback) {
                    callback.resume(false);
                }
            }
            window.plugins.log.uploadLogs(success, failure, uri);
        } else {
            log.error('Missing function: window.plugins.log.uploadLogs');
        }
    }


    /**
    * Gets the current battery level
    * 
    */
    function getBatteryLevel() {
        return mc.battery.getLevel();
    }

    function getBatteryPluggedIn() {
        return mc.battery.getPluggedIn();
    }

    /**
    * Clears a signature
    * 
    */
    function clearSignature(callback, dataid) {
        validateArgs(arguments, "clearsignature", 2, 2, [null, String]);
        var jSigjQ = jQuery('ul[dataid="' + dataid + '"] div.jsig');
        var canvas = jQuery('ul[dataid="' + dataid + '"] div.jsig canvas')[0];
        if (jSigjQ) {
            if (canvas) canvas.width = canvas.width;
            jSigjQ.jSignature("reset");
        }
        clearData(callback, dataid);
    }

    /**
    * Gets a base64 PNG of the signature data for a signature question
    *
    */
    function getSignatureImageData(callback, subjectId, dataId, svg) {
        function gotAnswer(answer) {
            var imgData;
            if (answer) {
                if (svg)
                    imgData = answer[2];
                else
                    imgData = answer[1];
            } else {
                imgData = answer;
            }

            if (callback.resume)
                callback.resume(imgData)
            else
                callback(imgData);
        }
        dskAns(gotAnswer, subjectId, undefined, undefined, undefined, undefined, dataId);
    }

    function saveSettings(callback, data) {
        function done(result) {
            if (callback.constructor === Function) {
                callback(result);
            } else {
                callback.resume(result);
            }
        }
        function onError() {
            log.error('Failed to save settings to file system');
            done(false);
        }
        function onSuccess() {
            done(true);
        }
        validateArgs(arguments, "saveSettings", 2, 2, [null, null]);
        // Apply padding so data is not JSON parsable (WP8 Cordova bug)
        var content = '@@' + JSON.stringify(data);

        if (device && device.platform && device.platform === 'Android') {
            plugins.settings.setUserPreference('userPrefs', content, onSuccess, onError);
        } else {
            if (mc.fs.available) {
                mc.fs.saveUserData('settings', content, onSuccess, onError);
            } else {
                onError();
            }
        }
    }

    function readSettings(callback) {
        function done(result) {
            if (callback.constructor === Function) {
                callback(result);
            } else {
                callback.resume(result);
            }
        }
        function onError() {
            log.error('Failed to read settings from file system');
            done(null);
        }
        function onSuccess(content) {
            // Strip padding so data is once more JSON parsable (WP8 Cordova bug)
            var data = content.replace(/^@@/, '');
            done(JSON.parse(data));
        }
        validateArgs(arguments, "readSettings", 1, 1, [null]);

        if (device && device.platform && device.platform === 'Android') {
            plugins.settings.getUserPreference('userPrefs', onSuccess, onError);
        } else {
            if (mc.fs.available) {
                mc.fs.readUserData('settings', onSuccess, onError);
            } else {
                onError();
            }
        }
    }

    function clearOldSubjects(callback) {
        function done(result) {
            if (callback.constructor === Function) {
                callback(result);
            } else {
                callback.resume(result);
            }
        }
        function clear(procs) {
            var proc = procs.pop();
            if (proc) {
                mc.db.deleteAllSubjects(proc.value.id, proc.value.version, function() { clear(procs); });
            } else {
                done();
            }
        }
        validateArgs(arguments, "clearOldSubjects", 1, 1, [null]);
        clear(mc.db.getOldProcesses());
    }

	/**
    * Validate a dynamic forms schema
    *
	* @param
	*			Object to perform asynchronous formula callbacks.
    * @param schema
    *          	The schema to validate.
	* @param rules
	*			The rules to validate against.
    * @return
    *          .      
    */
	
	function validateFormSchema(callback, schema,rules) {
	    function done(result) {
	        if (callback.constructor === Function) {
	            callback(result);
	        } else {
	            callback.resume(result);
	        }
	    }

	    validateArgs(arguments, "validateFormSchema", 2, 3, [null, null, null]);

	    done(false);
	}
	
    mc.fl = {
        //        aboutbox: aboutBox,
        activitystart: activityStart,
        activitystop: activityStop,
        ans: ans,
        attachfilebyreference: attachFileByReference,
        bottom: bottom,
        calculate: calculate,
        canconnectatleast: canConnectAtLeast,
        canconnectviawifi: canConnectViaWifi,
        choicestotext: choicesToText,
        clearans: clearAns,
        clearoldsubjects: clearOldSubjects,
        cleardata: clearData,
        cleardbandreplicate: clearDbAndReplicate,
        clearpagestack: clearPageStack,
        clearsignature: clearSignature,
        clearsubjectstack: clearSubjectStack,
        clonecurrentsubject: cloneCurrentSubject,
        clonesubject: cloneSubject,
        createdocument: createDocument,
        combinechoices: combineChoices,
        composeemail: composeEmail,
        contains: contains,
        createchoices: createChoices,
        created: created,
        createobject: createObject,
        createsubject: createSubjectGuid,
        createsubjectobject: createSubjectObject,
        currentpage: currentPage,
        currentprocessid: currentProcessId,
        currentrowidx: currentRowIdx,
        currentsubject: currentSubjectGuid,
        currentsubjectobject: currentSubjectObject,
        data: data,
        dataproviderrequest: dataProviderRequest,
        datarequest: dataRequest,
        date: date,
        dateadd: dateAdd,
        dateaddtime: dateAddTime,
        datediff: dateDiff,
        datefromparts: dateFromParts,
        dateparts: dateParts,
        datesubtime: dateSubTime,
        datetimecombine: dateTimeCombine,
        dbgmsgbox: dbgMsgBox,
        deletelogfiles: deleteLogFiles,
        deletesubject: deleteSubject,
        dskans: dskAns,
        dskcacheans: dskCacheAns,
        dskcachedata: dskCacheData,
        dskcachesummaryvalue: dskCacheSummaryValue,
        dskclosesubject: dskCloseSubject,
        dskcurrentpage: dskCurrentPage,
        dskdata: dskData,
        dskgetsummaryvalue: dskGetSummaryValue,
        dskhasdata: dskHasData,
        dskisanswered: dskIsAnswered,
        dskisdatapresent: dskHasData,
        dsksetans: dskSetAns,
        dsksetdata: dskSetData,
        dsksetsummaryvalue: dskSetSummaryValue,
        dynamicchoicestotext: dynamicChoicesToText,
        element: element,
        error: error,
        errortext: errorText,
        execFormula: execFormula,
        execjsasync: execJsAsync,
        execjssync: execJsSync,
        execjstext: execJsText,
        exitapp: exitApp,
        explode: explode,
        format: format,
        getfilereference: getFileReference,
        getbatterylevel: getBatteryLevel,
        getbatterypluggedin: getBatteryPluggedIn,
        getcodetype: getCodeType,
        getcurrentlocation: getCurrentLocation,
        getdebugflag: getDebugFlag,
        getdirections: getDirections,
        getenvironment: getEnvironment,
        getformattype: getFormatType,
        getlog: getLog,
        getloglevel: logGetLevel,
        getobjectvalue: getObjectValue,
        getorientation: getOrientation,
        getplatform: getPlatform,
        getparentsubject: getParentSubject,
        getselectedrows: getSelectedRows,
        getserviceusername: getServiceUserName,
        getsignatureimagedata: getSignatureImageData,
        //        getstatusbartext: getStatusBarText,
        getsubjectguid: getSubjectGuid,
        getsubjectobject: getSubjectObject,
        getsubjectvalue: getSubjectValue,
        getsummaryvalue: getSummaryValue,
        getsyncinfo: getSyncInfo,
        getusername: getUserName,
        getuserinfo: getUserInfo,
        guidfromsyncid: guidFromSyncID,
        gotopage: gotoPage,
        gotoprovisioningurl: gotoProvisioningUrl,
        gotourl: gotoUrl,
        hasdata: hasData,
        implode: implode,
        isanswered: isAnswered,
        isboolean: isBoolean,
        isclientsubject: isClientSubject,
        isdatapresent: hasData,
        isdatetime: isDateTime,
        iserror: isError,
        ishidden: isHidden,
        islist: isList,
        isnull: isNull,
        isnumber: isNumber,
        isreachable: isReachable,
        isreplicating: isReplicating,
        isrestricted: isRestricted,
        isserversubject: isServerSubject,
        istext: isText,
        isxmldataset: isXmlDataSet,
        left: left,
        length: length,
        list: list,
        log: logInfo,
        logaddappender: logAddAppender,
        logdebug: logDebug,
        logerror: logError,
        logfatal: logFatal,
        loggetlevel: logGetLevel,
        loginfo: logInfo,
        logmessage: logInfo,
        logremoveallappenders: logRemoveAllAppenders,
        logremoveappender: logRemoveAppender,
        logshell: logInfo,
        logtrace: logTrace,
        logwarn: logWarn,
        lookup: lookup,
        lowercase: lowerCase,
        maillogs: mailLogs,
        makephonecall: makePhoneCall,
        matchregex: matchRegEx,
        media: media,
        modifysubject: modifySubject,
        modifysubjectsyncinfo: modifySubjectSyncInfo,
        msgbox: msgBoxAsync,
        msgboxasync: msgBoxAsync,
        newcurrentpageonclose: newCurrentPageOnClose,
        notifyaddchannel: notifyAddChannel,
        notifycancelallmessagenotifications: notifyCancelAllMessageNotifications,
        notifycancelall: notifyCancelAllMessageNotifications,
        notifycancelmessagenotification: notifyCancelMessageNotification,
        notifycancelmessage: notifyCancelMessageNotification,
        notifydeletemessage: notifyDeleteMessage,
        notifygetmessages: notifyGetMessages,
        notifygetunreadmessages: notifyGetUnreadMessages,
        notifygetunreadmessagecount: notifyGetUnreadMessageCount,
        notifygetunreadcount: notifyGetUnreadMessageCount,
        notifylistchannels: notifyListChannels,
        notifymessagereceived: notifyMessageReceived,
        notifyreceivemessagenotification: notifyReceiveMessageNotification,
        notifyreceivemessage: notifyReceiveMessageNotification,
        notifyremovechannel: notifyRemoveChannel,
        notifysendmessage: notifySendMessage,
        now: now,
        number: number,
        opensubject: openSubject,
        pageback: pageBack,
        pagehome: pageHome,
        pagenext: pageNext,
        poplist: popList,
        poppage: popPage,
        popsubject: popSubject,
        postNotification: defaultPostNotification,
        pushlist: pushList,
        pushpage: pushPage,
        pushsubject: pushSubject,
        querysummarydata: querySummaryData,
        querysummaryvalues: querySummaryValues,
        querysummaryvaluesnonunique: querySummaryValuesNonUnique,
        readsettings: readSettings,
        refreshcurrentpage: refreshCurrentPage,
        refreshhidden: refreshHidden,
        refreshquestion: refreshQuestion,
        refreshiscroll: refreshiScroll,
        replicate: replicate,
        replicatedialog: replicateDialog,
        replicatepage: replicatePage,
        revert: revert,
        right: right,
        savesettings: saveSettings,
        scan: scan,
        setans: setAns,
        setdata: setData,
        setdebugflag: setDebugFlag,
        setenvironment: setEnvironment,
        setfocus: setFocus,
        setgpsheartbeatoptions: setGpsHeartBeatOptions,
		setreturnpage: setReturnPage,
        enablelogging: enableLogging,
        disablelogging: disableLogging,
        setobjectvalue: setObjectValue,
        //        setstatusbartext: setStatusBarText,
        setpagetitlebartext: setPageTitleBarText,
		setzumotoken: setZumoToken,
        settitlebartext: setTitleBarText,
        setsubjectvalue: setSubjectValue,
        setsyncinfo: setSyncInfo,
        startgpsheartbeat: startGpsHeartBeat,
        startmonitoringregion: startMonitoringRegion,
        stopgpsheartbeat: stopGpsHeartBeat,
        stopmonitoringregion: stopMonitoringRegion,
        split: split,
        subjectcontext: subjectContext,
        substring: subString,
        summaryitem: getSummaryValue,
        summaryquery: summaryQuery,
        switchcss: switchCss,
        text: text,
        time: time,
        timediff: timeDiff,
        today: today,
        top: top,
        trim: trim,
        typeofobject: typeofObject,
        uploadlogs: uploadLogs,
        uppercase: upperCase,
		validateformschema: validateFormSchema,
        viewdocument: viewDocument,
        viewdocumentdirect: viewDocumentDirect,
        zumorequest: zumoRequest,
        zumocleartoken: zumoClearToken
    };
} (window.jmfw, window.mCapture));

// Code for handling geofences in Android 8.1:

document.addEventListener("deviceready", function() {
	if( window.geofence !== undefined ) {
		window.geofence.initialize().then(function () {
			console.log("Successful geofence initialization");
			window.geofence.onTransitionReceived = function (geofences) {
				geofences.forEach(function (geo) {
					console.log('Geofence transition detected', geo);
					var expiry = new Date().getTime() + (999 * 365 * 24 * 60 * 60 * 1000);
					var content = {};
					if( geo.transitionType == 1 )  {
						content.direction = "entered";						
					} else  {
						content.direction = "exited";						
					}
					// content = JSON.stringify(content);
					plugins.notify.sendMessage({"channel":"$location$", "subchannel":geo.id, "expiry":expiry, "provider":"xcallbackurl", "content": content }, function(e, msgid) {
						if( e === undefined ) {
							console.log("Geofence message sent: " + msgid);
						}
					});
				});
			};
		}, function (error) {
			console.log("Error init geofence", error);
		});
	}	
}, false);


/*
** END OF MC2.FL.JS
*/
/*jslint browser: true, devel: true, bitwise: true, continue: true, evil: true, forin: true, nomen: true, plusplus: true, regexp: true, sloppy: true, white: true */
(function($, Q, mc) {
    var alphabet, isPageOffsetAware, isTouchable, passwordMask, popupPages, qData, qType, questionMaker, questions, loadMapsDeferred;

    function questionType(question) {
        var type, cls, a, i, n;
        cls = question.attr('class');
        if (cls !== undefined && cls !== null) {
            a = cls.split(' ');
            n = a.length;
            for (i = 0; i < n; i += 1) {
                type = qType[a[i]];
                if (type !== undefined) {
                    return type;
                }
            }
        }
        return null;
    }

    function question(spec) {
        var initTasks, row, that;

        function getDataId() {
            return spec.question.attr('dataid');
        }

        function getDesignData(id) {
            if (qData !== undefined) {
                return qData[id || getDataId()];
            }
            return undefined;
        }

        function getDesignValue(name, id) {
            var designData, v;
            designData = getDesignData(id);
            if (designData !== undefined && designData !== null) {
                v = designData[name];
            }
            return v;
        }

        function execTemplate(template, data) {
            var html;
            if (template) {
                try {
                    html = $.tmpl(template, data || mc.db.getCurrentSubject());
                } catch (e) {
                    html = 'Template exception: ' + e + "<BR>" + $.tmplString(template);
                }
            }
            return html;
        }

        function getTemplate(name) {
            var template, templateId;
            templateId = spec.question.attr('templateid');
            if (templateId === undefined || templateId === null) {
                templateId = spec.question.attr('dataid');
            }
            if (templateId) {
                template = getDesignValue(name || 'template', templateId);
            }
            if (!template) {
                template = getDesignValue(name || 'template');
            }
            return template;
        }

        function applyTemplate(name, data) {
            return execTemplate(getTemplate(name || 'template'), data);
        }

        function deleteValue() {
            mc.db.deleteValue(getDataId(), row);
        }

        function ensureAnswer(row) {
            mc.db.ensureValue(getDataId(), row);
        }

        function getAnswerArrayLength() {
            return mc.db.getValueArrayLength(getDataId());
        }

        function execAction(name, async) {
            name = name || 'action';
            mc.fl.execFormula(getDesignValue(name), undefined, undefined, async);
        }

        function getActionList() {
            return getDesignValue('actions');
        }

        function getBackground() {
            return getDesignValue('background');
        }

        function getCalculatedValue(callback) {
            var value;
            value = getDesignValue('calcval');
            if (value !== undefined && value !== null && value.constructor === Function) {
                value(callback);
            } else {
                callback(value);
            }
        }

        function getChoices(callback) {
            var choices;
            choices = getDesignValue('choices');
            if (choices) {
                switch (choices.constructor) {
                    case Array:
                        callback(choices);
                        break;
                    case Function:
                        choices(callback);
                        break;
                    default:
                        callback([]);
                        break;
                }
            } else {
                callback([]);
            }
        }

        function getColumns() {
            var columns;
            columns = getDesignValue('columns');
            if (columns) {
                switch (columns.constructor) {
                    case Array:
                        break;
                    case Function:
                        columns = columns();
                        break;
                    default:
                        columns = [];
                        break;
                }
            } else {
                columns = [];
            }
            return columns;
        }

        function getDefaultValue(callback) {
            var value;
            value = getDesignValue('defval');
            if (value && value.constructor === Function) {
                value = value(callback);
                /*
                if (value !== undefined) {
                callback(value);
                }
                */
            } else {
                callback(value);
            }
        }

        function getLatch(name) {
            var latch, templateId;
            templateId = spec.question.attr('templateid');
            if (templateId === undefined) {
                templateId = spec.question.attr('dataid');
            }
            if (templateId) {
                latch = getDesignValue('latch', templateId);
            }
            if (latch === undefined || latch === null) {
                latch = getDesignValue('latch');
            }
            name = undefined;
            return latch;
        }
        //get the data ID of the question that holds
        // the center point for the map. if undefined use 'My Location'

        function getMapCenterLocationQuestionID() {
            return getDesignValue('mapcenterlocation');
        }
        //get the data ID of the question that holds
        // the center pint url for the map.
        // only valid if getMapCenterLocationQuestionID()
        // is valid

        function getMapCenterPinURL() {
            return getDesignValue('mapcenterpin');
        }

        function getGeoCodeDelay() {
            return getDesignValue('mapgeocodedelay');
        }

        //show myLocation flag

        function getMapShowMyLocation() {
            return getDesignValue('showmylocation');
        }

        function getMapMyLocationPinURL() {
            return getDesignValue('mylocationpin');
        }

        function getPageId() {
            return spec.page.attr('id');
        }

        function getPageObject() {
            return spec.page;
        }

        function getQuestionId() {
            return spec.question.attr('id');
        }

        function getQuestionObject() {
            return spec.question;
        }

        function getRowHeight() {
            return getDesignValue('rowHeight');
        }

        function getRowIndex() {
            return row;
        }

        function getType() {
            return getDesignValue('type');
        }

        function setValue(v, callback) {
            var designData, stamp;
            stamp = false;
            designData = getDesignData();
            if (designData !== undefined) {
                stamp = designData.stamps;
            }
            return mc.db.setValue(getDataId(), v, row, stamp, callback);
        }

        function getValue(callback, ignoreDefault, dontSaveDefault) {
            var value = mc.db.getValue(getDataId(), row);
            if (value === undefined && ignoreDefault !== true) {
                getDefaultValue(function(value) {
                    if (!dontSaveDefault && value !== undefined) {
                        setValue(value, function() {
                            callback(value, true);
                        });
                    } else {
                        callback(value, true);
                    }
                });
            } else {
                callback(value, false);
            }
        }

        function initialize() { }

        function ready(b) {
            if (b === undefined) {
                return initTasks <= 0;
            }
            if (b) {
                if (initTasks > 0) {
                    initTasks -= 1;
                    if (initTasks === 0) {
                        spec.question.trigger('questionReady');
                    }
                }
            } else {
                initTasks += 1;
            }
        }

        function load(f) {
            function doLoad() {
                if (f && f.constructor === Function) {
                    f();
                }
                spec.question.trigger('questionLoaded');
            }

            function questionReady(e) {
                spec.question.unbind('questionReady', questionReady);
                doLoad();
                e = undefined;
            }
            if (ready()) {
                doLoad();
            } else {
                spec.question.bind('questionReady', questionReady);
            }
        }

        function postLoad() { }

        function postUnload() { }

        function refresh(callback) {
            function loaded(e) {
                spec.question.unbind('questionLoaded', loaded);
                callback();
                e = undefined;
            }
            if (callback && callback.constructor === Function) {
                spec.question.bind('questionLoaded', loaded);
            }
            that.initialize();
            that.load();
        }

        function save() { }

        function setRowIndex(rowIndex) {
            row = rowIndex;
        }

        function showPlaceholder(el, placeholder) {
            var html;
            placeholder = placeholder || 'placeholder';
            html = getDesignValue(placeholder);
            if (html) {
                el.html(html);
            } else {
                el.empty();
            }
        }

        function unload() { }

        function valueChanged() {
            var formulaName, formula;
            formulaName = getQuestionId() + '_ValueChanged';
            mc.currentPage(getPageId());
            formula = mc.fl[formulaName];
            if (formula !== undefined && formula.constructor === Function) {
                formula();
            }
        }
        initTasks = 0;
        that = {};
        that.applyTemplate = applyTemplate;
        that.deleteValue = deleteValue;
        that.ensureAnswer = ensureAnswer;
        that.execAction = execAction;
        that.execTemplate = execTemplate;
        that.getActionList = getActionList;
        that.getAnswerArrayLength = getAnswerArrayLength;
        that.getBackground = getBackground;
        that.getCalculatedValue = getCalculatedValue;
        that.getChoices = getChoices;
        that.getColumns = getColumns;
        that.getDataId = getDataId;
        that.getDefaultValue = getDefaultValue;
        that.getDesignData = getDesignData;
        that.getDesignValue = getDesignValue;
        that.getLatch = getLatch;
        that.getMapCenterLocationQuestionID = getMapCenterLocationQuestionID;
        that.getGeoCodeDelay = getGeoCodeDelay;
        that.getMapCenterPinURL = getMapCenterPinURL;
        that.getMapMyLocationPinURL = getMapMyLocationPinURL;
        that.getMapShowMyLocation = getMapShowMyLocation;
        that.getPageId = getPageId;
        that.getPageObject = getPageObject;
        that.getQuestionId = getQuestionId;
        that.getQuestionObject = getQuestionObject;
        that.getRowHeight = getRowHeight;
        that.getRowIndex = getRowIndex;
        that.getTemplate = getTemplate;
        that.getType = getType;
        that.getValue = getValue;
        that.initialize = initialize;
        that.load = load;
        that.postLoad = postLoad;
        that.postUnload = postUnload;
        that.ready = ready;
        that.refresh = refresh;
        that.save = save;
        that.setRowIndex = setRowIndex;
        that.setValue = setValue;
        that.showPlaceholder = showPlaceholder;
        that.unload = unload;
        that.valueChanged = valueChanged;
        return that;
    }

    function popupPage(column, cls, qspec) {
        var page;
        page = column.find('.' + cls);
        if (page.length === 0) {
            page = $(window.document.createElement('div'));
            page.addClass('jmuiPage', cls);
			page.addClass('md_popupPage');
            if ($.isIE) {
                page.addClass('jmuiPageScroller');
            }
            page.html(popupPages[cls]);
            column[0].appendChild(page[0]);
			page[0].id = 'md_popupPage_'+qspec.getQuestionId();
			
			container = page.find('div.md_popupQuestionContainer');
			if (container.length >0) {
				containerDiv = container[0];
				containerDiv.id = 'md_popupQuestion_'+qspec.getQuestionId();
				container.addClass(qspec.getDesignValue('usercss'));
			}
			
            $.ui.bindPage(page);
        }
        return page;
    }

    function popupQuestion(spec) {
        var that;

        function enable(b) {
            spec.question[0].disabled = !b;
        }
        that = question(spec);
        that.enable = enable;
        return that;
    }

    function designData(dataId) {
        return qData[dataId];
    }

    function drawSketch(canvas, commands) {
        var ctx, i, lastPoint, n, parts;

        function partsToCanvasCoordinates(parts) {
            var point = {
                x: parseFloat(parts[1]),
                y: parseFloat(parts[2])
            };
            return point;
        }
        if (commands && commands.constructor === Array) {
            n = commands.length;
            if (n > 0) {
                ctx = canvas[0].getContext('2d');
                for (i = 0; i < n; i += 1) {
                    parts = commands[i].split('|');
                    if (parts.length === 3) {
                        switch (parts[0]) {
                            case 'moveTo':
                                lastPoint = partsToCanvasCoordinates(parts);
                                break;
                            case 'lineTo':
                                if (lastPoint !== undefined) {
                                    ctx.beginPath();
                                    ctx.moveTo(lastPoint.x, lastPoint.y);
                                    lastPoint = partsToCanvasCoordinates(parts);
                                    ctx.lineTo(lastPoint.x, lastPoint.y);
                                    ctx.closePath();
                                    ctx.stroke();
                                }
                                break;
                        }
                    }
                }
                ctx.closePath();
                ctx.stroke();
            }
        }
    }

    function eraseSketch(canvas) {
        var ctx = canvas[0].getContext('2d');
        ctx.clearRect(0, 0, canvas[0].width, canvas[0].height);
    }

    function getEventPosition(e) {
        var offset, pos, scroller;
        pos = {
            x: 0,
            y: 0
        };
        if (e.offsetX !== undefined) {
            pos.x = e.offsetX;
            pos.y = e.offsetY;
        } else {
            offset = $(e.target).offset();
            pos.x = e.pageX - offset.left;
            pos.y = e.pageY - offset.top;
            scroller = $($.ui.parentPage(e.target)).find('.jmuiScroller > div');
            if (scroller.length) {
                if (scroller[0].jmuiScroller.x) {
                    pos.x += scroller[0].jmuiScroller.x;
                }
                if (scroller[0].jmuiScroller.y) {
                    pos.y -= scroller[0].jmuiScroller.y;
                }
            }
        }
        return pos;
    }

    function createActionListRows(question, ul) {
        var actions, i, li, q, ulPage;

        function createActionRow(index) {
            function createRow(hide) {
                if (hide !== true) {
                    li = $(window.document.createElement('li'));
                    li.addClass('jmuiArrow');
                    li.attr('actionIndex', i);
                    if (actions[i].template) {
                        li.html(question.execTemplate(actions[i].template));
                    } else if (actions[i].text) {
                        li.text(actions[i].text);
                    }
                    ul[0].appendChild(li[0]);
                }
            }
            mc.fl.execFormula(actions[index].hideFormula, createRow, createRow, true);
        }

        function invokeAction(e) {
            var me;

            function success(e) {
                log.debug('Success executing ' + actions[me.attr('actionIndex')].formulaName);
                ul.find('li.jmuiSelected').removeClass('jmuiSelected');
                e = undefined;
            }

            function error(e) {
                log.error('Error executing ' + actions[me.attr('actionIndex')].formulaName);
                alert(e);
                ul.find('li.jmuiSelected').removeClass('jmuiSelected');
            }
            if (e.jmuiTarget) {
                $(e.jmuiTarget).addClass('jmuiSelected');
            }
            me = $(this);
            log.debug('Action list item hit. After 100ms will execute ' + actions[me.attr('actionIndex')].formulaName);
            setTimeout(function() {
                log.debug('Inside timer will now execute ' + actions[me.attr('actionIndex')].formulaName);
                mc.fl.execFormula(actions[me.attr('actionIndex')].formulaName, success, error, true);
            }, 100);
        }
        q = question.getQuestionObject();
        actions = question.getActionList();
        ul.find('li').remove();
        ulPage = $($.ui.parentPage(ul[0]));
        for (i = 0; i < actions.length; i += 1) {
            createActionRow(i);
        }
        $.ui.generateTaps(ul.find('li').bind($.ui.tapEvent, invokeAction));
    }

    function bindEditActionList(question) {
        var editPage, page, q, ul;
        page = question.getPageObject();
        editPage = popupPage($($.ui.parentColumn(page[0])), 'editActionListPage',question);
        q = question.getQuestionObject();
        $.ui.generateTaps(q);
        ul = editPage.find('ul');
        q.bind($.ui.tapEvent, function() {
            function goBack() {
                editPage.find('.jmuiBackButton').unbind($.ui.tapEvent, goBack);
                $.ui.gotoPage(page, 'jmuiSlide', true, true);
            }
            if (!q.attr('disabled')) {
                editPage.find('h2').text(q.find('h3').text());
                editPage.find('.jmuiBackButton').bind($.ui.tapEvent, goBack);
                createActionListRows(question, ul);
                $.ui.gotoPage(editPage, 'jmuiSlide', false, true);
            }
        });
    }

    function initControls() { }

    function initQuestions(questions) {
        qData = questions;
    }

    function inlineQuestion(spec) {
        var that;

        function enable(b) {
            spec.question.find('*').each(function() {
                this.disabled = !b;
            });
        }
        that = question(spec);
        that.enable = enable;
        return that;
    }

    function idFromObject(o) {
        var id;
        if (o) {
            switch (o.constructor) {
                case Object:
                case Array:
                case window.NodeList:
                    id = o[0].id;
                    break;
                case String:
                    if (o[0] === '#') {
                        id = o.slice(1);
                    } else {
                        id = o;
                    }
                    break;
            }
        }
        return id;
    }

    function isQuestionHidden(questionId) {
        var b, q;
        b = false;
        q = $('#' + 'md_' + questionId + '_container');
        if (q && q.length) {
            b = (q.style('display') === 'none');
        }
        return b;
    }

    function objectFromId(id) {
        var o;
        if (id) {
            switch (id.constructor) {
                case Object:
                case Array:
                case window.NodeList:
                    o = id;
                    break;
                case String:
                    if (id[0] !== '#') {
                        id = '#' + id;
                    }
                    o = $(id);
                    break;
            }
        }
        return o;
    }
    
    function loadMapsComplete() {
        delete window.loadMapsCompleteCallback;
        loadMapsDeferred.resolve();
    }
    
    function loadMapsAsync() {
        if (!loadMapsDeferred) {
            var head = document.getElementsByTagName('head')[0],
                tag = document.createElement('script'),
                deferred = Q.defer();
            tag.src = mc.mapApi + '&callback=loadMapsCompleteCallback' + (mc.mapKey ? '&' + mc.mapKey : '');
            tag.type = 'text/javascript';
            tag.onerror = function() {
                deferred.reject();
            }                        
            window.loadMapsCompleteCallback = loadMapsComplete;
            loadMapsDeferred = deferred;
            head.appendChild(tag);
        }
        return loadMapsDeferred.promise;
    }

    function createMapRows(question, map, geocoder, infowindow) {
        //variables
        var columns, html, i, j, mapCenterLocID, mapCenterPin, marker_address, myLoc, myLocPin, myLatLng, myMarker, page, pinIcon, rowHeight, subject, geoCodeDelay;
        //helper functions

        function locationToLatLng(loc) {
            var lat, lng, values;
            values = loc.split(",");
            if (values.length === 2) {
                lat = parseFloat(values[0].trim());
                lng = parseFloat(values[1].trim());
                return new window.google.maps.LatLng(lat, lng);
            }
            return undefined;
        }
        // convert a string (address) into a latLng point 

        function geocodeRow(request, geocoder, callback) {
            if (request.location && request.location.length > 0) {
                callback(locationToLatLng(request.location));
            } else {
                log.debug("Geocode '" + request.address + "'...");
                geocoder.geocode(request, function(results, status) {
                    if (status === window.google.maps.GeocoderStatus.OK) {
                        var latLng = results[0].geometry.location;
                        log.debug("Geocode '" + request.address + "'... Done - " + latLng);
                        callback(latLng);
                    } else if (status === window.google.maps.GeocoderStatus.OVER_QUERY_LIMIT) {
                        log.error("Geocode of  '" + request.address + "'  was not successful for the following reason: " + status + " - will retry");
                        alert("Geocode of  '" + request.address + "'  was not successful for the following reason: " + status + " - will retry");
                        setTimeout(function() {
                            geocodeRow(request, geocoder, callback)
                        },
						250);
                    } else {
                        log.error("Geocode of  '" + request.address + "' was not successful for the following reason: " + status);
                        alert("Geocode of  '" + request.address + "' was not successful for the following reason: " + status);
                        callback(null);
                    }
                });
            }
        }
        //create a map marker at a given point, with a 
        // given html bubble shown when marker is clicked

        function createMarker(point, html_txt, markerImage, action, index) {
            var marker = new window.google.maps.Marker({
                position: point,
                icon: markerImage
            });
            window.google.maps.event.addListener(marker, "click", function() {
                var div;
                div = $(document.createElement('div'));
                div.addClass('bubble-background');
                div.html(html_txt);
                div.bind('click', function(e) {
                    var formula, formulaName;
                    infowindow.close();
                    if (action === '_RowTap') {
                        page.attr('rowIndex', index);
                    }
                    formulaName = question.getQuestionId() + action;
                    mc.currentPage(question.getPageId());
                    formula = mc.fl[formulaName];
                    if (formula !== undefined && formula.constructor === Function) {
                        if (action === '_RowTap') {
                            mc.showActivity();
                            formula(function(pageId) {
                                mc.hideActivity();
                                if (action === '_RowTap' && pageId && typeof pageId === 'string') {
                                    $.ui.gotoPage($('#' + pageId), 'jmuiSlide');
                                }
                            });
                        } else {
                            formula();
                        }
                    }
                    e = undefined;
                });
                infowindow.setContent(div[0]);
                infowindow.open(map, this);
            });
            question.addMarker(marker);
            return marker;
        }
        //return a callback function for the gecodeRow async function

        function makeCallback(mrkHtml, markerImage, action, index) {
            return function(latLng) {
                var marker = createMarker(latLng, mrkHtml, markerImage, action, index);
                marker.setMap(map);
            };
        }

        function centerMap(map, locationID, pin, myLatLng) {
            if ((locationID !== undefined) && (locationID.length > 0)) {
                //locationID is the data id of a question, whose ANSWER
                // is where to center the map				
                var request = {};
                ///### need to know the type of question - location or other
                //				var other = $('#' + locationID);
                //				if (questionType(other) === qType.locationInline) {
                //					//location question, so no lookup
                //					request.location = mc.db.getValue(locationID);
                //				} else {
                //					//other so use maps api to convert to location
                request.address = mc.db.getValue(locationID);
                //				}
                geocodeRow(request, geocoder, function(latLng) {
                    var html, marker;
                    map.panTo(latLng);
                    html = question.applyTemplate('mapCenterTemplate');
                    marker = createMarker(latLng, html, pin, '_CenterTap');
                    marker.setMap(map);
                });
            } else {
                if (myLatLng !== undefined) {
                    //move map center to this position
                    map.panTo(myLatLng);
                }
            }
        }

        function HandleRow(value, i, columns, geocoder, delay) {
            if (i < value.length) {
                if (value[i] && value[i].constructor === Array) {
                    //new geocode request		
                    marker_address = {};
                    pinIcon = undefined;
                    //loop over each column, looking for the 'Pin' & location colums
                    for (j = 0; j < value[i].length && j < columns.length; j += 1) {
                        if (columns[j].type === 'pin') {
                            if (value[i][j].length > 0) {
                                pinIcon = new window.google.maps.MarkerImage(value[i][j]);
                            }
                        }
                        if (columns[j].location === 'address') {
                            marker_address.address = value[i][j];
                        } else if (columns[j].location === 'position') {
                            marker_address.location = value[i][j];
                        }
                    }
                    subject = mc.db.getCurrentSubject();
                    subject._mapRowIndex = i;
                    subject._columns = columns;
                    subject._answer = value;
                    html = question.applyTemplate('bubbleTemplate');
                    delete subject._mapRowIndex;
                    delete subject._columns;
                    delete subject._answer;
                    if (!html) {
                        var data = {};
                        for (j = 0; j < columns.length; j += 1) {
                            data[columns[j].id] = value[i][j];
                        }
                        html = question.applyTemplate('rowTemplate', data);
                    }
                    subject = undefined;
                    //html.find('img').bind('load', function() {
                    //	$.ui.refreshScroller(page);
                    //});
                    try {
                        geocodeRow(marker_address, geocoder, makeCallback(html, pinIcon, '_RowTap', i));
                    } catch (e) {
                        alert('Error:' + e);
                    }
                }
                i++;
                setTimeout(function() {
                    HandleRow(value, i, columns, geocoder, delay)
                },
					delay);
            }
        }

        //body of createMapRows function
        window.google.maps.event.trigger(map, 'resize');
        columns = question.getColumns();
        if (columns) {
            rowHeight = question.getRowHeight();
            page = $($.ui.parentPage(map.getDiv()));
            page.removeAttr('rowIndex');
            question.setRowIndex(null);
            geoCodeDelay = question.getGeoCodeDelay();
            if (!geoCodeDelay) {
                geoCodeDelay = 150;
            }
            question.getValue(function(value) {
                if (value && value.constructor === Array) {
                    setTimeout(
						function() {
						    HandleRow(value, 0, columns, geocoder, geoCodeDelay)
						},
						geoCodeDelay);
                }
            });
            //get my location, and add a marker pin here
            myLoc = mc.fl.getcurrentlocation(['lat', 'long']);
            //alert('My Location:' + myLoc);
            if (myLoc !== undefined) {
                //alert(myLoc.latitude);
                //alert(myLoc.longitude);
                myLatLng = new window.google.maps.LatLng(myLoc.latitude, myLoc.longitude);
            }
            //center the map
            mapCenterLocID = question.getMapCenterLocationQuestionID();
            mapCenterPin = question.getMapCenterPinURL();
            centerMap(map, mapCenterLocID, mapCenterPin, myLatLng);
            if (question.getMapShowMyLocation()) {
                myLocPin = question.getMapMyLocationPinURL();
                html = question.applyTemplate('myLocactionTemplate');
                myMarker = createMarker(myLatLng, html, myLocPin, '_MyLocTap');
                myMarker.setMap(map);
            }
            $.ui.refreshScroller(page);
        }
    }

    function createFilterRows(question, ul) {
        var el, offset;

        function edit(e) {
            var formulaName, me, param;

            function callback(value) {
                if (!question.getLatch()) {
                    me.removeClass('jmuiSelected');
                    question.save();
                }
                if (value) {
                    alert(value);
                }
            }
            if (!$.ui.defaultPrevented(e)) {
                me = $(this);
                if (question.getLatch()) {
                    me.toggleClass('jmuiSelected');
                } else {
                    me.parent().find('.jmuiSelected').removeClass('jmuiSelected');
                    me.addClass('jmuiSelected');
                }
                question.save();
                formulaName = question.getQuestionId() + '_RowTap';
                if (mc.fl[formulaName] && mc.fl[formulaName].constructor === Function) {
                    if (question.getDesignValue('xmlName')) {
                        param = me[0].mdcRow;
                    } else {
                        param = me.attr('rowGuid');
                    }
                    mc.fl.execFormula(formulaName, callback, callback, true, param);
                } else {
                    callback();
                }
            }
        }

        function gotValue(value) {
            var comparison, conditions, distinct, gotRows, limit, paginate, processId, searchName, sort, summaryNames, table, tbody, xmlName;

            /*
            function loadBatch(el) {
            var li, ul;
            if (!question.busy) {
            question.busy = true;
            if (el.nodeName === 'TD') {
            tbody = el;
            while (tbody.nodeName !== 'TBODY') {
            tbody = tbody.parentElement;
            }
            if (tbody) {
            tbody = $(tbody);
            if (paginate) {
            tbody.empty();
            } else {
            tbody.find('tr:last-of-type').remove();
            }
            }
            } else {
            li = el;
            while (li.nodeName !== 'LI') {
            li = li.parentElement;
            }
            if (li) {
            li = $(li);
            if (paginate) {
            ul = li.parent();
            ul.find('li:not(.searchBar)').remove();
            } else {
            li.remove();
            }
            }
            }
            if (xmlName) {
            mc.db.queryXmlSummaries(processId, xmlName, summaryNames, conditions, limit, offset, gotRows);
            } else {
            mc.db.querySummaries(processId, summaryNames, conditions, distinct, sort, limit, offset, gotRows);
            }
            }
            }
            */
            function loadBatch(el) {
                var li, ul;
                if (!question.busy) {
                    question.busy = true;
                    mc.showActivity();
                    function gotResults(rows) {
                        if (el.nodeName === 'TD') {
                            tbody = el;
                            while (tbody.nodeName !== 'TBODY') {
                                tbody = tbody.parentElement;
                            }
                            if (tbody) {
                                tbody = $(tbody);
                                if (paginate) {
                                    tbody.empty();
                                } else {
                                    tbody.find('tr:last-of-type').remove();
                                }
                            }
                        } else {
                            li = el;
                            while (li.nodeName !== 'LI') {
                                li = li.parentElement;
                            }
                            if (li) {
                                li = $(li);
                                if (paginate) {
                                    ul = li.parent();
                                    ul.find('li:not(.searchBar)').remove();
                                } else {
                                    li.remove();
                                }
                            }
                        }
                        gotRows(rows);
                        mc.hideActivity();
                    }
                    if (xmlName) {
                        mc.db.queryXmlSummaries(processId, xmlName, summaryNames, conditions, limit, offset, gotResults);
                    } else {
                        mc.db.querySummaries(processId, summaryNames, conditions, distinct, sort, limit, offset, gotResults);
                    }
                }
            }

            function nextBatch() {
                loadBatch(this);
            }

            function prevBatch() {
                offset -= limit * 2;
                if (offset < 0) {
                    offset = 0;
                }
                loadBatch(this);
            }

            gotRows = function(rows) {
                var el, html, i, li, nextRow, prevRow, tr;
                html = question.applyTemplate('tableTemplate');
                if (html) {
                    if (!table || !table.length) {
                        li = $(window.document.createElement('li'));
                        li.html(html);
                        table = li.find('table');
                        if (table && table.length) {
                            tbody = table.find('tbody');
                            if (tbody.length === 0) {
                                tbody = $(document.createElement('tbody'));
                                table[0].appendChild(tbody[0]);
                            }
                        }
                    }
                    if (table && table.length) {
                        el = $(document.createElement('tbody'));
                        for (i = 0; i < rows.length; i += 1) {
                            html = question.applyTemplate('rowTemplate', rows[i]);
                            el.html(html);
                            tr = el.find('tr').item(0);
                            if (tr && tr.length) {
                                if (value && value.length && value.indexOf(rows[i].guid) >= 0) {
                                    tr.addClass('jmuiSelected');
                                }
                                tr.attr('rowIndex', i + offset);
                                tr.attr('rowGuid', rows[i].guid);
                                tr[0].mdcRow = rows[i];
                                if ($.isAndroid) {
                                    tr.bind('click', edit);
                                } else {
                                    $.ui.generateTaps(tr.bind($.ui.tapEvent, edit));
                                }
                                tbody[0].appendChild(tr[0]);
                            }
                        }
                        if (paginate) {
                            prevRow = question.applyTemplate('prevBatchRowTemplate') || '';
                            nextRow = question.applyTemplate('nextBatchRowTemplate') || '';
                            tr = $(window.document.createElement('tr'));
                            tr.html(prevRow + nextRow);
                            if (prevRow && offset > 0) {
                                $.ui.generateTaps(tr.find('td:first-of-type')).bind($.ui.tapEvent, prevBatch);
                            }
                            if (nextRow && rows.length === limit) {
                                $.ui.generateTaps(tr.find('td:last-of-type')).bind($.ui.tapEvent, nextBatch);
                            }
                            tbody[0].appendChild(tr[0]);
                        } else if (rows.length === limit) {
                            html = question.applyTemplate('nextBatchRowTemplate');
                            tr = $(document.createElement('tr'));
                            tr.html(html);
                            $.ui.generateTaps(tr.find('td').item(0)).bind($.ui.tapEvent, nextBatch);
                            tbody[0].appendChild(tr[0]);
                        }
                        offset += limit;
                    }
                    if (li && li.length) {
                        ul[0].appendChild(li[0]);
                    }
                } else {
                    for (i = 0; i < rows.length; i += 1) {
                        li = $(window.document.createElement('li'));
                        li.addClass('jmuiArrow');
                        if (value && value.length && value.indexOf(rows[i].guid) >= 0) {
                            li.addClass('jmuiSelected');
                        }
                        li.attr('rowIndex', i + offset);
                        li.attr('rowGuid', rows[i].guid);
                        li[0].mdcRow = rows[i];
                        li.text(rows[i][summaryNames[0]]);
                        ul[0].appendChild(li[0]);
                        if ($.isAndroid) {
                            li.bind('click', edit);
                        } else {
                            $.ui.generateTaps(li.bind($.ui.tapEvent, edit));
                        }
                    }
                    if (paginate) {
                        prevRow = $(window.document.createElement('DIV'));
                        prevRow.style($.isIE ? '-ms-flex' : '-webkit-box-flex', 1);
                        if (offset > 0) {
                            prevRow.text('Previous ' + limit);
                            $.ui.generateTaps(prevRow).bind($.ui.tapEvent, prevBatch);
                        }
                        nextRow = $(window.document.createElement('DIV'));
                        prevRow.style($.isIE ? '-ms-flex' : '-webkit-box-flex', 1);
                        nextRow.style('text-align', 'right');
                        if (rows.length === limit) {
                            nextRow.text('Next ' + limit);
                            $.ui.generateTaps(nextRow).bind($.ui.tapEvent, nextBatch);
                        }
                        if (prevRow.text() || nextRow.text()) {
                            li = $(window.document.createElement('li'));
                            li.style('display', $.isIE ? '-ms-flexbox' : '-webkit-box');
                            li.addClass('navBar');
                            li[0].appendChild(prevRow[0]);
                            li[0].appendChild(nextRow[0]);
                            ul[0].appendChild(li[0]);
                        }
                    } else if (rows.length === limit) {
                        li = $(window.document.createElement('li'));
                        li.text('Next ' + limit);
                        ul[0].appendChild(li[0]);
                        if ($.isAndroid) {
                            li.bind('click', nextBatch);
                        } else {
                            $.ui.generateTaps(li.bind($.ui.tapEvent, nextBatch));
                        }
                    }
                    offset += limit;
                }
                $.ui.refreshScroller(question.getPageObject());
                question.busy = false;
            };
            limit = question.getDesignValue('batchSize');
            if (limit === undefined || limit === null || limit.constructor !== Number) {
                limit = -1;
            }
            processId = question.getDesignValue('processId') || mc.db.getCurrentProcess().id;
            summaryNames = question.getDesignValue('summaryNames') || ['name'];
            xmlName = question.getDesignValue('xmlName');
            searchName = question.getDesignValue('searchName') || summaryNames[0];
            sort = question.getDesignValue('sort') || { column: searchName, order: 'ASC' };
            comparison = question.getDesignValue('comparison') || 'contains';
            conditions = [{
                condition: comparison,
                summaryName: searchName,
                value: el.val()
}];
                distinct = !!question.getDesignValue('distinct');
                paginate = !!question.getDesignValue('paginate');
                if (xmlName) {
                    mc.db.queryXmlSummaries(processId, xmlName, summaryNames, conditions, limit, offset, gotRows);
                } else {
                    mc.db.querySummaries(processId, summaryNames, conditions, distinct, sort, limit, offset, gotRows);
                }
            }
            ul.find('li:not(.searchBar)').remove();
            el = ul.find('input');
            if (el.val().length) {
                offset = 0;
                question.getValue(gotValue);
            } else {
                question.busy = false;
            }
        }

        function createGridRows(question, ul) {
            var page, table;

            function edit() {
                var formula, formulaName, index, row;
                if (!question.getQuestionObject().attr('disabled')) {
                    row = $(this);
                    index = row.attr('mdcRow');
                    if (index !== null && row.hasClass('jmuiSelected') === false) {
                        table.find('.jmuiSelected').removeClass('jmuiSelected');
                        row.addClass('jmuiSelected');
                        page.attr('rowIndex', index);
                        formulaName = question.getQuestionId() + '_RowTap';
                        mc.currentPage(question.getPageId());
                        formula = mc.fl[formulaName];
                        if (formula !== undefined && formula.constructor === Function) {
                            mc.showActivity();
                            formula(function(pageId) {
                                if (question.getLatch() === false) {
                                    row.removeClass('jmuiSelected');
                                }
                                mc.hideActivity();
                                if (pageId && typeof pageId === 'string') {
                                    $.ui.gotoPage($('#' + pageId), 'jmuiSlide');
                                }
                            });
                        } else if (question.getLatch() === false) {
                            row.removeClass('jmuiSelected');
                        }
                    }
                }
            }

            function loadAttachment(row, col, name) {
                function gotAttachment(data) {
                    var selector;
                    if (data) {
                        selector = 'tbody > tr:nth-of-type(' + (row + 1) + ') > td:nth-of-type(' + (col + 1) + ') > img';
                        table.find(selector).attr('src', data);
                    }
                }
                mc.att.getAttachment(mc.db.getCurrentSubjectGuid(), name, gotAttachment);
            }

            function tableFromTemplate() {
                var html, table;
                html = question.applyTemplate();
                if (html) {
                    ul.html(html);
                    table = ul.find('table');
                    if (!table.length) {
                        table = undefined;
                    }
                }
                return table;
            }

            function tableFromRowTemplate(value) {
                var columns, data, i, j, html, tr, table;
                html = question.applyTemplate('tableTemplate');
                if (html) {
                    ul.html('<li>' + html + '</li>');
                    table = ul.find('table');
                    if (table && value && value.constructor === Array) {
                        columns = question.getColumns();
                        for (i = 0; i < value.length; i += 1) {
                            data = {};
                            for (j = 0; j < columns.length; j += 1) {
                                if (columns[j].id) {
                                    data[columns[j].id] = value[i][j];
                                }
                            }
                            html = question.applyTemplate('rowTemplate', data);
                            if (html) {
                                tr = $(window.document.createElement('tbody'));
                                tr.html(html);
                                tr = tr.find('tr').item(0);
                                tr.attr('mdcRow', i);
                                table[0].appendChild(tr[0]);
                            }
                        }
                    }
                }
                return table;
            }

            function tableFromDefault(value) {
                var caption, columns, html, i, j, rowHeight, style, table;
                columns = question.getColumns();
                if (columns) {
                    ul.html('<li><table></table></li>');
                    table = ul.find('table');
                    rowHeight = question.getRowHeight();
                    html = '<thead>';
                    caption = ul.attr('caption');
                    if (caption) {
                        html += '<caption>' + caption + '</caption>';
                    }
                    html += '<tr>';
                    for (i = 0; i < columns.length; i += 1) {
                        html += '<th';
                        if (columns[i].align || columns[i].width) {
                            style = ' style="';
                            if (columns[i].align) {
                                style += 'text-align:' + columns[i].align + ';';
                            }
                            if (columns[i].width && parseFloat(columns[i].width)) {
                                style += 'width:' + columns[i].width + ';';
                            } else {
                                style += 'display:none;';
                            }
                            style += '"';
                            html += style;
                        }
                        html += '>';
                        if (columns[i].title) {
                            html += columns[i].title;
                        }
                        html += '</th>';
                    }
                    html += '</tr></thead><tbody>';
                    if (value && value.constructor === Array) {
                        for (i = 0; i < value.length; i += 1) {
                            if (value[i] && value[i].constructor === Array) {
                                html += '<tr';
                                if (rowHeight) {
                                    html += ' style="height:' + rowHeight + ';max-height:' + rowHeight + ';min-height:' + rowHeight + ';"';
                                }
                                html += ' mdcRow="' + i + '">';
                                for (j = 0; j < value[i].length && j < columns.length; j += 1) {
                                    html += '<td mdcCol="' + j + '" ';
                                    style = 'style="';
                                    if (columns[j].align) {
                                        style += 'text-align:' + columns[j].align + ';';
                                    }
                                    if (!columns[j].width || !parseFloat(columns[j].width)) {
                                        style += 'display:none;';
                                    }
                                    style += '"';
                                    html += style + '>';
                                    if (columns[j].type === 'image') {
                                        html += '<img src="' + value[i][j] + '"';
                                        if (rowHeight) {
                                            html += ' style="max-height:' + rowHeight + ';"';
                                        }
                                        html += '>';
                                    } else if (columns[j].type === 'imageAtt') {
                                        html += '<img';
                                        if (rowHeight) {
                                            html += ' style="max-height:' + rowHeight + ';"';
                                        }
                                        html += '>';
                                        loadAttachment(i, j, value[i][j]);
                                    } else {
                                        html += value[i][j];
                                    }
                                    html += '</td>';
                                }
                                html += '</tr>';
                            }
                        }
                    }
                    html += '</tbody>';
                    table.html(html);
                }
                return table;
            }
            page = $($.ui.parentPage(ul[0]));
            page.removeAttr('rowIndex');
            question.setRowIndex(null);
            question.getValue(function(value) {
                table = tableFromTemplate(value) || tableFromRowTemplate(value) || tableFromDefault(value);
                $.ui.refreshScroller(page);
                ul.find('img').bind('load', function() {
                    $.ui.refreshScroller(page);
                });
                $.ui.generateTaps(ul.find('tr[mdcRow]').bind($.ui.tapEvent, edit));
            });
        }

        function normalizeAllAnswers(pageId) {
            var length, process, q, qid;
            process = mc.db.getCurrentProcess();
            length = 0;
            for (qid in process.pages[pageId].qIdMap) {
                qid = pageId + qid.replace(' ', '_');
                q = mc.q(pageId, qid);
                if (q) {
                    length = Math.max(length, q.getAnswerArrayLength());
                }
            }
            if (length > 0) {
                for (qid in process.pages[pageId].qIdMap) {
                    qid = pageId + qid.replace(' ', '_');
                    q = mc.q(pageId, qid);
                    if (q) {
                        q.ensureAnswer(length - 1);
                    }
                }
            }
        }

        function createListItems(question, ul) {
            var addrow, answer, defval, delrow, editPage, glyph, html, i, li, q, ulPage;

            function goBack(e) {
                var formulaName;

                function success(r) {
                    normalizeAllAnswers(editPage[0].id);
                    if (r === true) {
                        editPage.find('.jmuiBackButton, .jmuiDeleteButton').unbind($.ui.tapEvent, goBack);
                        $.ui.gotoPage(ulPage, 'jmuiSlide', true);
                    }
                }

                function error(e) {
                    e = undefined;
                }
                if (!$.ui.defaultPrevented(e)) {
                    if (!e.jmuiTarget || !$(e.jmuiTarget).hasClass('jmuiDeleteButton')) {
                        formulaName = 'action_' + question.getQuestionObject().attr('editPageId') + '_Validate';
                        if (mc.fl[formulaName] && mc.fl[formulaName].constructor === Function) {
                            mc.fl.execFormula(formulaName, success, error, true);
                        } else {
                            success(true);
                        }
                    } else {
                        success(true);
                    }
                }
            }

            function create() {
                var rowIndex;
                rowIndex = answer.push(defval || '') - 1;
                question.setValue(answer);
                if (editPage.length > 0) {
                    editPage.attr('rowIndex', rowIndex);
                    editPage.find('.jmuiBackButton, .jmuiDeleteButton').bind($.ui.tapEvent, goBack);
                    $.ui.gotoPage(editPage, 'jmuiSlide');
                } else {
                    question.load();
                    question.postLoad();
                }
            }

            function edit(e) {
                var formulaName, me, oldRowIndex;

                function callback(r) {
                    if (r !== false && !question.getLatch()) {
                        if (editPage.length > 0) {
                            editPage.attr('rowIndex', me.attr('rowIndex'));
                            editPage.find('.jmuiBackButton, .jmuiDeleteButton').bind($.ui.tapEvent, goBack);
                            editPage.find('.jmuiDeleteButton').show(delrow ? 'block' : 'none');
                            $.ui.gotoPage(editPage, 'jmuiSlide');
                        }
                    }
                }
                if (!$.ui.defaultPrevented(e)) {
                    me = $(this);
                    if (question.getLatch()) {
                        me.toggleClass('jmuiSelected');
                    } else {
                        me.addClass('jmuiSelected');
                    }
                    formulaName = question.getQuestionId() + '_RowTap';
                    if (mc.fl[formulaName] && mc.fl[formulaName].constructor === Function) {
                        oldRowIndex = ulPage.attr('rowIndex');
                        ulPage.attr('rowIndex', me.attr('rowIndex'));
                        mc.fl.execFormula(formulaName, callback, callback, true);
                        if (oldRowIndex === null || oldRowIndex === undefined) {
                            ulPage.removeAttr('rowIndex');
                        } else {
                            ulPage.attr('rowIndex', oldRowIndex);
                        }
                    } else {
                        callback();
                    }
                }
            }
            q = question.getQuestionObject();
            question.getValue(function(value) {
                var tbody;
                answer = value || [];
                editPage = $('#' + q.attr('editPageId'));
                ul.find('li').remove();
                glyph = q.attr('glyph');
                addrow = q.attr('addrow');
                if (addrow === '') {
                    addrow = 'Add New Row...';
                }
                delrow = q.attr('delrow') !== 'false';
                ulPage = $($.ui.parentPage(ul[0]));
                question.getDefaultValue(function(d) {
                    var subject, table;
                    defval = d;
                    if (defval && defval.constructor === Array) {
                        defval = defval[0];
                    }
                    html = question.applyTemplate('tableTemplate');
                    if (html) {
                        li = $(window.document.createElement('li'));
                        li.html(html);
                        table = li.find('table');
                        if (table && table.length) {
                            tbody = table.find('tbody');
                            if (tbody.length === 0) {
                                tbody = $(document.createElement('tbody'));
                                table[0].appendChild(tbody[0]);
                            }
                            subject = mc.db.getCurrentSubject();
                            html = '';
                            for (i = 0; i < answer.length; i += 1) {
                                subject._listIndex = i;
                                html += question.applyTemplate('rowTemplate');
                            }
                            delete subject._listIndex;
                            tbody.html(tbody.html() + html);
                            tbody.find('tbody tr').each(function(index) {
                                var me;
                                me = $(this);
                                me.attr('rowIndex', index);
                                if ($.isAndroid) {
                                    me.bind('click', edit);
                                } else {
                                    $.ui.generateTaps(me.bind($.ui.tapEvent, edit));
                                }
                            });
                        }
                        ul[0].appendChild(li[0]);
                    } else {
                        for (i = 0; i < answer.length; i += 1) {
                            li = $(window.document.createElement('li'));
                            li.addClass('jmuiArrow');
                            li.attr('rowIndex', i);
                            html = '';
                            if (glyph !== null) {
                                html += '<div class="tagLabel">';
                                if (i < 52) {
                                    html += alphabet[i];
                                } else {
                                    html += '';
                                }
                                html += '</div>';
                            }
                            html += '<div>' + (answer[i] || '&nbsp;') + '</div></li>';
                            li.html(html);
                            ul[0].appendChild(li[0]);
                        }
                        if ($.isAndroid) {
                            ul.find('li').bind('click', edit);
                        } else {
                            $.ui.generateTaps(ul.find('li').bind($.ui.tapEvent, edit));
                        }
                    }
                    if (addrow !== null) {
						function clicked(e) {
							if( ! $(e.target).hasClass('clicked') ) {
								$(e.target).addClass('clicked');							
								create(e);							
							}
						}
                        li = $(window.document.createElement('li'));
                        li.addClass('jmuiArrow', 'listAddRow');
                        li.text(addrow);
                        ul[0].appendChild(li[0]);						
                        if ($.isAndroid) {
                            ul.find('li:last-child').bind('click', clicked);
                        } else {
                            $.ui.generateTaps(ul.find('li:last-child').bind($.ui.tapEvent, clicked));
                        }
                    }
                });
            }, true);
        }

        function createPins(question, img) {
            var i, imagePage, pin, pinParent, q;

            function edit() {
                var editPage;

                function goBack(e) {
                    var formulaName;

                    function success(r) {
                        normalizeAllAnswers(editPage[0].id);
                        if (r === true) {
                            editPage.find('.jmuiBackButton, .jmuiDeleteButton').unbind($.ui.tapEvent, goBack);
                            $.ui.gotoPage(imagePage, 'jmuiSlide', true);
                        }
                    }

                    function error(e) {
                        e = undefined;
                    }
                    if (!$.ui.defaultPrevented(e)) {
                        if (!e.jmuiTarget || !$(e.jmuiTarget).hasClass('jmuiDeleteButton')) {
                            formulaName = 'action_' + question.getQuestionObject().attr('editPageId') + '_Validate';
                            if (mc.fl[formulaName] && mc.fl[formulaName].constructor === Function) {
                                mc.fl.execFormula(formulaName, success, error, true);
                            } else {
                                success(true);
                            }
                        } else {
                            success(true);
                        }
                    }
                }
                editPage = $('#' + q.attr('editPageId'));
                if (editPage.length > 0) {
                    editPage.attr('rowIndex', $(this).attr('index'));
                    editPage.find('.jmuiBackButton, .jmuiDeleteButton').bind($.ui.tapEvent, goBack);
                    $.ui.gotoPage(editPage, 'jmuiSlide');
                }
            }
            question.getValue(function(coords) {
                coords = coords || [];
                q = question.getQuestionObject();
                imagePage = $($.ui.parentPage(img[0]));
                pinParent = $(img[0].parentElement);
                pinParent.find('.pinLabel').remove();
                for (i = 0; i < coords.length; i += 1) {
                    pin = $(window.document.createElement('div'));
                    pin.addClass('pinLabel');
                    pin.style('position', 'absolute');
                    pin.style('left', coords[i].x + '%');
                    pin.style('top', coords[i].y + '%');
                    pin.style('z-index', 1);
                    pin.attr('pc', coords[i].x + ',' + coords[i].y);
                    pin.attr('index', i);
                    if (i < 52) {
                        pin.text(alphabet[i]);
                    }
                    pinParent[0].appendChild(pin[0]);
                    $.ui.generateTaps(pin.bind($.ui.tapEvent, edit));
                }
            });
        }

        function bindAudio(question, button, save) {
            var audio, downloadComplete, error, state, success;

            function createAudio() {
                var src;
                // create file containing answer data
                state = 'restricted';
                if (mc.unrestricted) {
                    state = 'preparing';
                    audio = new window.Media(src, success, error, downloadComplete);
                    state = src ? 'idle' : 'empty';
                }
            }

            function startPlayback() {
                audio.play();
                state = 'playing';
            }

            function stopPlayback() {
                audio.stop();
                state = 'idle';
            }

            function startRecording() {
                audio.startAudioRecord();
                state = 'recording';
            }

            function stopRecording() {
                audio.stopAudioRecord();
                state = 'idle';
                if (save && save.constructor === Function) {
                    save();
                }
            }

            function buttonTap() {
                if (!audio) {
                    createAudio();
                }
                switch (state) {
                    case 'restricted':
                        alert('Not available in Restricted Client');
                        break;
                    case 'preparing':
                        alert('Not ready!');
                        break;
                    case 'empty':
                        button.addClass('jmuiSelected');
                        startRecording();
                        break;
                    case 'idle':
                        button.addClass('jmuiSelected');
                        startPlayback();
                        break;
                    case 'recording':
                        button.removeClass('jmuiSelected');
                        stopRecording();
                        button.html('&#x25b8;'); // Play
                        break;
                    case 'playing':
                        button.removeClass('jmuiSelected');
                        stopPlayback();
                        break;
                    default:
                        button.removeClass('jmuiSelected');
                        button.html('&#x25CF;'); // Record
                        alert(state);
                        break;
                }
            }
            success = function() {
                alert('Media success');
            };
            error = function() {
                alert('Media error');
            };
            downloadComplete = function() {
                alert('Media downloaded');
            };
            if (button.length > 0) {
                $.ui.generateTaps(button);
                button.bind($.ui.tapEvent, buttonTap);
                button[0]._tapHandler = buttonTap;
                button.html('&#x25CF;');
            }
            question = undefined;
        }

        function bindBarcode(question, li, save) {
            var div, placeholder, scanResult;

            function liTap(e) {
                var fail, name, success, show, message, data;
                success = function(data) {
					if(data && data.text !== undefined) {
						data = data.text;
					}					
                    if (placeholder[0]) {
                        div = placeholder;
                    }
                    if (scanResult[0]) {
                        div = scanResult;
                    }
                    div.empty();
                    div.hide();
                    if (question.getDesignValue('postScanShowResult') !== 'false') {
                        div.show();
                    }
                    div.text(data);
                    if (save && save.constructor === Function) {
                        save();
                    }
                    message = question.getDesignValue('postScanSuccessMessage');
                    if (message !== '') {
                        mc.msgBox(function(text) {
                            question.execAction('postScanAction', true);
                        }, 'Scan Complete', message, 'OK');
                    } else {
                        question.execAction('postScanAction', true);
                    }
                };
                fail = function(errormessage) {
                    message = question.getDesignValue('postScanFailureMessage');
                    if (message === '') {
                        message = errormessage;
                    }
                    if (message !== '' && message !== 'Error') {
                        mc.msgBox(function(text) {
                            return;
                        }, 'Scan Failed', message, 'OK');
                    }
                };
                if (!$.ui.defaultPrevented(e)) {
                    $.ui.cancelEvent(e);
                    try {
                        //should this use a call to isOurShell() ??
                        if (window.cordova && window.cordova.exec && window.plugins && window.plugins.barcodeScanner !== undefined) {
                            window.plugins.barcodeScanner.scan(success, fail);
                            return;
                        } else if (cordova.plugins.barcodeScanner !== undefined) {
							cordova.plugins.barcodeScanner.scan(success, fail);
							return;
                        } else {
                            log.debug('Scan error -> plugin is missing');
                        }
                    } catch (ex) {
                        log.debug('Scan error ->' + ex);
                    }
                    data = prompt('Not available in this environment', 'please enter');
                    if (data !== null) {
                        success(data);
                    } else {
                        fail('');
                    }
                    //question.execAction('postScanAction', true);
                }
            }
            div = li.find('div');
            placeholder = li.find('.jmuiPlaceholder');
            scanResult = li.find('.jmuiScanresult');
            $.ui.generateTaps(li);
            li.bind($.ui.tapEvent, liTap);
            li._tapHandler = liTap; // For unbind purposes
        }

        function bindCompound(question, ul, goBack) {
            var editPage, originalPageId;

            function validate(e) {
                var formulaName;

                function calculated(result) {
                    question.setValue(result, function() {
                        goBack(result);
                    });
                }

                function calculateError() {
                    goBack();
                }

                function validated(result) {
                    var formulaName;
                    if (result !== false) {
                        formulaName = question.getQuestionId() + '_Calculate';
                        mc.fl.execFormula(formulaName, calculated, calculateError, true);
                    } else {
                        editPage.find('.jmuiBackButton').bind($.ui.tapEvent, validate);
                    }
                }
                if (!$.ui.defaultPrevented(e)) {
                    e.preventDefault();
                    mc.currentPage(originalPageId);
                    editPage.find('.jmuiBackButton').unbind($.ui.tapEvent, validate);
                    formulaName = question.getQuestionId() + '_Validate';
                    mc.fl.execFormula(formulaName, validated, validated, true);
                }
            }
            /*
            function gotIsEditable(isEditable) {
            if (isEditable !== false) {
            if (editPage.length) {
            originalPageId = mc.currentPage();
            editPage.find('.jmuiBackButton').bind($.ui.tapEvent, validate);
            $.ui.gotoPage(editPage, 'jmuiSlide', false, false);
            }
            }
            }
            */
            function gotIsEditable(isEditable) {
                var page, rowIndex;
                if (isEditable !== false) {
                    if (editPage.length) {
                        originalPageId = mc.currentPage();
                        page = $('#' + originalPageId);
                        rowIndex = page.attr('rowIndex');
                        editPage.find('.jmuiBackButton').bind($.ui.tapEvent, validate);
                        if (rowIndex) {
                            editPage.attr('rowIndex', rowIndex);
                        } else {
                            editPage.removeAttr('rowIndex');
                        }
                        $.ui.gotoPage(editPage, 'jmuiSlide', false, false);
                    }
                }
            }

            function ulTap(e) {
                var formulaName;
                if (!$.ui.defaultPrevented(e)) {
                    $.ui.cancelEvent(e);
                    formulaName = question.getQuestionId() + '_IsEditable';
                    mc.fl.execFormula(formulaName, gotIsEditable, gotIsEditable, true);
                }
            }
            $.ui.generateTaps(ul);
            ul.bind($.ui.tapEvent, ulTap);
            ul._tapHandler = ulTap; // For unbind purposes
            editPage = $('#' + ul.attr('editPageId'));
        }

        function bindImageMap(question, imageMap) {
            var editPage, imagePage;

            function imageClicked(e) {
                var pos, rowIndex;

                function goBack(e) {
                    var formulaName;

                    function success(r) {
                        normalizeAllAnswers(editPage[0].id);
                        if (r === true) {
                            editPage.find('.jmuiBackButton, .jmuiDeleteButton').unbind($.ui.tapEvent, goBack);
                            $.ui.gotoPage(imagePage, 'jmuiSlide', true);
                        }
                    }

                    function error(e) {
                        e = undefined;
                    }
                    if (!$.ui.defaultPrevented(e)) {
                        if (!e.jmuiTarget || !$(e.jmuiTarget).hasClass('jmuiDeleteButton')) {
                            formulaName = 'action_' + question.getQuestionObject().attr('editPageId') + '_Validate';
                            if (mc.fl[formulaName] && mc.fl[formulaName].constructor === Function) {
                                mc.fl.execFormula(formulaName, success, error, true);
                            } else {
                                success(true);
                            }
                        } else {
                            success(true);
                        }
                    }
                }
                question.getValue(function(answer) {
                    answer = answer || [];
                    pos = getEventPosition(e);
                    pos.x = pos.x / imageMap.width() * 100;
                    pos.y = pos.y / imageMap.height() * 100;
                    rowIndex = answer.push(pos) - 1;
                    question.setValue(answer);
                    if (editPage.length > 0) {
                        editPage.attr('rowIndex', rowIndex);
                        editPage.find('.jmuiBackButton, .jmuiDeleteButton').bind($.ui.tapEvent, goBack);
                        $.ui.gotoPage(editPage, 'jmuiSlide');
                    } else {
                        question.load();
                        question.postLoad();
                    }
                });
            }

            function imageHold() {
                function takePicture() {
                    var fail, options, success, successFile, successData;

                    successFile = function(fileUri) {
                        var subject_guid, attachment_name;
                        function fileMoved(movedFileUri) {
                            function saved() {
                                log.debug('ATT: generating thumbnail ->' + movedFileUri);
                                mc.att.getThumbnail(movedFileUri, gotThumbnail);
                            }
                            function gotThumbnail(dataUrl) {
                                log.debug('ATT: got thumbnail dataUri <-' + movedFileUri);
                                imageMap.attr('src', dataUrl);
                            }
                            log.debug('ATT: set attachment for subject: ' + subject_guid + ' attachment : ' + attachment_name);
                            mc.att.setAttachment(subject_guid, attachment_name, '', true, saved);
                        }
                        function fileNotMoved(error) {
                            log.error('ATT: The file was not moved: ' + JSON.stringify(error));
                        }
                        subject_guid = mc.db.getCurrentSubjectGuid();
                        attachment_name = question.getPageId();
                        log.debug('ATT: move temp file for subject: ' + subject_guid + ' attachment : ' + attachment_name);
                        mc.fs.moveTemporaryFile(fileUri, subject_guid, attachment_name, fileMoved, fileNotMoved);
                    };

                    successData = function(dataUrl) {
                        dataUrl = 'data:image/jpeg;base64,' + dataUrl;
                        mc.db.setAttachment(mc.db.getCurrentSubjectGuid(), question.getPageId(), dataUrl, true);
                        imageMap.attr('src', dataUrl);
                    };

                    fail = function(message) {
                        if (message.toLowerCase().indexOf('cancelled') === -1) {
                            // alert('Camera failed: ' + message);
							log.warn('Camera failed: ' + message);
                        }
                    };
                    if (navigator.hasOwnProperty('camera')) {
                        options = {
                            quality: 20,
                            sourceType: navigator.camera.PictureSourceType.CAMERA,
                            allowEdit: true
                        };
                        if (mc.fs.availableForAtts) {
                            options.destinationType = navigator.camera.DestinationType.FILE_URI;
                            success = successFile;
                        } else {
                            options.destinationType = navigator.camera.DestinationType.DATA_URL;
                            success = successData;
                        }
                        navigator.camera.getPicture(success, fail, options);
                    } else {
                        alert('Not available in Restricted Client');
                    }
                }
                if (question.getDesignValue('canRetakeImage') !== false) {
                    takePicture();
                }
            }

            function gotAttachment(data) {
                if (data) {
                    imageMap.attr('src', data);
                }
            }
            mc.att.getAttachment(mc.db.getCurrentSubjectGuid(), question.getPageId(), gotAttachment);
            editPage = $('#' + question.getQuestionObject().attr('editPageId'));
            imagePage = $($.ui.parentPage(imageMap[0]));
            $.ui.generateTaps(imageMap);
            imageMap.bind($.ui.tapEvent, imageClicked);
            imageMap.bind($.ui.tapAndHoldEvent, imageHold);
        }

        function bindPhoto(question, li, save, deleteValue) {
            var scroller;

            function liTapAndHold() {
                if (scroller) {
                    scroller.scrolling = false;
                }
                mc.msgBox(function(text) {
                    if (text === 'Yes') {
                        question.showPlaceholder(li);
                        if (deleteValue && deleteValue.constructor === Function) {
                            deleteValue();
                        }
                    }
                }, 'Confirm', 'Clear?', 'Yes', 'No');
            }

            function liTap(e) {
                var fail, options, success, successFile, successData;
                successFile = function(fileUri) {
                    log.debug('ATT: success file...');
                    function saved(value) {
                        function gotThumbnail(dataUrl) {
                            var img;
                            log.debug('ATT: Showing thumb...');
                            li.empty();
                            img = document.createElement('img');
                            img.setAttribute('width', '100%');
                            img.setAttribute('src', dataUrl);
                            li[0].appendChild(img);
                            mc.fl.refreshiscroll(1500);
                        }
                        function fileMoved(movedFileUri) {
                            log.debug('ATT: generating thumbnail ->' + movedFileUri);
                            mc.att.getThumbnail(movedFileUri, gotThumbnail);
                        }
                        function fileNotMoved(error) {
                            log.error('ATT: The file was not moved: ' + JSON.stringify(error));
                        }
                        subject_guid = mc.db.getCurrentSubjectGuid();
                        log.debug('ATT: move temp file for subject: ' + subject_guid + ' attachment : ' + value);
                        if (options.sourceType === navigator.camera.PictureSourceType.CAMERA) {
                            mc.fs.moveTemporaryFile(fileUri, subject_guid, value, fileMoved, fileNotMoved);
                        } else {
                            mc.fs.copyTemporaryFile(fileUri, subject_guid, value, fileMoved, fileNotMoved);
                        }
                    }
                    if (save && save.constructor === Function) {
                        log.debug('ATT: Saving...');
                        save(saved);
                    } else {
                        log.error('ATT: cant save : ' + save);
                    }
                };
                successData = function(dataUrl) {
                    li.empty();
                    li.html('<img width="100%" src="data:image/jpeg;base64,' + dataUrl + '"/>');
                    if (save && save.constructor === Function) {
                        log.debug('ATT: Saving data...');
                        save();
                    } else {
                        log.error('ATT: cant save data: ' + save);
                    }
                };
                fail = function(message) {
                    if (message.toLowerCase().indexOf('cancelled') === -1) {
                        // alert('Camera failed: ' + message);
						log.warn('Camera failed: ' + message);
                    }
                };
                if (!$.ui.defaultPrevented(e)) {
                    $.ui.cancelEvent(e);
                    if (navigator.hasOwnProperty('camera')) {
                        var exOptions = {};
                        var extraPhotoOptionsStr = question.getDesignValue('extraPhotoOptions');
                        if (extraPhotoOptionsStr.length > 0)
                            exOptions = JSON.parse(extraPhotoOptionsStr);
                        options = {
                            quality: question.getDesignValue('quality') || 20,
                            allowEdit: true,
                            sourceType: navigator.camera.PictureSourceType.CAMERA
                        };
                        for (var attrname in exOptions) { options[attrname] = exOptions[attrname]; }

                        if (mc.fs.availableForAtts) {
                            options.destinationType = navigator.camera.DestinationType.FILE_URI;
                            success = successFile;
                        } else {
                            options.destinationType = navigator.camera.DestinationType.DATA_URL;
                            success = successData;
                        }
                        navigator.camera.getPicture(success, fail, options);
                    } else {
                        setTimeout(function() {
                            successData('/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcU FhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgo KCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCABQAFADASIA AhEBAxEB/8QAHAAAAgMBAQEBAAAAAAAAAAAABwgABAYFCQMB/8QAPxAAAgEDAwICBQcKBgMAAAAA AQIDBAURAAYSByETMRUiNVRzCBQWcZOy0SMyN0FRVpGUldIXU2F1s9MkYoH/xAAUAQEAAAAAAAAA AAAAAAAAAAAA/8QAFBEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8AL6UFY6KyUlQysMgi MkEfw186umno6WaqrIZIKaBGklllUqkaKMlmJ7AAAkk6Ilp9lUfwU+6NWtAC/prtX95rJ/Pxf3an 012r+81k/n4v7ta/qL0f2lvWzV9O9robbdKhzOtzpKVEnWY5PNyADICSeSse+c5DYYIt1F2fcdi7 ur7FdI5Q0DkwTOnEVMOSElUAkYYDyycHKnuDoHl9HV3udT9k34ano6u9zqfsm/DQ++S91kqt1Y2l umXxbvTwl6OukkHKrjXGUfJy0qjvkZLKrFu6lmYrQDb0dXe51P2TfhriXu92qw1SUt8udDbal0Ei xVlQkLshJAYBiDjIIz/odGTU0AL+mu1f3msn8/F/dr6U+79tVNRFBTbhs808rBI4462JmdicAABs kk/q0IPlkbPt1h3dar7bI4qdr2kxqYY04hpoypaXOcZcSLkADupY5LHTYW/btn2vtaptu3rdTW+i SFj4cCBeTBAvJj5sxCjLMSTjuToOrafZVH8FPujVrVW0+yqP4KfdGrWgmk7+Vpap791z2xaKN4kq bhb6WkiaUkIryVMygsQCcZIzgHTVXzcMFrFSiUtZXVkKJJ82pkAZw7EDi8hWPIwSQXBAx29Zcqv1 9u8z/KR2bWx08AFMKBqcS1BRZAtU7ZkbifD9YsOwfAAbzPEAA7pb7xtLcktHXxVNsvVumBIDFJIZ FIZWVgfqZWU4IwQcYOvQTo71Et3UbaNPcKWaIXSBEjuNKo4mCbHfCkk+GxBKnJyO2eQYBf8A5SEd n3xJSXGnmam3NbqPwpYKemqauGqBw6xpOqBBxLSYbj3LYbjjsEOmG9a7p/vKiv8Ab08bwcxz0xkZ FqImGGRiP/hGQQGVTg4xoPSnU0LennVGs3lQ0dzjtNrjtUuVmeC6vNPA4XPBojToOQOAfWHY8gWG M66zbvpK4ILhSVlmmd+Ecdw8P1/WRVw8bvGCzSKqqWDMQcKQM6ASfKP/AEp9F/8Aej/z0mjrdvZV Z8F/unQK+Uf+lPov/vR/56TR1u3sqs+C/wB06CWn2VR/BT7o1a0LL51k21tO5UtkuMVxmmhhg+dT 00KvHSB1Q5kHIPgCSM5VSDyAGWBUfep6h7c3dQ0w2duqmjusVXmCN+UbyMqEsGp34NLEVJB/V+tW VlDKAyodxXe37gvNNSzQPSC+13KGaLlxQVs5fgVKkM3LzbkBxGF88jLqfcJLx1v2pLcaOOCHlSxh IpzJ4kXzp+5PFeJOT2GcftOt7vGkuqXy63ylho6CoqpvZi1HjUwlKkPKJBCjDkwViuDk+Ic5kygm 3zcKx+o+1KiqpCtbBFS8kx6krrMxynDm3AnsPV5/+uexA110Vt+eTCHbu5PDDFVMM1JwYDtlec3L B8+/fv5Dy0E+reyko5pr5YbNcbda8cqqGren4xOWABj8ORjxJb83Hq/q7HCnD6SW/wDyrt/SKv8A 6tT6SW//ACrt/SKv/q0C/dJepVfsG5spD1dkqGzU0nLyPl4kefJwMf6MBg+SlWTu0k18s3zuouCy Uyy+PSihLQrxJUxOXDEu6fnK6lVyQwUMqkLd1Y21S0d0a57doa6O1SrynWShngSnkLY7c0UBTkYA J75HYcRql053l9HZKm33KnguFjriolpKtvyCSclxKw4OewHcBSTgeZUaA0da7jPuLc3SoXnwqpJL hJG6PGvF1M1OpBGMEEDuPLTIbat7WjpnarbI/N6O0RU7NjHIpCFzjJ/Z+3Sw7ksE9v3B0ZeuuL1s ddfZvCjj8P5tHTith8IwcMsEaJkIVnfiMAYxjTVUtlodv7VqLbaopIqSOOd1WSZ5WLOWdyXclmJZ mOST56DlXbYm2t2UVqqL9aYairpoomhqkZoZ04glVEsZV+ILE8c4z3xnQb3z8nerZKqqsVfDdyQn GmrUEFSUVSXxOmI5JXbtykj8m7t2yWKtPsqj+Cn3Rq1oEFvNl3RseeG2VtVX2iUoixUtaAIJHYgu IGy8DBealn5Ljkc4ORrNXO+Vv01sFxvcav8AMWhw1Oo/LRxzHLKc8WJIYZUhSR2xr0aq6aCspZqW shinpp0aOWKVAySIwwVYHsQQSCDpCuqlw2TW9c6Y2CGjt+1qappoKupoEDQyBWHjTRx8CoABK4VW VuHL1ufcChZeo22rmo5V60MvEsY64eDxwcfnn1CT2OAxOPqONhof3noPcqu1Lc9p11m3TRvE7JPb pxSPPMZCDhSXgKJg9lePyYeYGRHUWGs21d4pZKaKkrliknSlvFCsT+ECVDNBUr4blhnAXn3Bx3XQ MJdL5YIHnoLrdLXGxXhNT1NRGCVYeTKx8iD5HzB0t3UTaL2G4S11rWSr21US/wDiXCGKQ02TyPgr MQVdl4sPVZvzTnBDAMn0a6j7yFmSjfZFDLZ6VIvCehRbaWVm9dkRvyUjsGMmF8Jcg9xyUa3u7t27 E3hZqraW66qttfpCHM0dbTy0vgFPX5eOV8H1WTswdkYrgFgcEFD6dbmuNz3X0ysFY0T0Nmvsb0hC YdRNURM6kjzHJSRkZ9Y9yMAegt29lVnwX+6dIhR7CuOw+tmyKeqlirbXWXaint1zp+8FbCZ4yHUg kZwRlcnGQQSpVi9929lVnwX+6dBLT7Ko/gp90ataGqV9YiKqVdQqqMACQgAfx1++ka73yp+1b8dB qbpsrat3r5a667asldWy48SoqaCKWR8AAZZlJOAAPqA1V/w42P8Aubtv+lwf264HpGu98qftW/HU 9I13vlT9q346DSUmwdnUdVDVUe09vwVMDrJFLFbYVeN1OQykLkEEAgjXbultobvQS0N1oqauopce JT1MSyxvggjKsCDggH6wNYD0jXe+VP2rfjqeka73yp+1b8dB0Lf0ystmuXzrbVRcrHFJK01TQ0c4 ekqSxU4aGVXRAOOB4YQgEgHsMLZ1atG49uX+r+kMPOKqq/ES4RtJFRzKSxiVSS3FgoYeGWLDiQAy Hnpg/SNd75U/at+Op6RrvfKn7Vvx0Co7F3Na7JuW2VN3o0u1HT14uHhDlAYZlPaaIlgFf1E9XPGT iokAIR0dqjv9q3JtipuFir4K6keBvXibJUmMMFYeaNxZSVYAjIyNDO17bsdor4q61Wa20NbFnw6i mpUikTIIOGUAjIJH1E67719Y6Mr1dQysMEGQkEfx0H//2Q== ');
                        }, 100);
                        //alert('Not available in Restricted Client');
                    }
                }
            }
            $.ui.generateTaps(li);
            li.bind($.ui.tapEvent, liTap);
            li.bind($.ui.tapAndHoldEvent, liTapAndHold);
            li._tapHandler = liTap;
            li._tapAndHoldHandler = liTapAndHold;
            scroller = $($.ui.parentPage(li[0])).find('.jmuiScroller > div, .jmuiNativeScroller > div')[0].jmuiScroller;
        }

        function bindSketch(canvas, addCommand, saveCommands) {
            var bind, ctx, eraseTmo, lastTouch, lastPoint, scroller, unbind;

            function pageToCanvasCoordinates(x, y) {
                var point, offset, scale;
                offset = canvas.offset();
                point = {
                    x: x - offset.left,
                    y: y - offset.top
                };
                if (scroller) {
                    point.y -= scroller.y;
                }
                scale = {
                    x: canvas[0].width / canvas.width(),
                    y: canvas[0].height / canvas.height()
                };
                point.x *= scale.x;
                point.y *= scale.y;
                return point;
            }

            function eraseContent() {
                unbind(false, true, true);
                mc.msgBox(function(text) {
                    if (scroller) {
                        scroller.enabled = true;
                    }
                    if (text === 'Yes') {
                        addCommand('erase');
                        if (saveCommands !== undefined) {
                            saveCommands();
                        }
                    }
                }, 'Confirm', 'Clear?', 'Yes', 'No');
            }

            function lineTo(touch) {
                var newPoint;
                newPoint = pageToCanvasCoordinates(touch.pageX, touch.pageY);
                if (newPoint.x !== lastPoint.x || newPoint.y !== lastPoint.y) {
                    ctx.beginPath();
                    ctx.moveTo(lastPoint.x, lastPoint.y);
                    ctx.lineTo(newPoint.x, newPoint.y);
                    ctx.closePath();
                    ctx.stroke();
                    if (addCommand !== undefined) {
                        addCommand('lineTo|' + newPoint.x + '|' + newPoint.y);
                    }
                    lastPoint = newPoint;
                }
            }

            function moveTo(touch) {
                lastPoint = pageToCanvasCoordinates(touch.pageX, touch.pageY);
                if (addCommand !== undefined) {
                    addCommand('moveTo|' + lastPoint.x + '|' + lastPoint.y);
                }
            }

            function stopEraseTimer() {
                if (eraseTmo !== undefined) {
                    clearTimeout(eraseTmo);
                    eraseTmo = undefined;
                }
            }

            function touchEvent(e) {
                return isTouchable ? window.event.targetTouches[0] : e;
            }

            function touchEnd(e) {
                var touch;
                if (!$.ui.defaultPrevented(e)) {
                    $.ui.cancelEvent(e);
                    touch = touchEvent(e);
                    if (touch)
                        console.log('touchEnd. pageX: ' + touch.pageX + ', pageY: ' + touch.pageY);
                    else
                        console.log('touchEnd.');
                    stopEraseTimer();
                    unbind(false, true, true);
                    if (saveCommands !== undefined) {
                        saveCommands();
                    }
                    if (scroller) {
                        scroller.enabled = true;
                    }
                    return false;
                }
            }

            function touchMove(e) {
                var touch;
                if (!$.ui.defaultPrevented(e)) {
                    $.ui.cancelEvent(e);
                    touch = touchEvent(e);
                    if (touch.pageX !== lastTouch.pageX || touch.pageY !== lastTouch.pageY) {
                        console.log('touchMove. pageX: ' + touch.pageX + ', pageY: ' + touch.pageY);
                        lastTouch = { pageX: touch.pageX, pageY: touch.pageY };
                        stopEraseTimer();
                        lineTo(touch);
                    }
                    return false;
                }
            }

            function touchStart(e) {
                var touch;
                if (!$.ui.defaultPrevented(e)) {
                    $.ui.cancelEvent(e);
                    if (scroller) {
                        scroller.enabled = false;
                    }
                    touch = touchEvent(e);
                    lastTouch = { pageX: touch.pageX, pageY: touch.pageY };
                    console.log('touchStart. pageX: ' + touch.pageX + ', pageY: ' + touch.pageY);
                    moveTo(touch);
                    lineTo({
                        pageX: touch.pageX + 1,
                        pageY: touch.pageY + 1
                    });
                    bind(false, true, true);
                    eraseTmo = setTimeout(eraseContent, 500);
                    return false;
                }
            }
            bind = function(start, move, end) {
                if (isTouchable) {
                    if (start) {
                        canvas.bind('touchstart', touchStart);
                        canvas._touchStart = touchStart;
                    }
                    if (move) {
                        canvas.bind('touchmove', touchMove);
                    }
                    if (end) {
                        canvas.bind('touchend', touchEnd);
                    }
                } else {
                    if (start) {
                        canvas.bind('mousedown', touchStart);
                        canvas._touchStart = touchStart;
                    }
                    if (move) {
                        $(window).bind('mousemove', touchMove);
                    }
                    if (end) {
                        $(window).bind('mouseup', touchEnd);
                    }
                }
            };
            unbind = function(start, move, end) {
                if (isTouchable) {
                    if (start) {
                        canvas.unbind('touchstart', touchStart);
                        delete canvas._touchStart;
                    }
                    if (move) {
                        canvas.unbind('touchmove', touchMove);
                    }
                    if (end) {
                        canvas.unbind('touchend', touchEnd);
                    }
                } else {
                    if (start) {
                        canvas.unbind('mousedown', touchStart);
                        delete canvas._touchStart;
                    }
                    if (move) {
                        $(window).unbind('mousemove', touchMove);
                    }
                    if (end) {
                        $(window).unbind('mouseup', touchEnd);
                    }
                }
            };
            ctx = canvas[0].getContext('2d');
            ctx.strokeStyle = "rgba(0,0,0,0.7)";
            ctx.lineWidth = 2.0;
            //scroller = $($.ui.parentPage(canvas[0])).find('.jmuiScroller > div')[0].jmuiScroller;
            scroller = $($.ui.parentPage(canvas[0])).find('.jmuiScroller > div, .jmuiNativeScroller > div')[0].jmuiScroller;
            bind(true, false, false);
        }

        function bindEditAudio(question) {
            var editPage, page, q;
            page = question.getPageObject();
            editPage = popupPage($($.ui.parentColumn(page[0])), 'editAudioPage',question);
            q = question.getQuestionObject();
            $.ui.generateTaps(q);
            q.bind($.ui.tapEvent, function() {
                var btn, goBack;

                function actionButtonClick(e) {
                    if (!$.ui.defaultPrevented(e)) {
                        e.preventDefault();
                        /*
                        value = img.attr('src');
                        question.setValue(value);
                        q.find('h4').text(value.length ? '<answered>' : '');
                        question.valueChanged();
                        */
                        goBack();
                        $.ui.refreshScroller(page);
                    }
                }
                goBack = function() {
                    editPage.find('.jmuiCancelButton').unbind($.ui.tapEvent, goBack);
                    editPage.find('.jmuiActionButton').unbind($.ui.tapEvent, actionButtonClick);
                    btn.unbind($.ui.tapEvent, btn._tapHandler);
                    $.ui.gotoPage(page, 'jmuiSlide', true, true);
                };
                if (!q.attr('disabled')) {
                    btn = editPage.find('div');
                    bindAudio(question, btn);
                    editPage.find('h2').text(q.find('h3').text());
                    /*
                    value = question.getValue() || '';
                    if (value.length) {
                    img.attr('width', '100%');
                    img.attr('src', value);
                    } else {
                    img.removeAttr('width');
                    img.attr('src', emptyPhoto);
                    }
                    */
                    editPage.find('.jmuiActionButton').bind($.ui.tapEvent, actionButtonClick);
                    editPage.find('.jmuiCancelButton').bind($.ui.tapEvent, goBack);
                    $.ui.gotoPage(editPage, 'jmuiSlide', false, true);
                }
            });
        }

        function bindEditBarcode(question) {
            var editPage, page, q;
            page = question.getPageObject();
            editPage = popupPage($($.ui.parentColumn(page[0])), 'editBarcodePage',question);
            q = question.getQuestionObject();
            $.ui.generateTaps(q);
            q.bind($.ui.tapEvent, function() {
                var div, goBack, li, placeholder, scanResult;

                function actionButtonClick(e) {
                    var value;
                    if (!$.ui.defaultPrevented(e)) {
                        e.preventDefault();
                        value = div.text() || '';
                        question.setValue(value);
                        if (question.getDesignValue('postScanShowResult') !== 'false') {
                            q.find('h4').text(value);
                        }
                        question.valueChanged();
                        goBack();
                        $.ui.refreshScroller(page);
                    }
                }
                goBack = function() {
                    editPage.find('.jmuiCancelButton').unbind($.ui.tapEvent, goBack);
                    editPage.find('.jmuiActionButton').unbind($.ui.tapEvent, actionButtonClick);
                    li.unbind($.ui.tapEvent, li._tapHandler);
                    $.ui.gotoPage(page, 'jmuiSlide', true, true);
                };
                if (!q.attr('disabled')) {
                    li = editPage.find('li');
                    placeholder = li.find('.jmuiPlaceholder');
                    scanResult = li.find('.jmuiScanresult');
                    div= li.find('div');
                    bindBarcode(question, li);
                    editPage.find('h2').text(q.find('h3').text());
                    question.getValue(function(value) {
                        value = value || '';
                        if (placeholder[0]) {
                            div = placeholder;
                        }
                        question.showPlaceholder(div);
                        if (scanResult[0]) {
                            div = scanResult;
                        }
                        div.hide();
                        if (question.getDesignValue('postScanShowResult') !== 'false') {
                            div.show();
                        }
                        div.text(value);
                        editPage.find('.jmuiActionButton').bind($.ui.tapEvent, actionButtonClick);
                        editPage.find('.jmuiCancelButton').bind($.ui.tapEvent, goBack);
                        $.ui.gotoPage(editPage, 'jmuiSlide', false, true);
                    });
                }
            });
        }

        function bindEditCombo(question, choices) {
            var editPage, page, q;
            page = question.getPageObject();
            editPage = popupPage($($.ui.parentColumn(page[0])), 'editComboPage',question);
            q = question.getQuestionObject();
            $.ui.generateTaps(q);
            q.bind($.ui.tapEvent, function() {
                var editor, goBack, html, i, select;

                function actionButtonClick(e) {
                    var value;
                    if (!$.ui.defaultPrevented(e)) {
                        e.preventDefault();
                        value = editor.val();
                        question.setValue(value);
                        q.find('h4').html(value);
                        question.valueChanged();
                        goBack();
                        $.ui.refreshScroller(page);
                    }
                }
                goBack = function() {
                    editPage.find('.jmuiCancelButton').unbind($.ui.tapEvent, goBack);
                    editPage.find('.jmuiActionButton').unbind($.ui.tapEvent, actionButtonClick);
                    $.ui.gotoPage(page, 'jmuiSlide', true, true);
                };
                if (!q.attr('disabled')) {
                    editor = editPage.find('input');
                    select = editPage.find('select');
                    html = '';
                    for (i = 0; i < choices.length; i += 1) {
                        html += '<option value="' + choices[i].value + '">' + choices[i].label + '</option>';
                    }
                    select.empty();
                    select.html(html);
                    editor.val('');
                    editPage.find('h2').text(q.find('h3').text());
                    question.getValue(function(value) {
                        editor.val(value);
                        editPage.find('.jmuiActionButton').bind($.ui.tapEvent, actionButtonClick);
                        editPage.find('.jmuiCancelButton').bind($.ui.tapEvent, goBack);
                        $.ui.gotoPage(editPage, 'jmuiSlide', false, true);
                        editPage.trigger('jmuiPageAnimationStart', {
                            direction: 'in'
                        });
                    });
                }
            });
        }

        function bindEditCompound(question) {
            var editPage, page, q;
            page = question.getPageObject();
            editPage = popupPage($($.ui.parentColumn(page[0])), 'editCompoundPage',question);
            q = question.getQuestionObject();
            $.ui.generateTaps(q);
            q.bind($.ui.tapEvent, function() {
                var ul;

                function applyTemplate() {
                    question.getValue(function(value) {
                        var templateName;
                        if (value === undefined || value === null || value === '') {
                            templateName = 'unansweredTemplate';
                        } else {
                            templateName = 'answeredTemplate';
                        }
                        ul.html(question.applyTemplate(templateName));
                    }, false);
                }

                function goBack() {
                    editPage.find('.jmuiBackButton').unbind($.ui.tapEvent, goBack);
                    ul.unbind($.ui.tapEvent, ul._tapHandler);
                    $.ui.gotoPage(page, 'jmuiSlide', true, true);
                }
                if (!q.attr('disabled')) {
                    ul = editPage.find('ul');
                    ul.attr('editPageId', q.attr('editPageId'));
                    bindCompound(question, ul, function(value) {
                        applyTemplate();
                        q.find('h4').text(value && value.length ? '<answered>' : '');
                        $.ui.gotoPage(editPage, 'jmuiSlide', true, false);
                    });
                    editPage.find('h2').text(q.find('h3').text());
                    //ul.html(question.applyTemplate());
                    applyTemplate();
                    editPage.find('.jmuiBackButton').bind($.ui.tapEvent, goBack);
                    $.ui.gotoPage(editPage, 'jmuiSlide', false, true);
                }
            });
        }

        function bindEditDate(question) {
            var editPage, page, q;
            page = question.getPageObject();
            editPage = popupPage($($.ui.parentColumn(page[0])), 'editDatePage',question);
            q = question.getQuestionObject();
            $.ui.generateTaps(q);
            q.bind($.ui.tapEvent, function() {
                var editor, goBack;

                function actionButtonClick(e) {
                    var value;
                    if (!$.ui.defaultPrevented(e)) {
                        e.preventDefault();
                        value = new Date(editor.html() + ' 12:00:00 UTC');
                        if (isNaN(value.getTime())) {
                            value = null;
                            q.find('h4').html('');
                        } else {
                            q.find('h4').html(editor.html());
                        }
                        question.setValue(value);
                        question.valueChanged();
                        goBack();
                        $.ui.refreshScroller(page);
                    }
                }
                goBack = function() {
                    editPage.find('.jmuiCancelButton').unbind($.ui.tapEvent, goBack);
                    editPage.find('.jmuiActionButton').unbind($.ui.tapEvent, actionButtonClick);
                    $.ui.gotoPage(page, 'jmuiSlide', true, true);
                };
                if (!q.attr('disabled')) {
                    editor = editPage.find('.jmuiCompositeDate');
                    editPage.find('h2').text(q.find('h3').text());
                    question.getValue(function(value) {
                        if (value && value.constructor === Date) {
                            value = value.toLocaleDateString();
                        } else {
                            value = '&nbsp;';
                        }
                        editor.html(value);
                        editPage.find('.jmuiActionButton').bind($.ui.tapEvent, actionButtonClick);
                        editPage.find('.jmuiCancelButton').bind($.ui.tapEvent, goBack);
                        $.ui.gotoPage(editPage, 'jmuiSlide', false, true);
                    });
                }
            });
        }

        function bindEditGrid(question) {
            var caption, editPage, page, q, ul;
            page = question.getPageObject();
            editPage = popupPage($($.ui.parentColumn(page[0])), 'editGridPage',question);
            q = question.getQuestionObject();
            $.ui.generateTaps(q);
            ul = editPage.find('ul');
            q.bind($.ui.tapEvent, function() {
                function pageAnimationStart(e) {
                    if (e.direction === 'in') {
                        createGridRows(question, ul);
                    }
                }

                function goBack() {
                    editPage.find('.jmuiBackButton').unbind($.ui.tapEvent, goBack);
                    editPage.unbind('jmuiPageAnimationStart', pageAnimationStart);
                    $.ui.gotoPage(page, 'jmuiSlide', true, true);
                    $.ui.refreshScroller(page);
                }
                if (!q.attr('disabled')) {
                    caption = q.find('h3').text();
                    if (caption) {
                        ul.attr('caption', caption);
                    } else {
                        ul.removeAttr('caption');
                    }
                    editPage.find('.jmuiBackButton').bind($.ui.tapEvent, goBack);
                    editPage.bind('jmuiPageAnimationStart', pageAnimationStart);
                    $.ui.gotoPage(editPage, 'jmuiSlide', false, false);
                }
            });
        }

        function bindEditImage(question) {
            var editPage, image, page, q;
            page = question.getPageObject();
            editPage = popupPage($($.ui.parentColumn(page[0])), 'editImagePage',question);
            image = editPage.find('img');
            q = question.getQuestionObject();
            $.ui.generateTaps(q);
            q.bind($.ui.tapEvent, function() {
                function goBack() {
                    editPage.find('.jmuiBackButton').unbind($.ui.tapEvent, goBack);
                    $.ui.gotoPage(page, 'jmuiSlide', true, true);
                }
                if (!q.attr('disabled')) {
                    question.getCalculatedValue(function(value) {
                        function gotValue(value, defaultLoaded) {
                            value = value || '';
                            switch (question.getType()) {
                                case 'att':
                                    if (defaultLoaded) {
                                        image.attr('src', value);
                                    } else {
                                        mc.att.getAttachment(mc.db.getCurrentSubjectGuid(), value, function(data) {
                                            image.attr('src', data);
                                        });
                                    }
                                    break;
                                //case 'url':                    
                                default:
                                    image.attr('src', value);
                                    break;
                            }
                            editPage.find('h2').text(q.find('h3').text());
                            editPage.find('.jmuiBackButton').bind($.ui.tapEvent, goBack);
                            $.ui.gotoPage(editPage, 'jmuiSlide', false, true);
                        }
                        if (value === undefined || value === null) {
                            question.getValue(gotValue, false, true);
                        } else {
                            gotValue(value);
                        }
                    });
                }
            });
        }

        function bindEditImageMap(question) {
            var editPage, image, page, q;
            page = question.getPageObject();
            editPage = popupPage($($.ui.parentColumn(page[0])), 'editImageMapPage',question);
            image = editPage.find('img');
            bindImageMap(question, image);
            q = question.getQuestionObject();
            $.ui.generateTaps(q);
            q.bind($.ui.tapEvent, function() {
                var goBack;

                function actionButtonClick(e) {
                    if (!$.ui.defaultPrevented(e)) {
                        e.preventDefault();
                        question.getValue(function(value) {
                            q.find('h4').text(value && value.length ? '<answered>' : '');
                            question.valueChanged();
                            goBack();
                            $.ui.refreshScroller(page);
                        });
                    }
                }

                function pageAnimationEnd(e) {
                    if (e.direction === 'in') {
                        createPins(question, image);
                    }
                }
                goBack = function() {
                    editPage.find('.jmuiActionButton').unbind($.ui.tapEvent, actionButtonClick);
                    editPage.unbind('jmuiPageAnimationEnd', pageAnimationEnd);
                    $.ui.gotoPage(page, 'jmuiSlide', true, true);
                };
                if (!q.attr('disabled')) {
                    image.attr('src', q.attr('img'));
                    editPage.find('h2').text(q.find('h3').text());
                    editPage.find('.jmuiActionButton').bind($.ui.tapEvent, actionButtonClick);
                    editPage.bind('jmuiPageAnimationEnd', pageAnimationEnd);
                    $.ui.gotoPage(editPage, 'jmuiSlide', false, true);
                    createPins(question, image);
                }
            });
        }

        function bindEditList(question) {
            var editPage, page, q, ul;
            page = question.getPageObject();
            editPage = popupPage($($.ui.parentColumn(page[0])), 'editListPage',question);
            q = question.getQuestionObject();
            $.ui.generateTaps(q);
            ul = editPage.find('ul');
            q.bind($.ui.tapEvent, function() {
                var goBack;

                function actionButtonClick(e) {
                    if (!$.ui.defaultPrevented(e)) {
                        e.preventDefault();
                        question.getValue(function(value) {
                            q.find('h4').text(value && value.length ? '<answered>' : '');
                            question.valueChanged();
                            goBack();
                            $.ui.refreshScroller(page);
                        });
                    }
                }

                function pageAnimationStart(e) {
                    if (e.direction === 'in') {
                        createListItems(question, ul);
                    }
                }
                goBack = function() {
                    editPage.find('.jmuiActionButton').unbind($.ui.tapEvent, actionButtonClick);
                    editPage.unbind('jmuiPageAnimationStart', pageAnimationStart);
                    $.ui.gotoPage(page, 'jmuiSlide', true, true);
                };
                if (!q.attr('disabled')) {
                    editPage.find('h2').text(q.find('h3').text());
                    editPage.find('.jmuiActionButton').bind($.ui.tapEvent, actionButtonClick);
                    editPage.bind('jmuiPageAnimationStart', pageAnimationStart);
                    $.ui.gotoPage(editPage, 'jmuiSlide', false, true);
                    createListItems(question, ul);
                }
            });
        }

        function bindEditNumber(question) {
            var editPage, page, q;
            page = question.getPageObject();
            editPage = popupPage($($.ui.parentColumn(page[0])), 'editNumberPage',question);
            q = question.getQuestionObject();
            $.ui.generateTaps(q);
            q.bind($.ui.tapEvent, function() {
                var editor, goBack;

                function actionButtonClick(e) {
                    var value;
                    if (!$.ui.defaultPrevented(e)) {
                        e.preventDefault();
                        value = parseFloat(editor.val());
                        if (!value && value !== 0) {
                            value = null;
                        }
                        question.setValue(value);
                        q.find('h4').html(value);
                        question.valueChanged();
                        goBack();
                        $.ui.refreshScroller(page);
                    }
                }
                goBack = function() {
                    editPage.find('.jmuiActionButton').unbind($.ui.tapEvent, actionButtonClick);
                    editPage.find('.jmuiCancelButton').unbind($.ui.tapEvent, goBack);
                    $.ui.gotoPage(page, 'jmuiSlide', true, true);
                };
                if (!q.attr('disabled')) {
                    editor = editPage.find('input');
                    editPage.find('h2').text(q.find('h3').text());
                    question.getValue(function(value) {
                        editor.val(value);
                        editPage.find('.jmuiActionButton').bind($.ui.tapEvent, actionButtonClick);
                        editPage.find('.jmuiCancelButton').bind($.ui.tapEvent, goBack);
                        $.ui.gotoPage(editPage, 'jmuiSlide', false, true);
                    });
                }
            });
        }

        function bindEditNumberRange(question) {
            var editPage, page, q;
            page = question.getPageObject();
            editPage = popupPage($($.ui.parentColumn(page[0])), 'editNumberRangePage',question);
            q = question.getQuestionObject();
            $.ui.generateTaps(q);
            q.bind($.ui.tapEvent, function() {
                var editor, from, goBack, increment, to;

                function actionButtonClick(e) {
                    var value;
                    if (!$.ui.defaultPrevented(e)) {
                        e.preventDefault();
                        value = parseFloat(editor.html());
                        if (!value && value !== 0) {
                            value = null;
                        }
                        question.setValue(value);
                        q.find('h4').html(value);
                        question.valueChanged();
                        goBack();
                        $.ui.refreshScroller(page);
                    }
                }
                goBack = function() {
                    editPage.find('.jmuiActionButton').unbind($.ui.tapEvent, actionButtonClick);
                    editPage.find('.jmuiCancelButton').unbind($.ui.tapEvent, goBack);
                    $.ui.gotoPage(page, 'jmuiSlide', true, true);
                };
                if (!q.attr('disabled')) {
                    editor = editPage.find('.jmuiCompositeNumber');
                    from = parseInt(q.attr('min'), 10);
                    to = parseInt(q.attr('max'), 10);
                    increment = parseInt(q.attr('increment'), 10);
                    editor.attr('min', from);
                    editor.attr('max', to);
                    editor.attr('increment', increment);
                    editPage.find('h2').text(q.find('h3').text());
                    question.getValue(function(value) {
                        if (!value && value !== 0) {
                            value = '&nbsp;';
                        }
                        editor.html(value);
                        editPage.find('.jmuiActionButton').bind($.ui.tapEvent, actionButtonClick);
                        editPage.find('.jmuiCancelButton').bind($.ui.tapEvent, goBack);
                        $.ui.gotoPage(editPage, 'jmuiSlide', false, true);
                    });
                }
            });
        }

        function bindEditPhoto(question) {
            var dirty, editPage, page, q;

            page = question.getPageObject();
            editPage = popupPage($($.ui.parentColumn(page[0])), 'editPhotoPage',question);
            q = question.getQuestionObject();
            $.ui.generateTaps(q);
            q.bind($.ui.tapEvent, function() {
                var cachedValue, newValue, goBack, li;
                
                function deleteCallback(callback) {
                    dirty = 'delete';
                }

                function saveCallback(callback) {
                    dirty = 'save';
                    newValue = newValue || mc.db.guid();
                    callback(newValue);
                }
                
                function actionButtonClick(e) {
                
                    if (!$.ui.defaultPrevented(e)) {
                        if (dirty) {
                            e.preventDefault();
                            if (dirty === 'delete') {
                                if (cachedValue) {
                                    mc.db.deleteAttachment(mc.db.getCurrentSubjectGuid(), cachedValue, function(e) {
                                        if (!e) {
                                            question.deleteValue();
                                            cachedValue = undefined;
                                            q.find('h4').text('');
                                            question.valueChanged();
                                            goBack();
                                            $.ui.refreshScroller(page);
                                        }
                                    });
                                } else {
                                    goBack();
                                }
                            } else {
                                mc.att.setAttachment(mc.db.getCurrentSubjectGuid(), newValue, li.find('img').attr('src'), true, function(e) {
                                    if (!e && newValue) {
                                        question.setValue(newValue);
                                        cachedValue = newValue;
                                        newValue = undefined;
                                        q.find('h4').text('<answered>');
                                        question.valueChanged();
                                        goBack();
                                        $.ui.refreshScroller(page);
                                    } else {
                                        goBack();
                                    }
                                });
                            }
                        } else {
                            goBack();
                        }
                    }
                }
                goBack = function() {
                    
                    function goBackEnd() {
                        dirty = undefined;
                        editPage.find('.jmuiCancelButton').unbind($.ui.tapEvent, goBack);
                        editPage.find('.jmuiActionButton').unbind($.ui.tapEvent, actionButtonClick);
                        li.unbind($.ui.tapEvent, li._tapHandler);
                        li.unbind($.ui.tapAndHoldEvent, li._tapAndHoldHandler);
                        $.ui.gotoPage(page, 'jmuiSlide', true, true);
                    }
                    
                    // cleans up in case of cancel or delete
                    if (newValue) {
                        mc.db.deleteAttachment(mc.db.getCurrentSubjectGuid(), newValue, function(e) {
                            newValue = undefined;
                            goBackEnd();
                        });
                    } else {
                        goBackEnd();
                    }                    
                };
                if (!q.attr('disabled')) {
                    li = editPage.find('li');
                    bindPhoto(question, li, saveCallback, deleteCallback);
                    editPage.find('h2').text(q.find('h3').text());
                    question.getValue(function(value) {
                        cachedValue = value;
                        if (value) {
                            mc.att.getAttachment(mc.db.getCurrentSubjectGuid(), value, function(data) {
                                if (data) {
                                    li.html('<img width="100%" src="' + data + '"/>');
                                } else {
                                    question.showPlaceholder(li);
                                }
                                editPage.find('.jmuiActionButton').bind($.ui.tapEvent, actionButtonClick);
                                editPage.find('.jmuiCancelButton').bind($.ui.tapEvent, goBack);
                                $.ui.gotoPage(editPage, 'jmuiSlide', false, true);
                            });
                        } else {
                            question.showPlaceholder(li);
                            editPage.find('.jmuiActionButton').bind($.ui.tapEvent, actionButtonClick);
                            editPage.find('.jmuiCancelButton').bind($.ui.tapEvent, goBack);
                            $.ui.gotoPage(editPage, 'jmuiSlide', false, true);
                        }
                    }, true);
                }
            });
        }

        function bindEditSelect(question) {
            var backText, column, page, q, title;
            page = question.getPageObject();
            q = question.getQuestionObject();
            $.ui.generateTaps(q);
            column = $($.ui.parentColumn(page[0]));
            title = q.find('h3').text();
            backText = page.find('h1').text();
            q.bind($.ui.tapEvent, function() {
                if (!q.attr('disabled')) {
                    question.getValue(function(value) {
                        function callback(index, choice) {
                            var value;
                            if (choice) {
                                value = choice.value || undefined;
                                if (value === '') {
                                    value = undefined;
                                }
                                if (value !== undefined) {
                                    value = [value];
                                }
                                question.setValue(value);
                                if (value !== undefined) {
                                    q.find('h4').html(choice.label);
                                } else {
                                    q.find('h4').html('');
                                }
                                question.valueChanged();
                            }
                            $.ui.gotoPage(page, 'jmuiSlide', true, true);
                            index = undefined;
                        }
                        if (value && value.length) {
                            value = value[0];
                        }
                        question.getChoices(function(choices) {
                            $.ui.showListPage(column, choices, value, title, backText, callback);
                        });
                    });
                }
            });
        }

        function bindEditSelectButton(question, choices, pageClass) {
            var editPage, page, q, qid, choiceid;
            page = question.getPageObject();
            editPage = popupPage($($.ui.parentColumn(page[0])), pageClass,question);
            q = question.getQuestionObject();
            qid = question.getQuestionId();
            $.ui.generateTaps(q);
            q.bind($.ui.tapEvent, function() {
                var editor, goBack, html, i, j;

                function actionButtonClick(e) {
                    var value;
                    if (!$.ui.defaultPrevented(e)) {
                        e.preventDefault();
                        value = [];
                        html = '';
                        editPage.find('input').each(function() {
                            if (this.checked === true) {
                                value.push(this.value);
                                if (html.length > 0) {
                                    html += ', ';
                                }
                                html += this.nextElementSibling.innerHTML;
                            }
                        });
                        question.setValue(value);
                        q.find('h4').html(html);
                        question.valueChanged();
                        goBack();
                        $.ui.refreshScroller(page);
                    }
                }
                goBack = function() {
                    editPage.find('.jmuiActionButton').unbind($.ui.tapEvent, actionButtonClick);
                    editPage.find('.jmuiCancelButton').unbind($.ui.tapEvent, goBack);
                    $.ui.gotoPage(page, 'jmuiSlide', true, true);
                };
                if (!q.attr('disabled')) {
                    question.getValue(function(value) {
                        html = '';
                        for (i = 0; i < choices.length; i += 1) {
                            choiceid = qid + '_choice_' + i ;
                            html += '<li><input type="';
                            html += pageClass === 'editCheckboxPage' ? 'checkbox' : 'radio';
                            html += '" name="' + qid + '" value="' + choices[i].value + '" id="' + choiceid + '"';
                            if (value && value.length) {
                                for (j = 0; j < value.length; j += 1) {
                                    if (value[j] === choices[i].value) {
                                        html += ' checked=true';
                                    }
                                }
                            }
                            html += ' /><label for="' + choiceid + '">' + choices[i].label + '</label></li>';
                        }
                        editor = editPage.find('ul');
                        editor.empty();
                        editor.html(html);
                        if (pageClass === 'editCheckboxPage') {
                            $.ui.bindCheckboxes(editor);
                        } else {
                            $.ui.bindRadios(editor);
                        }
                        editPage.find('h2').text(q.find('h3').text());
                        editPage.find('.jmuiActionButton').bind($.ui.tapEvent, actionButtonClick);
                        editPage.find('.jmuiCancelButton').bind($.ui.tapEvent, goBack);
                        $.ui.gotoPage(editPage, 'jmuiSlide', false, true);
                    });
                }
            });
        }

        function bindEditSketch(question) {
            var editPage, page, q;
            page = question.getPageObject();
            editPage = popupPage($($.ui.parentColumn(page[0])), 'editSketchPage',question);
            q = question.getQuestionObject();
            $.ui.generateTaps(q);
            q.bind($.ui.tapEvent, function() {
                var jsig, goBack, ratio=6, showLine=true;

				function save() {
					if (question.ready()) {
						var data = jsig.jSignature("getData", "base30");
						var pngData = jsig.jSignature("getData", "image");
						var svgData = jsig.jSignature("getData", "svgbase64");
						question.setValue([JSON.stringify(data), pngData[1], svgData[1]]);
					}
				}
				
                function actionButtonClick(e) {
                    var value;
                    if (!$.ui.defaultPrevented(e)) {
                        e.preventDefault();
                        save();                        
                        question.valueChanged();
                        goBack();
                        $.ui.refreshScroller(page);
                    }
                }

				function onGoToEditPage(e) {
					if (e.direction === 'in') {
						editPage.find('div.jsig').empty();				
						jsig.jSignature({ showLine: showLine, sizeRatio: (30/ratio) });
						question.getValue(function(value) {
							if (value) {
								jsig.jSignature("setData", "data:" + JSON.parse(value[0]).join(","));								
							}
							editPage.unbind('jmuiPageAnimationStart', onGoToEditPage);
						});
					}
				}
				
                goBack = function() {					
                    editPage.find('.jmuiActionButton').unbind($.ui.tapEvent, actionButtonClick);
                    editPage.find('.jmuiCancelButton').unbind($.ui.tapEvent, goBack);
                    $.ui.gotoPage(page, 'jmuiSlide', true, true);
                };
                if (!q.attr('disabled')) {
                    editPage.find('h2').text(q.find('h3').text());
                    question.getValue(function(value) {
						jsig = jQuery(editPage).find('div.jsig');
						ratio = jsig.attr("ratio") | ratio;
						showLine = q.attr("sketchtype") == "signature";
						editPage.find('.jmuiActionButton').bind($.ui.tapEvent, actionButtonClick);
                        editPage.find('.jmuiCancelButton').bind($.ui.tapEvent, goBack);												
						editPage.bind('jmuiPageAnimationStart', onGoToEditPage);						
                        $.ui.gotoPage(editPage, 'jmuiSlide', false, false);                                                
                    });
                }
                return false;
            });
        }

        function bindEditText(question, pageClass) {
            var editPage, page, q;
            page = question.getPageObject();
            editPage = popupPage($($.ui.parentColumn(page[0])), pageClass,question,question);
            q = question.getQuestionObject();
            $.ui.generateTaps(q);
            q.bind($.ui.tapEvent, function() {
                var editor, goBack;

                function actionButtonClick(e) {
                    var value;
                    if (!$.ui.defaultPrevented(e)) {
                        e.preventDefault();
                        value = editor.val();
                        question.setValue(value);
                        if (pageClass === 'editPasswordPage') {
                            q.find('h4').html(value.length ? passwordMask : '');
                        } else {
                            q.find('h4').html(value);
                        }
                        question.valueChanged();
                        goBack();
                        $.ui.refreshScroller(page);
                    }
                }
                goBack = function() {
                    editPage.find('.jmuiActionButton').unbind($.ui.tapEvent, actionButtonClick);
                    editPage.find('.jmuiCancelButton').unbind($.ui.tapEvent, goBack);
                    $.ui.gotoPage(page, 'jmuiSlide', true, true);
                };
                if (!q.attr('disabled')) {
                    editor = editPage.find('input, textarea');
                    editPage.find('h2').text(q.find('h3').text());
                    question.getValue(function(value) {
                        value = value || '';
                        editor.val(value);
                        editPage.find('.jmuiActionButton').bind($.ui.tapEvent, actionButtonClick);
                        editPage.find('.jmuiCancelButton').bind($.ui.tapEvent, goBack);
                        $.ui.gotoPage(editPage, 'jmuiSlide', false, true);
                    });
                }
            });
        }

        function bindEditTime(question) {
            var editPage, page, q;
            page = question.getPageObject();
            editPage = popupPage($($.ui.parentColumn(page[0])), 'editTimePage',question);
            q = question.getQuestionObject();
            $.ui.generateTaps(q);
            q.bind($.ui.tapEvent, function() {
                var editor, goBack;

                function actionButtonClick(e) {
                    var a, value;
                    if (!$.ui.defaultPrevented(e)) {
                        e.preventDefault();
                        a = editor.html().split(':', 2);
                        if (a.length === 2) {
                            value = new Date();
                            value = new Date(value.getFullYear(), value.getMonth(), value.getDate(), a[0], a[1], 0, 0);
                            if (isNaN(value.getTime())) {
                                value = null;
                                q.find('h4').html('');
                            } else {
                                q.find('h4').html(editor.html());
                            }
                        } else {
                            value = null;
                            q.find('h4').html('');
                        }
                        question.setValue(value);
                        question.valueChanged();
                        goBack();
                        $.ui.refreshScroller(page);
                    }
                }
                goBack = function() {
                    editPage.find('.jmuiActionButton').unbind($.ui.tapEvent, actionButtonClick);
                    editPage.find('.jmuiCancelButton').unbind($.ui.tapEvent, goBack);
                    $.ui.gotoPage(page, 'jmuiSlide', true, true);
                };
                if (!q.attr('disabled')) {
                    editor = editPage.find('.jmuiCompositeTime');
                    editor.attr('increment', q.attr('increment'));
                    editPage.find('h2').text(q.find('h3').text());
                    question.getValue(function(value) {
                        if (value && value.constructor === Date) {
                            value.setMinutes(value.getMinutes() - value.getMinutes() % 5);
                            value = value.toString(Date.CultureInfo.formatPatterns.shortTime);
                        } else {
                            value = '&nbsp;';
                        }
                        editor.html(value);
                        editPage.find('.jmuiActionButton').bind($.ui.tapEvent, actionButtonClick);
                        editPage.find('.jmuiCancelButton').bind($.ui.tapEvent, goBack);
                        $.ui.gotoPage(editPage, 'jmuiSlide', false, true);
                    });
                }
            });
        }

        function bindEditToggle(question, choices) {
            var editPage, page, q;
            page = question.getPageObject();
            editPage = popupPage($($.ui.parentColumn(page[0])), 'editTogglePage',question);
            q = question.getQuestionObject();
            $.ui.generateTaps(q);
            q.bind($.ui.tapEvent, function() {
                var editor, goBack, html, i, j;

                function actionButtonClick(e) {
                    var value;
                    if (!$.ui.defaultPrevented(e)) {
                        e.preventDefault();
                        value = [];
                        html = '';
                        editPage.find('input').each(function() {
                            if (this.checked === true) {
                                value.push(this.value);
                                if (html.length > 0) {
                                    html += ', ';
                                }
                                html += this.parentElement.previousElementSibling.innerHTML;
                            }
                        });
                        question.setValue(value);
                        q.find('h4').html(html);
                        question.valueChanged();
                        goBack();
                        $.ui.refreshScroller(page);
                    }
                }
                goBack = function() {
                    editPage.find('.jmuiActionButton').unbind($.ui.tapEvent, actionButtonClick);
                    editPage.find('.jmuiCancelButton').unbind($.ui.tapEvent, goBack);
                    $.ui.gotoPage(page, 'jmuiSlide', true, true);
                };
                if (!q.attr('disabled')) {
                    question.getValue(function(value) {
                        html = '';
                        for (i = 0; i < choices.length; i += 1) {
                            html += '<li><span class="jmuiToggleText">' + choices[i].label + '</span><span class="jmuiToggle"><input type="checkbox" value="' + choices[i].value + '"';
                            if (value && value.length) {
                                for (j = 0; j < value.length; j += 1) {
                                    if (value[j] === choices[i].value) {
                                        html += ' checked=true';
                                    }
                                }
                            }
                            html += ' /></span></li>';
                        }
                        editor = editPage.find('ul');
                        editor.empty();
                        editor.html(html);
                        
                        editor.find('input').each(function (index, element) {
                            var init = new Switchery(element, {size: 'small'});
                        });
                        
                        editPage.find('h2').text(q.find('h3').text());
                        editPage.find('.jmuiActionButton').bind($.ui.tapEvent, actionButtonClick);
                        editPage.find('.jmuiCancelButton').bind($.ui.tapEvent, goBack);
                        $.ui.gotoPage(editPage, 'jmuiSlide', false, true);
                    });
                }
            });
        }

        function actionListInlineQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                superInitialize();
            }

            function load() {
                function callback() {
                    createActionListRows(that, spec.question);
                }
                superLoad(callback);
				
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function actionListPopupQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                superInitialize();
                bindEditActionList(that);
            }

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        spec.question.find('h4').text(value && value.length ? '<answered>' : '');
                    });
                }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function audioInlineQuestion(spec) {
            var btn, that, superInitialize, superLoad, superSave;

            function load() {
                function callback() { }
                superLoad(callback);
            }

            function save() { }

            function initialize() {
                superInitialize();
                btn = spec.question.find('.audioButton');
                bindAudio(that, btn, save);
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            superSave = that.save;
            that.save = save;
            return that;
        }

        function audioPopupQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                superInitialize();
                bindEditAudio(that);
            }

            function load() {
                function callback() { }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function barcodeInlineQuestion(spec) {
            var div, li, that, superInitialize, superLoad, superSave, placeholder, scanResult;

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        value = value || '';
                        if (value) {
                            if (placeholder[0]) {
                               div = placeholder;
                               that.showPlaceholder(div);
                            }
                            if (scanResult[0]) {
                                div = scanResult;
                            }
                            div.empty();
                            div.hide();
                            if (that.getDesignValue('postScanShowResult') !== 'false') {
                                div.show();
                            }
                            div.text(value);
                        } else {
                            if (placeholder[0]) {
                               div = placeholder;
                            }
                             that.showPlaceholder(div);
                        }
                    });
                }
                superLoad(callback);
            }

            function save() {
                if (that.ready()) {
                    if (scanResult[0]) {
                        div = scanResult;
                    }
                    that.setValue(div.text());
                }
            }

            function initialize() {
                superInitialize();
                li = spec.question.find('li');
                div = li.find('div');
                placeholder = li.find('.jmuiPlaceholder');
                scanResult = li.find('.jmuiScanresult');
                bindBarcode(that, li, save);
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            superSave = that.save;
            that.save = save;
            return that;
        }

        function barcodePopupQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                superInitialize();
                bindEditBarcode(that);
            }

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        value = value || '';
                        if (that.getDesignValue('postScanShowResult') !== 'false') {
                            spec.question.find('h4').text(value);
                        }
                    });
                }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function checkboxInlineQuestion(spec) {
            var qid, superInitialize, superLoad, that, choiceid;

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        if (Object.prototype.toString.call(value) === '[object Array]' && value.length !== 0) {
                            spec.question.find('input').each(function() {
                                var checked, i, myValue;
                                checked = false;
                                myValue = this.value;
                                for (i = 0; i < value.length; i += 1) {
                                    if (value[i] === myValue) {
                                        checked = true;
                                        break;
                                    }
                                }
                                this.checked = checked;
                            });
                        } else {
                            spec.question.find('input').each(function() {
                                this.checked = false;
                            });
                        }
                    });
                }
                superLoad(callback);
            }

            function save() {
                var value;
                if (that.ready()) {
                    value = [];
                    spec.question.find('input').each(function() {
                        if (this.checked) {
                            value.push(this.value);
                        }
                    });
                    that.setValue(value);
                }
            }

            function initialize() {
                function addChoices(choices) {
                    var html, i, n;
                    spec.question.empty();
                    n = choices.length;
                    html = '';
                    for (i = 0; i < n; i += 1) {
                        choiceid = qid + '_choice_' + i ;
                        html += '<li><input type="checkbox" name="' + qid + '" value="' + choices[i].value + '"  id="' + choiceid + '"/>';
                        html += '<label for="' + choiceid + '">' + choices[i].label + '</label></li>';
                    }
                    spec.question.html(html);
                    $.ui.bindCheckboxes(spec.question);
                    //spec.question.find('input').bind('change', save);
                    spec.question.find('input').bind('jmuiChange', save);
                    that.ready(true);
                }
                superInitialize();
                that.ready(false);
                that.getChoices(addChoices);
            }
            that = inlineQuestion(spec);
            qid = that.getQuestionId();
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            that.save = save;
            return that;
        }

        function checkboxPopupQuestion(spec) {
            var choices, superInitialize, superLoad, that;

            function initialize() {
                function addChoices(a) {
                    choices = a;
                    bindEditSelectButton(that, choices, 'editCheckboxPage');
                    that.ready(true);
                }
                superInitialize();
                that.ready(false);
                that.getChoices(addChoices);
            }

            function load() {
                function callback() {
                    var i, j, text;
                    that.getValue(function(value) {
                        if (value) {
                            text = [];
                            if (choices.length > 0) {
                                for (i = 0; i < value.length; i += 1) {
                                    for (j = 0; j < choices.length; j += 1) {
                                        if (value[i] === choices[j].value) {
                                            text.push(choices[j].label);
                                            break;
                                        }
                                    }
                                }
                                text = text.join(', ');
                            } else {
                                text = '';
                            }
                            spec.question.find('h4').html(text);
                        } else {
                            spec.question.find('h4').html('');
                        }
                    });
                }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function comboInlineQuestion(spec) {
            var superInitialize, superLoad, that;

            function load(rowIndex) {
                function callback() {
                    that.getValue(function(value) {
                        spec.question.find('input').val(value || '');
                    });
                }
                superLoad(callback);
                rowIndex = undefined;
            }

            function save() {
                if (that.ready()) {
                    that.setValue(spec.question.find('input').val());
                }
            }

            function initialize() {
                var input;

                function addChoices(choices) {
                    var droplist, i, html, n;
                    droplist = spec.question.find('select');
                    droplist.empty();
                    n = choices.length;
                    html = '';
                    for (i = 0; i < n; i += 1) {
                        html += '<option value="' + choices[i].value + '">' + choices[i].label + '</option>';
                    }
                    droplist.html(html);
                    that.ready(true);
                }
                superInitialize();
                that.ready(false);
                that.getChoices(addChoices);
                input = spec.question.find('input');
                input.bind('change', save);
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            that.save = save;
            return that;
        }

        function comboPopupQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                function addChoices(choices) {
                    bindEditCombo(that, choices);
                    that.ready(true);
                }
                superInitialize();
                that.ready(false);
                that.getChoices(addChoices);
            }

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        spec.question.find('h4').html(value || '');
                    });
                }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function compoundInlineQuestion(spec) {
            var superInitialize, superLoad, that;

         function initialize() {
                superInitialize();
                bindCompound(that, spec.question, function() {
                    $.ui.gotoPage(spec.page, 'jmuiSlide', true, false);
                });
            }

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        var templateName;
                        if (value === undefined || value === null || value === '') {
                            templateName = 'unansweredTemplate';
                        } else {
                            templateName = 'answeredTemplate';
                        }
                        spec.question.html(that.applyTemplate(templateName));
                    }, false);
                }
                superLoad(callback);
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function compoundPopupQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                superInitialize();
                bindCompound(that, spec.question, function() {
                    $.ui.gotoPage(spec.page, 'jmuiSlide', true, false);
                });
            }

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        var templateName;
                        if (value === undefined || value === null || value === '') {
                            templateName = 'unansweredTemplate';
                        } else {
                            templateName = 'answeredTemplate';
                        }
                        spec.question.html(that.applyTemplate(templateName));
                    }, false);
                }
                superLoad(callback);
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function dateInlineQuestion(spec) {
            var superInitialize, superLoad, that;

            function load() {
                function callback() {
                    var editor;
                    editor = spec.question.find('.jmuiCompositeDate');
                    that.getValue(function(v) {
                        if (v && v.constructor === Date) {
                            editor.text(mc.fl.format(v, 'D'));
                        } else {
                            editor.html('&nbsp;');
                        }
                    });
                }
                superLoad(callback);
            }

            function save() {
                var editor, v;
                if (that.ready()) {
                    editor = spec.question.find('.jmuiCompositeDate');
                    v = new Date(editor.html() + ' 12:00:00 UTC');
                    if (isNaN(v.getTime())) {
                        v = null;
                    }
                    that.setValue(v);
                }
            }

            function initialize() {
                superInitialize();
                spec.question.find('.jmuiCompositeDate').bind('change', save);
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            that.save = save;
            return that;
        }

        function datePopupQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                superInitialize();
                bindEditDate(that);
            }

            function load() {
                function callback() {
                    var t;
                    t = spec.question.find('h4');
                    that.getValue(function(v) {
                        if (v && v.constructor === Date) {
                            t.html(v.toLocaleDateString());
                        } else {
                            t.html('');
                        }
                    });
                }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function filteredListInlineQuestion(spec) {
            var superInitialize, superLoad, that;

            function load(submit) {
                function callback() {
                    if (submit && !that.busy) {
                        that.busy = true;
                        createFilterRows(that, spec.question);
                        spec.question.find('input').blur();
                        return false;
                    }
                    //				}
                }
                superLoad(callback);
            }

            function save() {
                var a, ul;
                a = [];
                ul = spec.question;
                ul.find('li.jmuiSelected').each(function(index, el) {
                    var me;
                    me = $(el);
                    a.push(me.attr('rowGuid'));
                    index = undefined;
                });
                that.setValue(a);
            }

            function reset(e) {
                var el, offset, padding, ul;
                ul = spec.question;
                el = ul.find('input');
                if (e && !$.ui.defaultPrevented(e)) {
                    offset = el.offset();
                    padding = parseInt(el.style('padding-right'), 10);
                    if (e.pageX >= offset.left + el[0].offsetWidth - padding) {
                        if (!that.busy) {
                            $.ui.cancelEvent(e);
                            ul.find('li:not(.searchBar)').remove();
                            el.val('');
                            that.setValue([]);
                            //el.blur(); // only works inside a click event, not a tap
                            return false;
                        }
                    }
                }
            }

            function initialize() {
                var form, input, li;
                superInitialize();
                li = spec.question.find('.searchBar');
                input = li.find('input');
                $.ui.generateTaps(input);
                input.bind($.ui.tapEvent, reset);
                //input.bind('keypress', load);
                form = li.find('form');
                form.bind('submit', function(e) {
                    $.ui.cancelEvent(e);
                    load(true);
                    return false;
                });
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            that.save = save;
            return that;
        }

        function filteredListPopupQuestion(spec) {
            var that;
            that = popupQuestion(spec);
            return that;
        }

        function gridInlineQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                superInitialize();
            }

            function load() {
                function callback() {
                    createGridRows(that, spec.question);
                }
                superLoad(callback);
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function gridPopupQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                superInitialize();
                bindEditGrid(that);
            }

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        spec.question.find('h4').text(value && value.length ? '<answered>' : '');
                    });
                }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function imageInlineQuestion(spec) {
            var that, superLoad;

            function load() {
                function callback() {
                    that.getCalculatedValue(function(value) {
                        function gotValue(value, defaultLoaded) {
                            if (value !== "") {
                                switch (that.getType()) {
                                    case 'att':
                                        if (defaultLoaded) {
                                            spec.question.find('img').attr('src', value);
                                        } else {
                                            mc.att.getAttachment(mc.db.getCurrentSubjectGuid(), value, function(data) {
                                                spec.question.find('img').attr('src', data);
                                            });
                                        }
                                        break;
                                    //case 'url':                    
                                    default:
                                        spec.question.find('img').attr('src', value);
                                        break;
                                }
                            }
                        }
                        if (value === undefined || value === null) {
                            that.getValue(function(value, defaultLoaded) {
                                gotValue(value || '', defaultLoaded);
                            }, false, true);
                        } else {
                            gotValue(value, false);
                        }
                    });
                }
                superLoad(callback);
            }
            that = inlineQuestion(spec);
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function imagePopupQuestion(spec) {
            var that, superInitialize, superLoad;

            function initialize() {
                superInitialize();
                bindEditImage(that, 'editImagePage');
            }

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        spec.question.find('h4').text(value && value.length ? '<answered>' : '');
                    });
                }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function imageMapInlineQuestion(spec) {
            var image, superInitialize, that;

            function initialize() {
                superInitialize();
                image = spec.question.find('img');
                bindImageMap(that, image);
            }

            function postLoad() {
                createPins(that, image);
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            that.postLoad = postLoad;
            return that;
        }

        function imageMapPopupQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                superInitialize();
                bindEditImageMap(that);
            }

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        spec.question.find('h4').text(value && value.length ? '<answered>' : '');
                    });
                }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function labelInlineQuestion(spec) {
            var superLoad, that;

            function load() {
                function callback() {
                    that.getCalculatedValue(function(value) {
                        function gotValue(value) {
                            var hideFormula;
                            spec.question.find('li').each(function() {
                                var background, me;
                                me = $(this);
                                me.html(value);
                                background = that.getBackground();
                                if (background) {
                                    me.style('background', background);
                                }
                            });
                            // Following code commented out because label visibility is now only controlled inside hide formulas
                            // commented back in because we DO need this
                            // we need to hide the value but not the header if the value is blank
                            // or have more control over hiding the data and header separately
                            hideFormula = 'questionHide_' + that.getQuestionId();
                            if (mc.fl.hasOwnProperty(hideFormula)) {
                                mc.fl[hideFormula]();
                            } else {
                                if (value) {
                                    spec.question.show();
                                } else {
                                    spec.question.hide();
                                }
                            }
                        }
                        if (value === undefined || value === null) {
                            that.getValue(function(value) {
                                value = value || '';
                                gotValue(value);
                            });
                        } else {
                            gotValue(value);
                        }
                    });
                }
                superLoad(callback);
            }
            that = inlineQuestion(spec);
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function labelPopupQuestion(spec) {
            var superLoad, that;

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        value = value || '';
                        spec.question.find('h4').html(value);
                    });
                }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function listInlineQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                superInitialize();
            }

            function load() {
                function callback() {
                    createListItems(that, spec.question);
                }
                superLoad(callback);
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function listPopupQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                superInitialize();
                bindEditList(that);
            }

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        spec.question.find('h4').text(value && value.length ? '<answered>' : '');
                    });
                }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function locationInlineQuestion(spec) {
            var superLoad, that;

            function load() {
                function callback() {
                    that.getCalculatedValue(function(value) {
                        if (value === undefined || value === null) {
                            value = that.getValue() || '';
                        }
                        spec.question.find('li').each(function() {
                            var background, me;
                            me = $(this);
                            me.html(value);
                            background = that.getBackground();
                            if (background) {
                                me.style('background', background);
                            }
                        });
                        if (value) {
                            spec.question.show();
                        } else {
                            spec.question.hide();
                        }
                    });
                }
                superLoad(callback);
            }
            that = inlineQuestion(spec);
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function mapInlineQuestion(spec) {
            var notSupported = $.isWindows8, geocoder, infowindow, map, markers = [], superInitialize, that;

            function clearMarkers() {
                var i;
                if (notSupported) {
                  return;
                }
                if (markers) {
                    for (i in markers) {
                        markers[i].setMap(null);
                    }
                    markers.length = 0;
                }
            }

            function addMarker(m) {
                if (notSupported) {
                  return;
                }
                markers.push(m);
            }

            function segmentSelected(e) {
                if (e.segmentId && spec.question.parent()[0].id === e.segmentId) {
                    spec.question.trigger('resize');
                }
            }

            function initialize() {
                var latlng, options;
                superInitialize();
                if (notSupported) {
                  return;
                }
                if (spec.question.parent().hasClass('jmuiSegmentPanel')) {
                    spec.question.parent().parent().bind('jmuiChange', segmentSelected);
                }
                loadMapsAsync().then(
                    function success() {
                        if (typeof (google) !== 'undefined') {
                            if (google.maps !== undefined) {
                                latlng = new google.maps.LatLng(52.93221, -1.475029);
                                options = {
                                    zoom: 12,
                                    center: latlng,
                                    mapTypeId: window.google.maps.MapTypeId.ROADMAP
                                };
                                map = new window.google.maps.Map(spec.question.find('div')[0], options);
                                geocoder = new window.google.maps.Geocoder();
                                infowindow = new window.google.maps.InfoWindow();
                                spec.question.find('div').bind(isTouchable ? 'touchstart' : 'mousedown', function(e) {
                                    e.stopPropagation(); // Prevent touch from starting page scroll.
                                });
                                return;
                            }
                        }
                    },
                    function error() {
                        console.error('maps api not loaded');                        
                    });
            }

            function postLoad() {
                if (notSupported) {
                  return;
                }
                loadMapsAsync().then(
                    function success() {
                        clearMarkers();
                        if (typeof (google) !== 'undefined') {
                            if (google.maps !== undefined) {
                                createMapRows(that, map, geocoder, infowindow);
                            }
                        }
                    });
            }

            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            that.postLoad = postLoad;
            that.addMarker = addMarker;
            that.clearMarkers = clearMarkers;
            return that;
        }

        function notesInlineQuestion(spec) {
            var superInitialize, superLoad, that;

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        spec.question.find('textarea').val(value || '');
                    });
                }
                superLoad(callback);
            }

            function save() {
                if (that.ready()) {
                    that.setValue(spec.question.find('textarea').val());
                }
            }

            function initialize() {
                superInitialize();
                spec.question.find('textarea').bind('change', save);
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            that.save = save;
            return that;
        }

        function notesPopupQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                superInitialize();
                bindEditText(that, 'editNotesPage');
            }

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        spec.question.find('h4').html(value || '');
                    });
                }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function numberInlineQuestion(spec) {
            var superInitialize, superLoad, that;

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        if (value !== null && value !== undefined) {
                            spec.question.find('input').val(value);
                        } else {
                            spec.question.find('input').val('');
                        }
                    });
                }
                superLoad(callback);
            }

            function save() {
                var value;
                if (that.ready()) {
                    value = spec.question.find('input').val();
                    that.setValue(value.length ? parseFloat(value) : null);
                }
            }

            function initialize() {
                superInitialize();
                spec.question.find('input').bind('change', save);
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            that.save = save;
            return that;
        }

        function numberPopupQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                superInitialize();
                bindEditNumber(that);
            }

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        if (value !== undefined && value !== null) {
                            spec.question.find('h4').html(value);
                        } else {
                            spec.question.find('h4').html('');
                        }
                    });
                }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function numberRangeInlineQuestion(spec) {
            var superInitialize, superLoad, that;

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        if (value !== null && value !== undefined) {
                            spec.question.find('.jmuiCompositeNumber').html(value);
                        } else {
                            spec.question.find('.jmuiCompositeNumber').html('&nbsp;');
                        }
                    });
                }
                superLoad(callback);
            }

            function save() {
                var value;
                if (that.ready()) {
                    value = spec.question.find('.jmuiCompositeNumber').html();
                    value = value.length ? parseFloat(value) : null;
                    if (isNaN(value)) {
                        value = null;
                    }
                    that.setValue(value);
                }
            }

            function initialize() {
                superInitialize();
                spec.question.find('.jmuiCompositeNumber').bind('change', save);
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            that.save = save;
            return that;
        }

        function numberRangePopupQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                superInitialize();
                bindEditNumberRange(that);
            }

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        if (value !== undefined && value !== null) {
                            spec.question.find('h4').html(value);
                        } else {
                            spec.question.find('h4').html('');
                        }
                    });
                }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function passwordInlineQuestion(spec) {
            var superInitialize, superLoad, that;

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        spec.question.find('input').val(value || '');
                    });
                }
                superLoad(callback);
            }

            function save() {
                if (that.ready()) {
                    that.setValue(spec.question.find('input').val());
                }
            }

            function initialize() {
                superInitialize();
                spec.question.find('input').bind('change', save);
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            that.save = save;
            return that;
        }

        function passwordPopupQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                superInitialize();
                bindEditText(that, 'editPasswordPage');
            }

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        spec.question.find('h4').html(value ? passwordMask : '');
                    });
                }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function photoInlineQuestion(spec) {
            var cachedValue, li, that, superInitialize, superLoad, superSave;

            function load() {
                function callback() {
                    function gotValue(value) {
                        cachedValue = value;
                        if (value) {
                            mc.att.getAttachment(mc.db.getCurrentSubjectGuid(), value, function(data) {
                                if (data) {
                                    li.html('<img width="100%" src="' + data + '"/>');
                                } else {
                                    that.showPlaceholder(li);
                                }
                            });
                        } else {
                            that.showPlaceholder(li);
                        }
                    }
                    that.getValue(gotValue, true);
                }
                superLoad(callback);
            }

            function save(callback) {
                var guid;
                if (that.ready()) {
                    guid = cachedValue || mc.db.guid();
                    mc.att.setAttachment(mc.db.getCurrentSubjectGuid(), guid, li.find('img').attr('src'), true, function(e) {
                        if (!e) {
                            if (!cachedValue) {
                                cachedValue = guid;
                                that.setValue(cachedValue);
                            }
                            callback && callback(cachedValue);
                            mc.fl.refreshiscroll(1500);							
                        }
                    });
                }
            }

            function deleteValue() {
                if (that.ready()) {
                    if (cachedValue) {
                        mc.db.deleteAttachment(mc.db.getCurrentSubjectGuid(), cachedValue, function(e) {
                            if (!e) {
                                that.deleteValue();
                                cachedValue = undefined;
                            }
                        });
                    }
                }
            }

            function initialize() {
                superInitialize();
                li = spec.question.find('li');
                bindPhoto(that, li, save, deleteValue);
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            superSave = that.save;
            that.save = save;
            return that;
        }

        function photoPopupQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                superInitialize();
                bindEditPhoto(that);
            }

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        spec.question.find('h4').text(value ? '<answered>' : '');
                    }, true);
                }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function processSelectorInlineQuestion(spec) {
            var superInitialize, superLoad, that;

            function clear(e) {
                if (!$.ui.defaultPrevented(e)) {
                    e.preventDefault();
                    mc.msgBox(function(text) {
                        if (text === 'Yes') {
                            //should this use a call to isOurShell() ??
                            var uri;
                            function loadClear(uri) {
                                uri.addQuery('newguid', 'yes');
                                window.locationUtils.setURI(uri);
                            }
                            function browserClear() {
                                var currentProcess = mc.db.getCurrentProcess();
                                uri = URI(mc.getRootPath() + 'mdesign/0/procs/clear.html');
                                if (MCAPTURE_CFG.isTesting == 'yes' && MCAPTURE_CFG.deviceType.toString().toLowerCase().substring(0, 1) == 'w') {
                                    uri.addQuery('clienttype', currentProcess.devClient);
                                    uri.addQuery('devicetype', currentProcess.devPlatform);
                                    uri.addQuery('deviceformat', currentProcess.devFormat);
                                } 
                                loadClear(uri);
                            	//window.locationUtils.setHref(mc.getRootPath() + 'mdesign/0/procs/clear.html?newguid=yes');
                            }
                            function shellClear(clearUrl) {
                                uri = URI(clearUrl);
                                loadClear(uri);
                            }
                            if (window.cordova && window.cordova.exec && window.plugins && window.plugins.settings) {
                                window.plugins.settings.getClearURL(shellClear,browserClear);
                            } else {
                                browserClear();
                            }
                        }
                    }, 'Confirm', 'Clear all data?', 'Yes', 'No');
                }
            }

            function save(callback) {
                var li;
                if (that.ready()) {
                    li = $(this);
                    li.parent().find('.jmuiSelected').removeClass('jmuiSelected');
                    li.addClass('jmuiSelected');
                    that.setValue($(this).attr('processId'), callback);
                }
            }

            function load() {
                function callback() {
                    var designProcesses, html, i, li, n, name, processes;
                    spec.question.empty();
                    designProcesses = that.getDesignValue('processes');
                    if (designProcesses && designProcesses.constructor === Array) {
                        processes = [];
                        for (i = 0; i < designProcesses.length; i += 1) {
                            name = mc.db.makeProcessName({
                                id: designProcesses[i],
                                version: mc.db.getLatestProcessVersion(designProcesses[i])
                            });
                            processes.push({
                                'name': name,
                                'value': mc.db.getProcess(name)
                            });
                        }
                    } else {
                        processes = mc.db.getLatestProcesses();
                        if (processes !== undefined) {
                            processes.sort(function(a, b) {
                                if (a.value.title !== undefined && b.value.title !== undefined) {
                                    return a.value.title.localeCompare(b.value.title);
                                }
                                return a.value.id.localeCompare(b.value.id);
                            });
                        }
                    }
                    if (processes) {
                        n = processes.length;
                        for (i = 0; i < n; i += 1) {
                            if (processes[i].value !== undefined && processes[i].value.hidden !== true && (mc.db.isProcessDeployed(processes[i].value.id) === true || mc.db.isProcessInUse(processes[i].value.id) === true)) {
                                html = that.applyTemplate('template', processes[i].value);
                                if (html) {
                                    li = $(window.document.createElement('ul'));
                                    li.html(html);
                                    li = li.find('li');
                                } else {
                                    li = $(window.document.createElement('li'));
                                    li.addClass('jmuiArrow');
                                    li.text(processes[i].value.title);
                                }
                                li.addClass('jmuiColorPress');
                                li.attr('processId', processes[i].value.id);
                                spec.question[0].appendChild(li[0]);
                            }
                        }
                        $.ui.generateTaps(spec.question.find('li').bind($.ui.tapEvent, function() {
                            var processId, processVersion;

                            function nextPage() {
                                var formula, formulaName, process;
                                process = mc.db.getProcess(mc.db.makeProcessName({
                                    'id': processId,
                                    'version': processVersion
                                }));
                                if (process.singleSubject) {
                                    if (process.deleteOnOpen) {
                                        mc.showActivity();
                                        mc.db.deleteAllSubjects(process.id, process.version, function() {
                                            mc.hideActivity();
                                            mc.gotoUrl(process.url, !process.urlProcess);
                                        });
                                    } else {
                                        //NB
                                        //If the process says its not client createable process.notClientCreatable === true
                                        //We open the process and create a new subject so that the designer of the process
                                        //can detect that case and display an error message to the user
                                        //When that process is closed the subject will be deleted
                                        mc.gotoUrl(process.url, !process.urlProcess);
                                    }
                                } else {
                                    //$.ui.gotoPage($('#subjectsPage'), 'jmuiSlide');
                                    formulaName = that.getQuestionId() + '_RowTap';
                                    mc.currentPage(that.getPageId());
                                    formula = mc.fl[formulaName];
                                    if (formula !== undefined && formula.constructor === Function) {
                                        mc.showActivity();
                                        formula(function(pageId) {
                                            mc.hideActivity();
                                            if (pageId && typeof pageId === 'string') {
                                                $.ui.gotoPage($('#' + pageId), 'jmuiSlide');
                                            }
                                        });
                                    } else {
                                        mc.fl.pagenext();
                                    }
                                }
                            }
                            processId = $(this).attr('processId');
                            processVersion = mc.db.getLatestProcessVersion(processId);
                            save.call(this, nextPage);
                        }));
                    }
                }
                superLoad(callback);
            }

            function replicate(e) {
                if (!$.ui.defaultPrevented(e)) {
                    e.preventDefault();
                    mc.fl.replicatedialog();
                }
            }

            function initialize() {
                superInitialize();
                spec.page.find('.jmuiCancelButton').bind($.ui.tapEvent, clear);
                spec.page.find('.jmuiActionButton').bind($.ui.tapEvent, replicate);
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            that.save = save;
            return that;
        }

        function processSelectorPopupQuestion(spec) {
            var superInitialize, that;

            function initialize() {
                superInitialize();
            }

            function load() { }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            that.load = load;
            return that;
        }

        function radioInlineQuestion(spec) {
            var qid, superInitialize, superLoad, that;

            function save() {
                var value;
                if (that.ready()) {
                    value = [];
                    spec.question.find('input').each(function() {
                        if (this.checked) {
                            value.push(this.value);
                        }
                    });
                    that.setValue(value);
                }
            }

            function initialize() {
                function addChoices(choices) {
                    var html, i, n, choiceid;
                    spec.question.empty();
                    n = choices.length;
                    html = '';
                    for (i = 0; i < n; i += 1) {
                        choiceid = qid + '_choice_' + i ;
                        html += '<li><input type="radio" name="' + qid + '" value="' + choices[i].value + '" id="' + choiceid +'"/>';
                        html += '<label for="' +choiceid + '">' + choices[i].label + '</label></li>';
                    }
                    spec.question.html(html);
                    $.ui.bindRadios(spec.question);
                    spec.question.find('input').bind('change', save);
                    that.ready(true);
                }
                superInitialize();
                that.ready(false);
                that.getChoices(addChoices);
            }

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        if (Object.prototype.toString.call(value) === '[object Array]' && value.length !== 0) {
                            spec.question.find('input').each(function() {
                                var checked, i, myValue;
                                checked = false;
                                myValue = this.value;
                                for (i = 0; i < value.length; i += 1) {
                                    if (value[i] === myValue) {
                                        checked = true;
                                        break;
                                    }
                                }
                                this.checked = checked;
                            });
                        } else {
                            spec.question.find('input').each(function() {
                                this.checked = false;
                            });
                        }
                    });
                }
                superLoad(callback);
            }
            that = inlineQuestion(spec);
            qid = that.getQuestionId();
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            that.save = save;
            return that;
        }

        function radioPopupQuestion(spec) {
            var choices, superInitialize, superLoad, that;

            function initialize() {
                function addChoices(a) {
                    choices = a;
                    bindEditSelectButton(that, choices, 'editRadioPage');
                    that.ready(true);
                }
                superInitialize();
                that.ready(false);
                that.getChoices(addChoices);
            }

            function load() {
                function callback() {
                    var i, j, text;
                    that.getValue(function(value) {
                        if (value) {
                            text = [];
                            if (choices.length > 0) {
                                for (i = 0; i < value.length; i += 1) {
                                    for (j = 0; j < choices.length; j += 1) {
                                        if (value[i] === choices[j].value) {
                                            text.push(choices[j].label);
                                            break;
                                        }
                                    }
                                }
                                text = text.join(', ');
                            } else {
                                text = '';
                            }
                            spec.question.find('h4').html(text);
                        } else {
                            spec.question.find('h4').html('');
                        }
                    });
                }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function ready(questions) {
            initControls();
            initQuestions(questions);
        }

        function selectionInlineQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                superInitialize();
            }

            function save() {
                var value;
                if (that.ready()) {
                    value = spec.question.find('select').val();
                    if (value === '') {
                        value = undefined;
                    }
                    if (value !== undefined) {
                        value = [value];
                    }
                    that.setValue(value);
                }
            }

            function load() {
                function callback() {
                    function addChoices(choices) {
                        var droplist, i, html, n;
                        n = choices.length;
                        html = '';
                        for (i = 0; i < n; i += 1) {
                            html += '<option value="' + choices[i].value + '">' + choices[i].label + '</option>';
                        }
                        droplist = spec.question.find('select');
                        droplist.empty();
                        droplist.html(html);
                        droplist.bind('change', save);
                        that.getValue(function(v) {
                            if (v && v.constructor === Array && v.length > 0) {
                                v = v[0];
                            } else {
                                v = undefined;
                            }
                            spec.question.find('select').val(v);
                            save(); // previous line has side effects which need saving sometimes.
                        });
                    }
                    that.getChoices(addChoices);
                }
                superLoad(callback);
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            that.save = save;
            return that;
        }

        function selectionPopupQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                superInitialize();
                bindEditSelect(that);
            }

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        value = value || '';
                        if (value) {
                            if (value.constructor === Array) {
                                if (value.length > 0) {
                                    value = value[0];
                                } else {
                                    value = '';
                                }
                            }
                            that.getChoices(function(choices) {
                                var i;
                                if (choices.length > 0) {
                                    for (i = 0; i < choices.length; i += 1) {
                                        if (choices[i].value === value) {
                                            value = choices[i].label;
                                            break;
                                        }
                                    }
                                }
                                spec.question.find('h4').html(value);
                            });
                        } else {
                            spec.question.find('h4').html('');
                        }
                    });
                }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function showQuestion(questionId, show) {
            var label, q, question;
            question = $('#' + 'md_' + questionId + '_container');
            if (question && question.length) {
                label = question[0].previousElementSibling;
                if (label && label.nodeName === 'H2') {
                    label = $(label);
                    if (show === true) {
                        label.show();
                    } else {
                        label.hide();
                    }
                }
                if (show === true) {
                    if (questionType(question) === qType.labelInline) {
                        q = questionMaker($.ui.parentPage(question[0]).id, questionId);
                        q.getCalculatedValue(function(value) {
                            if (value === undefined || value === null) {
                                q.getValue(function(value) {
                                    if (value) {
                                        question.show();
                                    } else {
                                        question.hide();
                                    }
                                });
                            } else {
                                question.show();
                            }
                        });
                    } else {
                        question.show();
						if( question.find(".jSignature").length > 0 ) {
							if( jQuery ) {
								jQuery(".jsig").resize();
							}
						}
                    }
                } else {
                    question.hide();
                }
            }
        }

        function signatureInlineQuestion(spec) {
            var li, superInitialize, superLoad, that;

            function initialize() {
                function edit() {
                    var plugin;
                    if (that.ready()) {
                        plugin = $('#mdcPlugin');
                        if (plugin.length > 0) {
                            that.getValue(function(value) {
                                try {
                                    value = plugin[0].signatureDialog(value);
                                    that.setValue(value);
                                } catch (e) {
                                    alert(e);
                                }
                            });
                        }
                    }
                }
                superInitialize();
                li = spec.question.find('li');
                if ($.isZetakey) {
                    $.ui.generateTaps(li);
                    li.bind($.ui.tapEvent, edit);
                } else {
                    li.attr('disabled', 'disabled');
                }
            }

            function load() {
                function callback() { }
                superLoad(callback);
            }

            function save() {
                //if (that.ready()) {
                //}
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            that.save = save;
            return that;
        }

        function sketchInlineQuestion(spec) {
            var jsig, superInitialize, superLoad, that;

            function load() {
                function callback() {
					function animEnded(e) {
						if (e.direction === 'in') {
                            that.getValue(function(value) {
                                if (value) {
                                    jsig.jSignature("setData", "data:" + JSON.parse(value[0]).join(","));
                                }
                            });
							spec.page.unbind('jmuiPageAnimationEnd', animEnded);
                        }
					}
                    spec.page.bind('jmuiPageAnimationEnd', animEnded);
                }
                superLoad(callback);
            }

            function save() {
                if (that.ready()) {
                    var data = jsig.jSignature("getData", "base30");
                    var pngData = jsig.jSignature("getData", "image");
                    var svgData = jsig.jSignature("getData", "svgbase64");
                    that.setValue([JSON.stringify(data), pngData[1], svgData[1]]);
                }
            }

            function initialize() {
                var initialized = false;
                superInitialize();
                spec.page.bind('jmuiPageAnimationEnd', function(e) {
                    if (e.direction === 'in' && !initialized) {
                        var showLine = true;
						var ratio = 7;
                        initialized = true;
                        jsig = jQuery(spec.question[0]).find('.jsig');
						ratio = jsig.attr("ratio");
                        showLine = spec.question.attr("sketchtype") == "signature";
                        jsig.jSignature({ showLine: showLine, sizeRatio: (30/ratio) });
                        jsig.bind('change', function(e) {
                            save();
                        });
						spec.question.find('.jsig').bind('touchstart', function() {
                            $('div.jmuiPage.jmuiCurrent div.jmuiNativeScroller').addClass('noscroll');
                        });
                        spec.question.find('.jsig').bind('touchend', function() {
                            $('div.jmuiPage.jmuiCurrent div.jmuiNativeScroller').removeClass('noscroll');
                        });
                        spec.question.find('.jsig').bind('mousedown', function() {
                            $('div.jmuiPage.jmuiCurrent div.jmuiNativeScroller').addClass('noscroll');
                        });
                        spec.question.find('.jsig').bind('mouseup', function() {
                            $('div.jmuiPage.jmuiCurrent div.jmuiNativeScroller').removeClass('noscroll');
                        });
                    }
                });
            }

            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            that.save = save;
            return that;
        }

        function sketchPopupQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                superInitialize();
                bindEditSketch(that);
            }

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        var text;
                        text = (value && value.length) ? '<answered>' : '';
                        spec.question.find('h4').text(text);
                    });
                }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function subjectSelectorInlineQuestion(spec) {
            var addButton, currentSubjectGuid, processId, superInitialize, superLoad, that, alreadyOpened;

            function save(e, subjectGuid) {
                var formulaName, tr;

                function openSubject(open) {
                    if (open !== false) {
                        mc.fl.pushsubject();
                        mc.fl.opensubject(undefined, subjectGuid);
                    }
                }
                if (!e || !e.jmuiTarget || !$(e.jmuiTarget).hasClass('subjectDelete')) {
                    if (that.ready()) {
                        if (subjectGuid === undefined) {
                            tr = $(this);
                            subjectGuid = tr.attr('subjectGuid');
                            tr.parent().find('.jmuiSelected').removeClass('jmuiSelected');
                            tr.addClass('jmuiSelected');
                            that.setValue(subjectGuid);
                            formulaName = that.getQuestionId() + '_RowTap';
                            mc.fl.execFormula(formulaName, openSubject, openSubject, true, subjectGuid);
                        } else {
                            openSubject(true);
                        }
                    }
                }
            }

            function createSubject(e) {
                var formulaName;

                function success() { }

                function error() {
                    var processVersion;
                    if (!$.ui.defaultPrevented(e) && processId !== undefined) {
                        e.preventDefault();
                        processVersion = mc.db.getLatestProcessVersion(processId);
                        mc.db.createSubject(processId, processVersion, undefined, function(subject) {
                            save(undefined, subject.guid);
                        });
                    }
                }
                formulaName = 'action_' + mc.currentPage() + '_NewSubject';
                mc.fl.execFormula(formulaName, success, error, true);
            }

            function deleteSubject(e, subjectGuid) {
                var formulaName, me, tr;

                function doDelete() {
                    mc.db.deleteSubject(subjectGuid);
                    tr.remove();
                }

                function callback(del) {
                    if (del !== false) {
                        if (del === true) {
                            doDelete();
                        } else {
                            mc.msgBox(function(text) {
                                if (text === 'Yes') {
                                    doDelete();
                                }
                            }, 'Confirm', 'Delete subject?', 'Yes', 'No');
                        }
                    }
                    me.removeClass('subjectConfirmDelete');
                }
                me = $(this);
                me.addClass('subjectConfirmDelete');
                tr = $($.ui.parentElement(this, 'subjectRow'));
                if (subjectGuid === undefined) {
                    subjectGuid = tr.attr('subjectGuid');
                }
                formulaName = that.getQuestionId() + '_RowDelete';
                mc.fl.execFormula(formulaName, callback, callback, true, subjectGuid);
                e = undefined;
            }

            function doubleSubjectPrevention(e) {				
				if(!alreadyOpened) {					
					alreadyOpened = true;
					createSubject(e);
					addButton.disabled = true;
					setTimeout(function() {
						alreadyOpened = false;
					}, 500);
				}
			}

            function initialize() {
                superInitialize();
                addButton = spec.page.find('.NewSubject');
                addButton.bind($.ui.tapEvent, doubleSubjectPrevention);
                spec.page.find('.jmuiBackButton').bind($.ui.tapEvent, function(e) {
                    if (!$.ui.defaultPrevented(e)) {
                        e.preventDefault();
                        that.deleteValue();
                        $.ui.gotoPage($('#processesPage'), 'jmuiSlide', true);
                    }
                });
                currentSubjectGuid = mc.db.getCurrentSubjectGuid().toLowerCase();
            }

            function load() {
                function callback() {
                    var filter, rowCount, summaryNames, table, filterFormula;

                    function rowSelection(selection, row) {
                        function insertRow(selected) {
                            var html, name, tr;
                            if (selected !== false) {	// Might be true or a string so do not change this condition
                                html = that.applyTemplate('rowTemplate', row);
                                if (html) {
                                    tr = $(window.document.createElement('tbody'));
                                    tr.html(html);
                                    tr = tr.find('tr').item(0);
                                }
                                if (tr === undefined) {
                                    tr = $(window.document.createElement('tr'));
                                    tr.addClass('jmuiArrow');
                                    name = row.name || row.guid;
                                    if (html === undefined) {
                                        html = '<span class="subjectDelete"></span>' + name;
                                    }
                                    tr.html(html);
                                }
                                tr.addClass('subjectRow');
                                tr.attr('subjectGuid', row.guid);
                                table[0].appendChild(tr[0]);
                                $.ui.generateTaps(tr.bind($.ui.tapEvent, save));
                                $.ui.generateTaps(tr.find('.subjectDelete').bind($.ui.tapEvent, deleteSubject));
                            }
                            rowCount -= 1;
                            if (rowCount <= 0) {
                                $.ui.refreshScroller(spec.page);
                            }
                        }
                        mc.fl.execFormula(selection, insertRow, insertRow, true, row, processId);
                    }
                    function getFilteredRows(filter) {
                        mc.db.getSubjectSummaries(processId, undefined, summaryNames, filter, function(rows) {
                            var i, selection;
                            if (rows && rows.length) {
                                rowCount = rows.length;
                                selection = that.getDesignValue('selection');
                                for (i = 0; i < rows.length; i += 1) {
                                    rowSelection(selection, rows[i]);
                                }
                            }
                        });
                    }
                    spec.question.html('<li></li>');
                    spec.question.find('li').html(that.applyTemplate('tableTemplate') || '<table><tbody></tbody></table>');
                    table = spec.question.find('tbody');
                    table.empty();
                    processId = spec.question.attr('processDataId');
                    if (!processId) {
                        processId = that.getDesignValue('processDataId');
                    }
                    if (!processId) {
                        processId = that.getDesignValue('processId');
                    } else {
                        processId = mc.db.getValue(processId);
                    }
                    summaryNames = that.getDesignValue('summaryNames');
                    filterFormula = that.getDesignValue('filterformula');
                    if (filterFormula !== undefined) {
                        mc.fl.execFormula(filterFormula, getFilteredRows, getFilteredRows, true);
                    } else {
                        filter = that.getDesignValue('filter');
                        getFilteredRows(filter)
                    }
                }
                superLoad(callback);
            }
            alreadyOpened = false;
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            that.save = save;
            return that;
        }

        function subjectSelectorPopupQuestion(spec) {
            var superInitialize, that;

            function initialize() {
                superInitialize();
            }

            function load() { }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            that.load = load;
            return that;
        }

        function textInlineQuestion(spec) {
            var superInitialize, superLoad, that;

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        spec.question.find('input').val(value || '');
                    });
                }
                superLoad(callback);
            }

            function save() {
                if (that.ready()) {
                    that.setValue(spec.question.find('input').val());
                }
            }

            function initialize() {
                superInitialize();
                spec.question.find('input').bind('change', save);
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            that.save = save;
            return that;
        }

        function textPopupQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                superInitialize();
                bindEditText(that, 'editTextPage');
            }

            function load() {
                function callback() {
                    that.getValue(function(value) {
                        spec.question.find('h4').html(value || '');
                    });
                }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function timeInlineQuestion(spec) {
            var superInitialize, superLoad, that;

            function load() {
                function callback() {
                    var editor;
                    editor = spec.question.find('.jmuiCompositeTime');
                    that.getValue(function(v) {
                        if (v && v.constructor === Date) {
                            editor.text(mc.fl.format(v, 't'));
                        } else {
                            editor.html('&nbsp;');
                        }
                    });
                }
                superLoad(callback);
            }

            function save() {
                var editor, h, m, parts, v;
                if (that.ready()) {
                    v = null;
                    editor = spec.question.find('.jmuiCompositeTime');
                    parts = editor.html().split(':');
                    if (parts.length === 2) {
                        h = parseInt(parts[0], 10);
                        m = parseInt(parts[1], 10);
                        if (h >= 0 && h < 24 && m >= 0 && m < 60) {
                            v = new Date();
                            v.setHours(h);
                            v.setMinutes(m);
                            v.setSeconds(0);
                            v.setMilliseconds(0);
                        }
                    }
                    that.setValue(v);
                }
            }

            function initialize() {
                superInitialize();
                spec.question.find('.jmuiCompositeTime').bind('change', save);
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            that.save = save;
            return that;
        }

        function timePopupQuestion(spec) {
            var superInitialize, superLoad, that;

            function initialize() {
                superInitialize();
                bindEditTime(that);
            }

            function load() {
                function callback() {
                    var t;
                    t = spec.question.find('h4');
                    that.getValue(function(v) {
                        if (v && v.constructor === Date) {
                            t.text(v.toString(Date.CultureInfo.formatPatterns.shortTime));
                        } else {
                            t.html('');
                        }
                    });
                }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }

        function toggleInlineQuestion(spec) {
            var superInitialize, superLoad, that;

            function load() {
                function callback() {			
                    that.getValue(function(value) {		
					    function setChecked(checkbox, checked) {
						    if (checkbox.checked !== checked) {
							    checkbox.checked = checked;
								$(checkbox).trigger('change');
						    }
					    }			
                        if (Object.prototype.toString.call(value) === '[object Array]' && value.length !== 0) {
                            spec.question.find('input').each(function() {
                                var checked, i, myValue;
                                checked = false;
                                myValue = this.value;
                                for (i = 0; i < value.length; i += 1) {
                                    if (value[i] === myValue) {
                                        checked = true;
                                        break;
                                    }
                                }
                                setChecked(this, checked);
                            });
                        } else {
                            spec.question.find('input').each(function() {
                                setChecked(this, false);
                            });
                        }
                    });
                }
                superLoad(callback);
            }

            function save() {
                /*
				
				AnS: 12-MAY-15: 				Unreachable code as of switchery implementation
				
                var value;
                if (that.ready()) {
                    value = [];
                    spec.question.find('input').each(function() {
                        if (this.checked) {
                            value.push(this.value);
                        }
                    });
                    that.setValue(value);
                }
				*/
            }

            function initialize() {
                function addChoices(choices) {
                    var html, i, n;
                    spec.question.empty();
                    html = '';
                    n = choices.length;
                    for (i = 0; i < n; i += 1) {
                        html += '<li><span class="jmuiToggleText">' + choices[i].label + '</span><span class="jmuiToggle"><input type="checkbox" value="' + choices[i].value + '" /></span></li>';
                    }
                    spec.question.html(html);
                    spec.question.find('input')
                        .bind('jmuiChange', save) // <--- this doesn't work with switchery
                        .each(function (index, element) {
                            var init = new Switchery(element, {size: 'small'});
				
							/*--- To cater for the broken save function - being able to set data to subject and also refresh hidden for a toggle check box */
							var dataid = jQuery(element).closest('ul').attr('dataid');
							var value = jQuery(element).val();
							
							jQuery(element).next("span").click(function(){
								if(jQuery(this).siblings('input').is(':checked')){
									mCapture.fl.setdata(dataid,value,index);
								}else{
									mCapture.fl.cleardata(dataid,index);
								}
								mCapture.fl.refreshhidden();
							});
							/*---*/
                        });
					
                    that.ready(true);
                }
                superInitialize();
                that.ready(false);
                that.getChoices(addChoices);
            }
            that = inlineQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            that.save = save;
            return that;
        }

        function togglePopupQuestion(spec) {
            var choices, superInitialize, superLoad, that;

            function initialize() {
                function addChoices(a) {
                    choices = a;
                    bindEditToggle(that, choices);
                    that.ready(true);
                }
                superInitialize();
                that.ready(false);
                that.getChoices(addChoices);
            }

            function load() {
                function callback() {
                    var i, j, text;
                    that.getValue(function(value) {
                        if (value) {
                            text = [];
                            if (choices.length > 0) {
                                for (i = 0; i < value.length; i += 1) {
                                    for (j = 0; j < choices.length; j += 1) {
                                        if (value[i] === choices[j].value) {
                                            text.push(choices[j].label);
                                            break;
                                        }
                                    }
                                }
                                text = text.join(', ');
                            } else {
                                text = '';
                            }
                            spec.question.find('h4').html(text);
                        } else {
                            spec.question.find('h4').html('');
                        }
                    });
                }
                superLoad(callback);
            }
            that = popupQuestion(spec);
            superInitialize = that.initialize;
            that.initialize = initialize;
            superLoad = that.load;
            that.load = load;
            return that;
        }
        questionMaker = function(pg, q) {
            var cached, qid, spec, that;
            if (!pg || !q) {
                return;
            }
            qid = idFromObject(q);
            cached = questions[qid];
            if (cached !== undefined) {
                return cached;
            }
            spec = {};
            spec.page = objectFromId(pg);
            spec.question = objectFromId(q);
            switch (questionType(spec.question)) {
                case qType.actionListInline:
                    that = actionListInlineQuestion(spec);
                    break;
                case qType.actionListPopup:
                    that = actionListPopupQuestion(spec);
                    break;
                case qType.audioInline:
                    that = audioInlineQuestion(spec);
                    break;
                case qType.audioPopup:
                    that = audioPopupQuestion(spec);
                    break;
                case qType.barcodeInline:
                    that = barcodeInlineQuestion(spec);
                    break;
                case qType.barcodePopup:
                    that = barcodePopupQuestion(spec);
                    break;
                case qType.checkboxInline:
                    that = checkboxInlineQuestion(spec);
                    break;
                case qType.checkboxPopup:
                    that = checkboxPopupQuestion(spec);
                    break;
                case qType.comboInline:
                    that = comboInlineQuestion(spec);
                    break;
                case qType.comboPopup:
                    that = comboPopupQuestion(spec);
                    break;
                case qType.compoundInline:
                    that = compoundInlineQuestion(spec);
                    break;
                case qType.compoundPopup:
                    that = compoundPopupQuestion(spec);
                    break;
                case qType.dateInline:
                    that = dateInlineQuestion(spec);
                    break;
                case qType.datePopup:
                    that = datePopupQuestion(spec);
                    break;
                case qType.filteredListInline:
                    that = filteredListInlineQuestion(spec);
                    break;
                case qType.filteredListPopup:
                    that = filteredListPopupQuestion(spec);
                    break;
                case qType.gridInline:
                    that = gridInlineQuestion(spec);
                    break;
                case qType.gridPopup:
                    that = gridPopupQuestion(spec);
                    break;
                case qType.imageInline:
                    that = imageInlineQuestion(spec);
                    break;
                case qType.imagePopup:
                    that = imagePopupQuestion(spec);
                    break;
                case qType.imageMapInline:
                    that = imageMapInlineQuestion(spec);
                    break;
                case qType.imageMapPopup:
                    that = imageMapPopupQuestion(spec);
                    break;
                case qType.labelInline:
                    that = labelInlineQuestion(spec);
                    break;
                case qType.labelPopup:
                    that = labelPopupQuestion(spec);
                    break;
                case qType.listInline:
                    that = listInlineQuestion(spec);
                    break;
                case qType.listPopup:
                    that = listPopupQuestion(spec);
                    break;
                case qType.locationInline:
                    that = locationInlineQuestion(spec);
                    break;
                case qType.mapInline:
                    that = mapInlineQuestion(spec);
                    break;
                case qType.mapPopup:
                    //that = mapPopupQuestion(spec);
                    break;
                case qType.notesInline:
                    that = notesInlineQuestion(spec);
                    break;
                case qType.notesPopup:
                    that = notesPopupQuestion(spec);
                    break;
                case qType.numberInline:
                    that = numberInlineQuestion(spec);
                    break;
                case qType.numberPopup:
                    that = numberPopupQuestion(spec);
                    break;
                case qType.numberRangeInline:
                    that = numberRangeInlineQuestion(spec);
                    break;
                case qType.numberRangePopup:
                    that = numberRangePopupQuestion(spec);
                    break;
                case qType.passwordInline:
                    that = passwordInlineQuestion(spec);
                    break;
                case qType.passwordPopup:
                    that = passwordPopupQuestion(spec);
                    break;
                case qType.photoInline:
                    that = photoInlineQuestion(spec);
                    break;
                case qType.photoPopup:
                    that = photoPopupQuestion(spec);
                    break;
                case qType.processSelectorInline:
                    that = processSelectorInlineQuestion(spec);
                    break;
                case qType.processSelectorPopup:
                    that = processSelectorPopupQuestion(spec);
                    break;
                case qType.radioInline:
                    that = radioInlineQuestion(spec);
                    break;
                case qType.radioPopup:
                    that = radioPopupQuestion(spec);
                    break;
                case qType.selectionInline:
                    that = selectionInlineQuestion(spec);
                    break;
                case qType.selectionPopup:
                    that = selectionPopupQuestion(spec);
                    break;
                case qType.signatureInline:
                    that = signatureInlineQuestion(spec);
                    break;
                case qType.sketchInline:
                    that = sketchInlineQuestion(spec);
                    break;
                case qType.sketchPopup:
                    that = sketchPopupQuestion(spec);
                    break;
                case qType.subjectSelectorInline:
                    that = subjectSelectorInlineQuestion(spec);
                    break;
                case qType.subjectSelectorPopup:
                    that = subjectSelectorPopupQuestion(spec);
                    break;
                case qType.textInline:
                    that = textInlineQuestion(spec);
                    break;
                case qType.textPopup:
                    that = textPopupQuestion(spec);
                    break;
                case qType.timeInline:
                    that = timeInlineQuestion(spec);
                    break;
                case qType.timePopup:
                    that = timePopupQuestion(spec);
                    break;
                case qType.toggleInline:
                    that = toggleInlineQuestion(spec);
                    break;
                case qType.togglePopup:
                    that = togglePopupQuestion(spec);
                    break;
            }
            questions[qid] = that;
            return that;
        };
        questions = [];
        alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
        if ($.isTouch) {
            isTouchable = (new RegExp("iPhone", "i")).test(navigator.userAgent);
            if (isTouchable === true) {
                // iPhone
                isPageOffsetAware = (new RegExp("iPhone OS 4", "i")).test(navigator.userAgent);
            } else {
                isTouchable = (new RegExp("iPad", "i")).test(navigator.userAgent);
                if (isTouchable === true) {
                    // iPad
                    isPageOffsetAware = true;
                } else {
                    isTouchable = (new RegExp("Android", "i")).test(navigator.userAgent);
                    isPageOffsetAware = false;
                }
            }
        }
        qType = {
            actionListInline: 'actionListInline',
            actionListPopup: 'actionListPopup',
            audioInline: 'audioInline',
            audioPopup: 'audioPopup',
            barcodeInline: 'barcodeInline',
            barcodePopup: 'barcodePopup',
            checkboxInline: 'checkboxInline',
            checkboxPopup: 'checkboxPopup',
            comboInline: 'comboInline',
            comboPopup: 'comboPopup',
            compoundInline: 'compoundInline',
            compoundPopup: 'compoundPopup',
            dateInline: 'dateInline',
            datePopup: 'datePopup',
            filteredListInline: 'filteredListInline',
            filteredListPopup: 'filteredListPopup',
            gridInline: 'gridInline',
            gridPopup: 'gridPopup',
            imageInline: 'imageInline',
            imagePopup: 'imagePopup',
            imageMapInline: 'imageMapInline',
            imageMapPopup: 'imageMapPopup',
            labelInline: 'labelInline',
            labelPopup: 'labelPopup',
            listInline: 'listInline',
            listPopup: 'listPopup',
            locationInline: 'locationInline',
            mapInline: 'mapInline',
            mapPopup: 'mapPopup',
            notesInline: 'notesInline',
            notesPopup: 'notesPopup',
            numberInline: 'numberInline',
            numberPopup: 'numberPopup',
            numberRangeInline: 'numberRangeInline',
            numberRangePopup: 'numberRangePopup',
            passwordInline: 'passwordInline',
            passwordPopup: 'passwordPopup',
            photoInline: 'photoInline',
            photoPopup: 'photoPopup',
            processSelectorInline: 'processSelectorInline',
            processSelectorPopup: 'processSelectorPopup',
            radioInline: 'radioInline',
            radioPopup: 'radioPopup',
            selectionInline: 'selectionInline',
            selectionPopup: 'selectionPopup',
            signatureInline: 'signatureInline',
            sketchInline: 'sketchInline',
            sketchPopup: 'sketchPopup',
            subjectSelectorInline: 'subjectSelectorInline',
            subjectSelectorPopup: 'subectSelectorPopup',
            textInline: 'textInline',
            textPopup: 'textPopup',
            timeInline: 'timeInline',
            timePopup: 'timePopup',
            toggleInline: 'toggleInline',
            togglePopup: 'togglePopup'
        };
        mc.q = questionMaker;
        mc.q.designData = designData;
        mc.q.ready = ready;
        mc.q.refresh = function(pageId, questionId, callback) {
            var q;
            q = mc.q(pageId, questionId);
            if (q) {
                q.refresh(callback);
            }
        };
        mc.q.show = function(id) {
            showQuestion(id, true);
        };
        mc.q.hide = function(id) {
            showQuestion(id, false);
        };
        mc.q.isHidden = isQuestionHidden;
        mc.q.enable = function(pageId, questionId) {
            var q;
            q = mc.q(pageId, questionId);
            if (q) {
                q.enable(true);
            }
        };
        mc.q.disable = function(pageId, questionId) {
            var q;
            q = mc.q(pageId, questionId);
            if (q) {
                q.enable(false);
            }
        };
        passwordMask = '&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;';
        if ($.isIE || $.isBlackberry) {
            popupPages = {
                editActionListPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Info</h1><div class="jmuiBackButton">Back</div></div></div><div class="jmuiNativeScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul></ul></div></div></div></div>',
                editBarcodePage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiNativeScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><div class="jmuiPlaceholder"></div><div class="jmuiScanresult"></div></li></ul></div></div></div></div>',
                editCheckboxPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiNativeScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul></ul></div></div></div>',
                editComboPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiNativeScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><div class="jmuiCompositeArrow"></div><div class="jmuiCompositeInput"><select style="display:none"></select><input type="text" value="" /></div><div class="jmuiMask"></div></li></ul></div></div></div>',
                editCompoundPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiBackButton">Back</div></div></div><div class="jmuiNativeScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul></ul></div></div></div>',
                editDatePage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiNativeScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><div class="jmuiCompositeClear"></div><div class="jmuiCompositeDate">&nbsp;</div></li></ul></div></div></div>',
                editGridPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Info</h1><div class="jmuiBackButton">Back</div></div></div><div class="jmuiNativeScroller"><div><ul></ul></div></div></div></div>',
                editImagePage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Info</h1><div class="jmuiBackButton">Back</div></div></div><div class="jmuiNativeScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><img width="100%"></li></ul></div></div></div></div>',
                editImageMapPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiActionButton">Done</div></div></div><div class="jmuiNativeScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><div style="position:relative"><img width="100%"></div></li></ul></div></div></div></div>',
                editListPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiActionButton">Done</div></div></div><div class="jmuiNativeScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul></ul></div></div></div></div>',
                editNotesPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiNativeScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><textarea style="height:8em;"></textarea><div class="jmuiMask"></div></li></ul></div></div></div></div>',
                editNumberPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiNativeScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><input type="text" value="" pattern="[0-9]*"/><div class="jmuiMask"></div></li></ul></div></div></div></div>',
                editNumberRangePage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiNativeScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><div class="jmuiCompositeClear"></div><div class="jmuiCompositeNumber">&nbsp;</div></li></ul></div></div></div>',
                editPasswordPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiNativeScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><input type="password" value=""/><div class="jmuiMask"></div></li></ul></div></div></div></div>',
                editRadioPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiNativeScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul></ul></div></div></div>',
                editPhotoPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiNativeScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><img alt="add photo"/></li></ul></div></div></div></div>',
                editSketchPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiNativeScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li class="jmuiColorPress"><div class="jsig"></div></li></ul></div></div></div>',
                editTextPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiNativeScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><input type="text" value=""/><div class="jmuiMask"></div></li></ul></div></div></div></div>',
                editTimePage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiNativeScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><div class="jmuiCompositeClear"></div><div class="jmuiCompositeTime">&nbsp;</div></li></ul></div></div></div>',
                editTogglePage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiNativeScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul></ul></div></div></div>'
            };
        } else {
            popupPages = {
                editActionListPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Info</h1><div class="jmuiBackButton">Back</div></div></div><div class="jmuiScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul></ul></div></div></div></div>',
                editBarcodePage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><div class="jmuiPlaceholder"></div><div class="jmuiScanresult"></div></li></ul></div></div></div></div>',
                editCheckboxPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul></ul></div></div></div>',
                editComboPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><div class="jmuiCompositeArrow"></div><div class="jmuiCompositeInput"><select style="display:none"></select><input type="text" value="" /></div><div class="jmuiMask"></div></li></ul></div></div></div>',
                editCompoundPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiBackButton">Back</div></div></div><div class="jmuiScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul></ul></div></div></div>',
                editDatePage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><div class="jmuiCompositeClear"></div><div class="jmuiCompositeDate">&nbsp;</div></li></ul></div></div></div>',
                editGridPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Info</h1><div class="jmuiBackButton">Back</div></div></div><div class="jmuiScroller"><div><ul></ul></div></div></div></div>',
                editImagePage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Info</h1><div class="jmuiBackButton">Back</div></div></div><div class="jmuiScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><img width="100%"></li></ul></div></div></div></div>',
                editImageMapPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiActionButton">Done</div></div></div><div class="jmuiScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><div style="position:relative"><img width="100%"></div></li></ul></div></div></div></div>',
                editListPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiActionButton">Done</div></div></div><div class="jmuiScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul></ul></div></div></div></div>',
                editNotesPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><textarea style="height:8em;"></textarea><div class="jmuiMask"></div></li></ul></div></div></div></div>',
                editNumberPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><input type="text" value="" pattern="[0-9]*"/><div class="jmuiMask"></div></li></ul></div></div></div></div>',
                editNumberRangePage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><div class="jmuiCompositeClear"></div><div class="jmuiCompositeNumber">&nbsp;</div></li></ul></div></div></div>',
                editPasswordPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><input type="password" value=""/><div class="jmuiMask"></div></li></ul></div></div></div></div>',
                editRadioPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul></ul></div></div></div>',
                editPhotoPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><img alt="add photo"/></li></ul></div></div></div></div>',
                editSketchPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li class="jmuiColorPress"><div class="jsig"></div></li></ul></div></div></div>',
                editTextPage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><input type="text" value=""/><div class="jmuiMask"></div></li></ul></div></div></div></div>',
                editTimePage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul><li><div class="jmuiCompositeClear"></div><div class="jmuiCompositeTime">&nbsp;</div></li></ul></div></div></div>',
                editTogglePage: '<div class="jmuiHeader"><div class="jmuiToolbar"><h1>Edit</h1><div class="jmuiCancelButton">Cancel</div><div class="jmuiActionButton">Save</div></div></div><div class="jmuiScroller"><div><div class="md_popupQuestionContainer"><h2></h2><ul></ul></div></div></div>'
            };
        }
    } (window.jmfw, window.Q, window.mCapture));
/*
** END OF MC.QUESTION.JS
*/
/*jslint browser: true, devel: true, bitwise: true, continue: true, evil: true, eqeq: true, forin: true, nomen: true, plusplus: true, regexp: true, sloppy: true, white: true */
// The argument 'generated' is the generated state machine function.
function make_formula(generated_) {
	var impl, that;
	impl = {
        ExecState : {
            EXEC_CONTINUE: 1,
            EXEC_ASYNC: 2,
            EXECE_DONE: 3
        },
        // This object holds local variables for the function        
        locals : { },
        state : 1,
		is_done: false,
		invalid: function(where) {
			if (this.is_done) {
				var msg = "called " + where + " after done";
				alert(msg);
				throw (msg);
			}
			return this.is_done;
		},
		onsuccess: null,
		// callback once formula execution is complete	
		onfailure: null,
		// callback if formula execution fails
        closure : undefined,
        // Methods for getting and setting 'local' variables
        getvar : function(name) {
            return this.locals[name];
        },
        setvar: function(name, val) {
            this.locals[name]=val;
        },
        // Invoke an asynchronous call
        // There async functions are invoke, the state in which we resume is always the next one numerically
        async : function() {
            return this.ExecState.EXEC_ASYNC;
        },
        go_to : function(new_state) {
			if (!this.invalid("go_to")) {
				this.state = new_state;
				return this.ExecState.EXEC_CONTINUE;
			}
        },
        // Execute the state machine (in a loop)
        exec : function(result) {
            var r = this.ExecState.EXEC_CONTINUE;
            try {
                while(r === this.ExecState.EXEC_CONTINUE) {
	       	       r = this.generated(result);
                }
                switch(r) {
                    case this.ExecState.EXEC_ASYNC:
                        break;
                    case this.ExecState.EXEC_DONE:
                        break;
                    default:
                        break;
                }
            } catch(e) {
                alert("Exception name: " + e.name + ". Error message: " + e.message);
                this.onfailure( e );
            }
        },
        // Initial execution of formula
        execute : function(success,failure) {
            var i;
            this.onsuccess = success;
            this.onfailure = failure;
            for (i = 2; i < arguments.length; i += 1) {
                this.setvar('_arg' + (i - 1), arguments[i]);
            }
            this.exec( );
        },
        // Invoke completion callback
        done : function(result) {
			if (!this.invalid("done")) {
				this.is_done = true;
				this.onsuccess(result);
				return this.ExecState.EXEC_DONE;
			}
        },
        // Resumption
        resume : function(result) {
			if (!this.invalid("resume")) {
				this.exec(result);
			}
        }
    };
    impl.generated = generated_;
	// Return the new object
	that = {
        // Initial call to invoke execution of the formula
        // onsuccess and failure are callbacks
		execute: function() { // success, failure
            impl.execute.apply(impl, arguments);   
            //impl.execute(success,failure);
        },
    	// Called by function library once we have results
        resume : function(result) {
            impl.resume(result);
        }
	};
	impl.closure = that;
	return that;
}
// Copyright (c) 2002-2004, Ross Smith.  All rights reserved.
// Licensed under the BSD or LGPL License. See license.txt for details.
var _bin2hex = [
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
];

var _hex2bin = [
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, // 0-9
     0,10,11,12,13,14,15, 0, 0, 0, 0, 0, 0, 0, 0, 0, // A-F
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0,10,11,12,13,14,15, 0, 0, 0, 0, 0, 0, 0, 0, 0, // a-f
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
];

function bin2hex(str) {
    var len = str.length;
    var rv = '';
    var i = 0;
    var c;
    
    while (len-- > 0) {
        c = str.charCodeAt(i++);

        rv += _bin2hex[(c & 0xf0) >> 4];
        rv += _bin2hex[(c & 0x0f)];
    }

    return rv;
}

function hex2bin(str) {
    var len = str.length;
    var rv = '';
    var i = 0;

    var c1;
    var c2;

    while (len > 1) {
        h1 = str.charAt(i++);
        c1 = h1.charCodeAt(0);
        h2 = str.charAt(i++);
        c2 = h2.charCodeAt(0);
        
        rv += String.fromCharCode((_hex2bin[c1] << 4) + _hex2bin[c2]);
        len -= 2;
    }

    return rv;
}

// ----------------------------------------------------------------------------------------

//+ Jonas Raoni Soares Silva
//@ http://jsfromhell.com/classes/binary-parser [rev. #1]

BinaryParser = function(bigEndian, allowExceptions){
	this.bigEndian = bigEndian, this.allowExceptions = allowExceptions;
};
with({p: BinaryParser.prototype}){
	p.encodeFloat = function(number, precisionBits, exponentBits){
		var bias = Math.pow(2, exponentBits - 1) - 1, minExp = -bias + 1, maxExp = bias, minUnnormExp = minExp - precisionBits,
		status = isNaN(n = parseFloat(number)) || n == -Infinity || n == +Infinity ? n : 0,
		exp = 0, len = 2 * bias + 1 + precisionBits + 3, bin = new Array(len),
		signal = (n = status !== 0 ? 0 : n) < 0, n = Math.abs(n), intPart = Math.floor(n), floatPart = n - intPart,
		i, lastBit, rounded, j, result;
		for(i = len; i; bin[--i] = 0);
		for(i = bias + 2; intPart && i; bin[--i] = intPart % 2, intPart = Math.floor(intPart / 2));
		for(i = bias + 1; floatPart > 0 && i; (bin[++i] = ((floatPart *= 2) >= 1) - 0) && --floatPart);
		for(i = -1; ++i < len && !bin[i];);
		if(bin[(lastBit = precisionBits - 1 + (i = (exp = bias + 1 - i) >= minExp && exp <= maxExp ? i + 1 : bias + 1 - (exp = minExp - 1))) + 1]){
			if(!(rounded = bin[lastBit]))
				for(j = lastBit + 2; !rounded && j < len; rounded = bin[j++]);
			for(j = lastBit + 1; rounded && --j >= 0; (bin[j] = !bin[j] - 0) && (rounded = 0));
		}
		for(i = i - 2 < 0 ? -1 : i - 3; ++i < len && !bin[i];);

		(exp = bias + 1 - i) >= minExp && exp <= maxExp ? ++i : exp < minExp &&
			(exp != bias + 1 - len && exp < minUnnormExp && this.warn("encodeFloat::float underflow"), i = bias + 1 - (exp = minExp - 1));
		(intPart || status !== 0) && (this.warn(intPart ? "encodeFloat::float overflow" : "encodeFloat::" + status),
			exp = maxExp + 1, i = bias + 2, status == -Infinity ? signal = 1 : isNaN(status) && (bin[i] = 1));
		for(n = Math.abs(exp + bias), j = exponentBits + 1, result = ""; --j; result = (n % 2) + result, n = n >>= 1);
		for(n = 0, j = 0, i = (result = (signal ? "1" : "0") + result + bin.slice(i, i + precisionBits).join("")).length, r = [];
			i; n += (1 << j) * result.charAt(--i), j == 7 && (r[r.length] = String.fromCharCode(n), n = 0), j = (j + 1) % 8);
		r[r.length] = n ? String.fromCharCode(n) : "";
		return (this.bigEndian ? r.reverse() : r).join("");
	};
	p.encodeInt = function(number, bits, signed){
		var max = Math.pow(2, bits), r = [];
		(number >= max || number < -(max >> 1)) && this.warn("encodeInt::overflow") && (number = 0);
		number < 0 && (number += max);
		for(; number; r[r.length] = String.fromCharCode(number % 256), number = Math.floor(number / 256));
		for(bits = -(-bits >> 3) - r.length; bits--; r[r.length] = "\0");
		return (this.bigEndian ? r.reverse() : r).join("");
	};
	p.decodeFloat = function(data, precisionBits, exponentBits){
		var b = ((b = new this.Buffer(this.bigEndian, data)).checkBuffer(precisionBits + exponentBits + 1), b),
			bias = Math.pow(2, exponentBits - 1) - 1, signal = b.readBits(precisionBits + exponentBits, 1),
			exponent = b.readBits(precisionBits, exponentBits), significand = 0,
			divisor = 2, curByte = b.buffer.length + (-precisionBits >> 3) - 1,
			byteValue, startBit, mask;
		do
			for(byteValue = b.buffer[ ++curByte ], startBit = precisionBits % 8 || 8, mask = 1 << startBit;
				mask >>= 1; (byteValue & mask) && (significand += 1 / divisor), divisor *= 2);
		while(precisionBits -= startBit);
		return exponent == (bias << 1) + 1 ? significand ? NaN : signal ? -Infinity : +Infinity
			: (1 + signal * -2) * (exponent || significand ? !exponent ? Math.pow(2, -bias + 1) * significand
			: Math.pow(2, exponent - bias) * (1 + significand) : 0);
	};
	p.decodeInt = function(data, bits, signed){
		var b = new this.Buffer(this.bigEndian, data), x = b.readBits(0, bits), max = Math.pow(2, bits);
		return signed && x >= max / 2 ? x - max : x;
	};
	with({p: (p.Buffer = function(bigEndian, buffer){
		this.bigEndian = bigEndian || 0, this.buffer = [], this.setBuffer(buffer);
	}).prototype}){
		p.readBits = function(start, length){
			//shl fix: Henri Torgemane ~1996 (compressed by Jonas Raoni)
			function shl(a, b){
				for(++b; --b; a = ((a %= 0x7fffffff + 1) & 0x40000000) == 0x40000000 ? a * 2 : (a - 0x40000000) * 2 + 0x7fffffff + 1);
				return a;
			}
			if(start < 0 || length <= 0)
				return 0;
			this.checkBuffer(start + length);
			for(var offsetLeft, offsetRight = start % 8, curByte = this.buffer.length - (start >> 3) - 1,
				lastByte = this.buffer.length + (-(start + length) >> 3), diff = curByte - lastByte,
				sum = ((this.buffer[ curByte ] >> offsetRight) & ((1 << (diff ? 8 - offsetRight : length)) - 1))
				+ (diff && (offsetLeft = (start + length) % 8) ? (this.buffer[ lastByte++ ] & ((1 << offsetLeft) - 1))
				<< (diff-- << 3) - offsetRight : 0); diff; sum += shl(this.buffer[ lastByte++ ], (diff-- << 3) - offsetRight)
			);
			return sum;
		};
		p.setBuffer = function(data){
			if(data){
				for(var l, i = l = data.length, b = this.buffer = new Array(l); i; b[l - i] = data.charCodeAt(--i));
				this.bigEndian && b.reverse();
			}
		};
		p.hasNeededBits = function(neededBits){
			return this.buffer.length >= -(-neededBits >> 3);
		};
		p.checkBuffer = function(neededBits){
			if(!this.hasNeededBits(neededBits))
				throw new Error("checkBuffer::missing bytes");
		};
	}
	p.warn = function(msg){
		if(this.allowExceptions)
			throw new Error(msg);
		return 1;
	};
	p.toSmall = function(data){return this.decodeInt(data, 8, true);};
	p.fromSmall = function(number){return this.encodeInt(number, 8, true);};
	p.toByte = function(data){return this.decodeInt(data, 8, false);};
	p.fromByte = function(number){return this.encodeInt(number, 8, false);};
	p.toShort = function(data){return this.decodeInt(data, 16, true);};
	p.fromShort = function(number){return this.encodeInt(number, 16, true);};
	p.toWord = function(data){return this.decodeInt(data, 16, false);};
	p.fromWord = function(number){return this.encodeInt(number, 16, false);};
	p.toInt = function(data){return this.decodeInt(data, 32, true);};
	p.fromInt = function(number){return this.encodeInt(number, 32, true);};
	p.toDWord = function(data){return this.decodeInt(data, 32, false);};
	p.fromDWord = function(number){return this.encodeInt(number, 32, false);};
	p.toFloat = function(data){return this.decodeFloat(data, 23, 8);};
	p.fromFloat = function(number){return this.encodeFloat(number, 23, 8);};
	p.toDouble = function(data){return this.decodeFloat(data, 52, 11);};
	p.fromDouble = function(number){return this.encodeFloat(number, 52, 11);};
}

// -----------------------------------------------------------------------------------------------

function encode_utf8( s ) {
  return unescape( encodeURIComponent( s ) );
}

function decode_utf8( s ) {
  return decodeURIComponent( escape( s ) );
}

// -----------------------------------------------------------------------------------------------

function encode_base64( what ) {
	var base64_encodetable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	var result = "";
	var len = what.length;
	var x, y;
	var ptr = 0;

	while( len-- > 0 ) {
		x = what.charCodeAt( ptr++ ) & 0xff;
		result += base64_encodetable.charAt( ( x >> 2 ) & 63 );

		if( len-- <= 0 ) {
			result += base64_encodetable.charAt( ( x << 4 ) & 63 );
			result += "==";
			break;
		}

		y = what.charCodeAt( ptr++ ) & 0xff;
		result += base64_encodetable.charAt( ( ( x << 4 ) | ( ( y >> 4 ) & 15 ) ) & 63 );

		if ( len-- <= 0 ) {
			result += base64_encodetable.charAt( ( y << 2 ) & 63 );
			result += "=";
			break;
		}

		x = what.charCodeAt( ptr++ ) & 0xff;
		result += base64_encodetable.charAt( ( ( y << 2 ) | ( ( x >> 6 ) & 3 ) ) & 63 );
		result += base64_encodetable.charAt( x & 63 );

	}

	return result;
}

function encode_base64_arr( what ) {
	var base64_encodetable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	var result = "";
	var len = what.length;
	var x, y;
	var ptr = 0;

	while( len-- > 0 ) {
		x = what[ ptr++ ];
		result += base64_encodetable.charAt( ( x >> 2 ) & 63 );

		if( len-- <= 0 ) {
			result += base64_encodetable.charAt( ( x << 4 ) & 63 );
			result += "==";
			break;
		}

		y = what[ ptr++ ];
		result += base64_encodetable.charAt( ( ( x << 4 ) | ( ( y >> 4 ) & 15 ) ) & 63 );

		if ( len-- <= 0 ) {
			result += base64_encodetable.charAt( ( y << 2 ) & 63 );
			result += "=";
			break;
		}

		x = what[ ptr++ ];
		result += base64_encodetable.charAt( ( ( y << 2 ) | ( ( x >> 6 ) & 3 ) ) & 63 );
		result += base64_encodetable.charAt( x & 63 );

	}

	return result;
}

function decode_base64( what ) {
	var base64_decodetable = new Array (
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,  62, 255, 255, 255,  63,
		 52,  53,  54,  55,  56,  57,  58,  59,  60,  61, 255, 255, 255, 255, 255, 255,
		255,   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,
		 15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25, 255, 255, 255, 255, 255,
		255,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,
		 41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51, 255, 255, 255, 255, 255
	);
	var result = "";
	var len = what.length;
	var x, y;
	var ptr = 0;

	while( !isNaN( x = what.charCodeAt( ptr++ ) ) ) {
		if( x == 13 || x == 10 )
			continue;

		if( ( x > 127 ) || (( x = base64_decodetable[x] ) == 255) )
			return false;
		if( ( isNaN( y = what.charCodeAt( ptr++ ) ) ) || (( y = base64_decodetable[y] ) == 255) )
			return false;

		result += String.fromCharCode( (x << 2) | (y >> 4) );

		if( (x = what.charCodeAt( ptr++ )) == 61 )
		{
			if( (what.charCodeAt( ptr++ ) != 61) || (!isNaN(what.charCodeAt( ptr ) ) ) )
				return false;
		}
		else
		{
			if( ( x > 127 ) || (( x = base64_decodetable[x] ) == 255) )
				return false;
			result += String.fromCharCode( (y << 4) | (x >> 2) );
			if( (y = what.charCodeAt( ptr++ )) == 61 )
			{
				if( !isNaN(what.charCodeAt( ptr ) ) )
					return false;
			}
			else
			{
				if( (y > 127) || ((y = base64_decodetable[y]) == 255) )
					return false;
				result += String.fromCharCode( (x << 6) | y );
			}
		}
	}
	return result;
}

function wrap76( what ) {
	var result = "";
	var i;

	for(i=0; i < what.length; i+=76) {
		result += what.substring(i, i+76) + String.fromCharCode(13) + String.fromCharCode(10);
	}
	return result;
}

// -----------------------------------------------------------------------------------------------

function dec2hex(n) {
    n = parseInt(n); var c = 'ABCDEF';
    var b = n / 16; var r = n % 16; b = b-(r/16); 
    b = ((b>=0) && (b<=9)) ? b : c.charAt(b-10);    
    return ((r>=0) && (r<=9)) ? b+''+r : b+''+c.charAt(r-10);
}

function hex2dec(hexchar) {
    return hexchars.indexOf(hexchar.toUpperCase());
}

// -----------------------------------------------------------------------------------------------

//jQuery.fn.delay = function(time,func) {
//    this.each(function(){
//        setTimeout(func,time);
//    });
//
//    return this;
//};

// -----------------------------------------------------------------------------------------------

function fromInteger(num) {
    return encodeInt(num, 32, false);
}

function encodeInt(number, bits, signed) {
    var bigEndian = true;
    
    var max = Math.pow(2, bits), r = [];
    (number >= max || number < -(max >> 1)) && this.warn("encodeInt::overflow") && (number = 0);
    number < 0 && (number += max);
    for(; number; r[r.length] = String.fromCharCode(number % 256), number = Math.floor(number / 256));
    for(bits = -(-bits >> 3) - r.length; bits--; r[r.length] = "\0");
    return (bigEndian ? r.reverse() : r).join("");
};

// ------------------------------------------------------------------------------------------------

function parseIsoDate(s) {
    return Date.parseExact(s, "yyyy-MM-dd HH:mm:ssZ");
}

function parseIsoDateOld(s) {
    var re=/(\d\d\d\d)\D?(\d\d)\D?(\d\d)\D?(\d\d)\D?(\d\d\D?(\d\d\.?(\d*))?)(Z|[+-]\d\d?(:\d\d)?)?/;
    var a=re(s).slice(1).map(function(x,i)
    {
        if (i==6 && x) x=parseInt(x,10)/Math.pow(10,x.length)*1000; // convert to milliseconds
            return parseInt(x,10)||0;
    });
    
    return new Date(Date.UTC(a[0],a[1]-1,a[2],a[3]-(a[7]||0),a[4],a[5],a[6]));
};

function isJSONDate(str) {
          //    YYYY - MM    - DD    [T ]  HH   : mm    : ss   [:] .[m...]Z
    var a = /^(\d{4})-(\d{2})-(\d{2})[T\s](\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(str);    
    return a;        
}

function makeDateFromJSONString(str) {
    var a = /^(\d{4})-(\d{2})-(\d{2})[T\s](\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(str);
    if (a) 
    {
        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4], +a[5], +a[6]));
    }
}

// ------------------------

function removeBOM( xml_str ) {
    var bom0 = xml_str.charCodeAt(0);       // 63471 = F7EF
    var bom1 = xml_str.charCodeAt(1);       // 63419 = F7BB        
    var bom2 = xml_str.charCodeAt(2);       // 63423 = F7BF

    // remove the byte order mark if its there
    if( (bom0 == 63471 && bom1 == 63419 && bom2 == 63423) ||
        (bom0 == 239 && bom1 == 187 && bom2 == 191) )     
    {
        xml_str = xml_str.substr(3);
    }
    
    return xml_str;
}    

// -----------------------

function getUrlVars() {
    return window.locationUtils.getURI().query(true);
}

// ------------------------

// The data from the server is in UTF8, the binary string in javascript seems to contain F7s
function removeF7s(data) {
    var str = "";
    for (var i = 0; i < data.length; i += 1) {
        var c = data.charCodeAt(i);
        if (c > 63232) {
            c = c - 63232; // F7
        }
        str += String.fromCharCode(c);
    }
    return str;
}/*jslint browser: true, devel: true, bitwise: true, continue: true, evil: true, eqeq: true, forin: true, nomen: true, plusplus: true, regexp: true, sloppy: true, white: true */
var CTBinaryReader, Protocol, ReplicationResult;

Protocol = {
	"EndSessionRequestTag": "00",
                    "GetNotificationRequestTag"  : "01", 
                    "KeepAliveRequestTag"        : "02", 
                    "LogMessageRequestTag"       : "03", 
                    "ReplicateRequestTag"        : "04", 
                    "RetrieveRequestTag"         : "05", 
                    "StartSessionRequestTag"     : "06", 
                    "FastLookupRequestTag"       : "07",
                    "EndSessionResponseTag" 	 : "10",
                    "GetNotificationResponseTag" : "11", 
                    "KeepAliveResponseTag"       : "12", 
                    "ReplicateResponseTag"       : "14", 
                    "RetrieveResponseTag"        : "15", 
                    "StartSessionResponseTag"    : "16", 
                    "FastLookupResponseTag"      : "17",
                    "AcknowledgementsTag"        : "20", 
                    "CommandsTag"                : "21", 
                    "SyncItemTag"                : "22", 
                    "SyncListTag"                : "23", 
                    "CreateItemTag"              : "30", 
                    "DeleteItemTag"              : "31", 
                    "ModifyItemTag"              : "32", 
                    "ItemCreatedTag"             : "40", 
                    "ItemDeletedTag"             : "41", 
                    "ItemModifiedTag"            : "42", 
                    "ApplicationIdTag"           : "50", 
                    "ContextTag"                 : "51", 
                    "ErrorTag"                   : "52", 
                    "ItemDataTag"                : "53", 
                    "ItemIdTag"                  : "54", 
                    "NotificationTag"            : "55", 
                    "SyncDataTag"                : "56", 
                    "UsernameTag"                : "57", 
                    "GetServerChangesTag"        : "60", 
                    "IsPartialTag"               : "61",
                    "MaxNumCommandsTag"          : "62",
                    "MoreAvailableTag" 	         : "63",
                    "ShouldContinueTag"          : "64"
};
ReplicationResult = {
	"Completed": 0,
		                    "Unknown"                   : 1,
		                    "Aborted"                   : 2,
		                    "EngineRequiredToRun"       : 3,		                    
		                    "GenricEngineFailure"       : 4,
		                    "EngineException"           : 5,		                    
		                    "NoPluginsRegistered"       : 6,
		                    "FailedToLoadPlugin"        : 7,
		                    "NoCommandsToProcess"       : 8,
		                    "ConnectionFailure"         : 9,
		                    "ConnectionLost"            : 10,
		                    "TimeoutWaitingForServer"   : 11,
		                    "UnknownNotificationCode"   : 12,		                    
		                    "FailedToStartSession"      : 13,
		                    "UserTimeout"               : 14,
		                    "FailedToLaunchEngine"      : 15,
				    "NotAuthenticated"          : 16
};		                       
CTBinaryReader = function(data) {
	this._buffer = data;
	this._pos = 0;
};
CTBinaryReader.prototype = {
    // Look at the next tag without consuming
	peekTag: function() {
		return window.dec2hex(this._peekUInt8());
	},
    // Read the next Tag and consume
	readTag: function() {
		return window.dec2hex(this._readUInt8());
	},
    // Read an Integer
	readInteger: function() {
		return this._readUInt32BE();
	},
    // read a Binary
    readBinary:     function() { 
                                    var length = this.readInteger();
                                    return this._readString(length);
                               },
    // read a UTF8 string
    readString:     function() {                                    
		var binary, string;
		binary = this.readBinary();
		string = window.decode_utf8(binary);
                                    return string;
                               },                                    
/* Private */
    seek: function (pos) {
		this._pos = pos;
		this._checkSize(0);
	},
	getPosition: function () {
		return this._pos;
	},
	getSize: function () {
		return this._buffer.length;
	},
	_readInt8: function() {
		return this._decodeInt(8, true);
	},
	_readUInt8: function() {
		return this._decodeInt(8, false);
	},
	_readInt16: function() {
		return this._decodeInt(16, true);
	},
	_readUInt16: function() {
		return this._decodeInt(16, false);
	},
	_readInt32: function() {
		return this._decodeInt(32, true);
	},
	_readUInt32: function() {
		return this._decodeInt(32, false);
	},
	_readFloat: function() {
		return this._decodeFloat(23, 8);
	},
	_readDouble: function() {
		return this._decodeFloat(52, 11);
	},
	_readChar: function() {
		return this._readString(1);
	},
	_readString: function (length) {
		if (length == 0) {
			return "";
		}
		this._checkSize(length * 8);
		var result = this._buffer.substr(this._pos, length);
		this._pos += length;
		return result;
	},
	_readUInt32BE: function() {
		var b0, b1, b2, b3, n;
		b0 = this._readUInt8();
		b1 = this._readUInt8();
		b2 = this._readUInt8();
		b3 = this._readUInt8();
	    n = b3 + (b2*256) + (b1*65536) + (b0*16777216);
        return n;
	},		
	_peekUInt8: function() {
	    var val = this._readUInt8();
	    this.seek( this.getPosition() - 1 );
	    return val;  
	},
	_decodeFloat: function(precisionBits, exponentBits){
		var bias, byteValue, curByte, divisor, exponent, length, mask, signal, significand, size, startBit;
		length = precisionBits + exponentBits + 1;
		size = length >> 3;
		this._checkSize(length);
		bias = Math.pow(2, exponentBits - 1) - 1;
		signal = this._readBits(precisionBits + exponentBits, 1, size);
		exponent = this._readBits(precisionBits, exponentBits, size);
		significand = 0;
		divisor = 2;
		curByte = length + (-precisionBits >> 3) - 1;
		do {
			byteValue = this._readByte(++curByte, size);
			startBit = precisionBits % 8 || 8;
			mask = 1 << startBit;
			while ((mask >>= 1) !== 0) {
				if (byteValue & mask) {
					significand += 1 / divisor;
				}
				divisor *= 2;
			}
		} while ((precisionBits -= startBit) !== 0);
		this._pos += size;
		return exponent == (bias << 1) + 1 ? significand ? NaN : signal ? -Infinity : +Infinity : (1 + signal * -2) * (exponent || significand ? !exponent ? Math.pow(2, -bias + 1) * significand : Math.pow(2, exponent - bias) * (1 + significand) : 0);
	},
	_decodeInt: function(bits, signed){
		var max, result, x;
		x = this._readBits(0, bits, bits / 8);
		max = Math.pow(2, bits);
		result = signed && x >= max / 2 ? x - max : x;
		this._pos += bits / 8;
		return result;
	},
	//shl fix: Henri Torgemane ~1996 (compressed by Jonas Raoni)
	_shl: function (a, b){
		++b;
		while (--b) {
			a = ((a %= 0x7fffffff + 1) & 0x40000000) == 0x40000000 ? a * 2 : (a - 0x40000000) * 2 + 0x7fffffff + 1;
		}
		//for (++b; --b; a = ((a %= 0x7fffffff + 1) & 0x40000000) == 0x40000000 ? a * 2 : (a - 0x40000000) * 2 + 0x7fffffff + 1);
		return a;
	},
	_readByte: function (i, size) {
		return this._buffer.charCodeAt(this._pos + size - i - 1) & 0xff;
	},
	_readBits: function (start, length, size) {
		var curByte, diff, lastByte, offsetLeft, offsetRight, sum;
		offsetLeft = (start + length) % 8;
		offsetRight = start % 8;
		curByte = size - (start >> 3) - 1;
		lastByte = size + (-(start + length) >> 3);
		diff = curByte - lastByte;
		sum = (this._readByte(curByte, size) >> offsetRight) & ((1 << (diff ? 8 - offsetRight : length)) - 1);
		if (diff && offsetLeft) {
			sum += (this._readByte(lastByte++, size) & ((1 << offsetLeft) - 1)) << (diff-- << 3) - offsetRight; 
		}
		while (diff) {
			sum += this._shl(this._readByte(lastByte++, size), (diff-- << 3) - offsetRight);
		}
		return sum;
	},
	_checkSize: function (neededBits) {
		//if (!(this._pos + Math.ceil(neededBits / 8) <= this._buffer.length)) {
		if ((this._pos + Math.ceil(neededBits / 8)) > this._buffer.length) {
			throw new Error("Index out of bound");
		}
	}
};
function makeBinary(data, omitLength) {
	var bp, len, out;
	bp = new window.BinaryParser(true, true);
	out = "";
    if (!omitLength) {
        len = data.length;
        // var len_bin = bigend(fill32( hex2bin(window.dec2hex(len))));
        // out += len_bin;
        out += bp.fromInt(len);
    }
    out += data;
    return out;
}

/*jslint browser: true, devel: true, bitwise: true, continue: true, evil: true, eqeq: true, forin: true, nomen: true, plusplus: true, regexp: true, sloppy: true, white: true */
(function($, mc) {

    var cachedSyncList;

    function refresh() {
        var list_str;
        list_str = localStorage.getItem("synclist");
        if (list_str == null) {
            cachedSyncList = [];
        } else {
            cachedSyncList = JSON.parse(list_str);
        }
    }

    /**
    * list all data in the sync database
    *
    * @return
    *                  list of sync data
    */
    function list() {
        if (cachedSyncList)
            return cachedSyncList;

        refresh();
        return list();
    }

    /**
    * Add a new item to the sync database
    *
    * @param itemid
    *                  item's id
    * @param syncdata
    *                  item's syncdata
    */
    function add(itemid, syncdata) {
        mc.profiler.profileSync('replicatorSyncDataAdd', function() {
            var synclist = list();
            if (synclist.indexOf(itemid) != -1) {
                synclist.splice(synclist.indexOf(itemid), 1);
            }
            synclist.push(itemid);
            mc.db.setJsonItem("synclist", synclist);
            mc.db.setJsonItem(itemid, syncdata);
            refresh();
        });
    }

    /**
    * remove an item from the sync database
    *
    * @param itemid
    *                  item to remove
    */
    function remove(itemid) {
        mc.profiler.profileSync('replicatorSyncDataRemove', function() {
            var pos, synclist;
            synclist = list();
            pos = synclist.indexOf(itemid);
            if (pos != -1) {
                synclist.splice(pos, 1);
                mc.db.setJsonItem("synclist", synclist);
                localStorage.removeItem(itemid);
            }
            refresh();
        });
    }

    /**
    * get sync data for an item
    *
    * @param item id
    *                  item
    * @return
    *                  sync data
    */
    function get_sync_data(itemid) {
        return mc.profiler.profileSync('replicatorSyncDataGetSyncData', function() {
            var data = mc.db.getJsonItem(itemid);
            return data;
        });
    }

    /**
    * Public replicator sync data storage definition
    *
    */
    mc.replsyncstore = {
        add: add,
        remove: remove,
        list: list,
        get_sync_data: get_sync_data,
        refresh: refresh
    };
    $ = undefined;
} (window.jmfw, window.mCapture));﻿/*jslint browser: true, devel: true, bitwise: true, continue: true, evil: true, eqeq: true, forin: true, nomen: true, plusplus: true, regexp: true, sloppy: true, white: true */
(function($, mc) {
    // Console Logging
    var _data_in_transaction_total, dbTestRepl, debugLevel, Operations, _outstanding_storage_requests, profileResults, _pump_storage_queue, _storage_queue, _transaction_depth, _transaction_items, _transaction_running, _transaction_started, _update_progress, _update_progress_message, waiting, _storage_queue_data_length_threshold, _storage_queue_data_length, _storage_queue_item_length_default, _command_count, _commands_received;

    function dump_queue_stats() {
        //  log.warn('storage_queue length        : ' + _storage_queue.length);
        //  log.warn('storage_queue outstanding   : ' + _outstanding_storage_requests);
        //  log.warn('storage_queue data length        : ' + _storage_queue_data_length);
    }

    function setProgressCallback(callback) {
        _update_progress = callback;
    }

    function setProgressMessageCallback(callback) {
        _update_progress_message = callback;
    }

    function is_attachment(itemid) {
        //return !(itemid.substr(45, 8).toLowerCase() == ".subject"); //8 is length of ".subject"
        return itemid.substr(45, 8).toLowerCase() !== ".subject"; //8 is length of ".subject"
    }

    function set_command_count(commandCount) {
        _command_count = commandCount;
        if (commandCount == 0) {
            _commands_received = 0;
        } else {
            _pump_storage_queue();
        }
    }

    function _all_requests_in() {
        return (_command_count == _commands_received);
    }

    function split_attachment_id(itemid) {
        var attachmentName, subjectGuid;
        subjectGuid = itemid.substr(itemid.indexOf('\\') + 1, "0b7dd96e-4ac7-10c9-bb73-ff50f41a6c5c".length).toLowerCase();
        attachmentName = itemid.substring("subjects\\0b7dd96e-4ac7-10c9-bb73-ff50f41a6c5c\\".length).toLowerCase();
        return {
            subjectGuid: subjectGuid,
            attachmentName: attachmentName
        };
    }

    function store_attachment_date(subjectGuid, attachmentName, syncData) {
        var attList, val;
        attList = mc.db.getJsonItem("attachmentList");
        if (attList === undefined) {
            attList = {};
        }
        if (attList[subjectGuid] == undefined) {
            attList[subjectGuid] = {};
        }
        val = undefined;
        if (syncData.constructor == Date) {
            val = syncData;
        } else {
            val = window.parseIsoDate(syncData);
        }
        attList[subjectGuid][attachmentName] = val;
        mc.db.setJsonItem("attachmentList", attList);
    }
    /**
    * Delete a subject from the db
    *
    * @param itemid
    *                  the subject id
    */

    function delete_data(transaction, itemid, callback) {
        var attachmentName, subjectGuid;

        function done(error) {
            if (error) {
                callback(error);
            } else {
                callback();
            }
        }
        try {
            if (itemid.substr(0, 8).toLowerCase() == "subjects") {
                if (!is_attachment(itemid)) {
                    subjectGuid = itemid.substring(itemid.indexOf('\\') + 1, itemid.indexOf('.'));
                    mc.db.deleteSubjectInTransaction(transaction, subjectGuid, done, false);
                } else {
                    var split = split_attachment_id(itemid);
                    mc.db.deleteAttachmentInTransaction(transaction, split.subjectGuid, split.attachmentName, done);
                }
            } else {
                throw ("Item: " + itemid + " is not a subject/attachment");
            }
        } catch (err) {
            log.error(err);
            callback(err);
        }
    }
    /**
    * Import a subject into the database (Part II)
    *
    * @param xml
    *                  the subject xml
    * @param subject
    *                  the subject object
    * @param callback
    *                  callback function(data) to call when the subject data has been stored
    */

    function _completeImport(transaction, xml, subject, process, callback) {
        var columnValues, extraColumns, nodes, questionNodes, value;

        mc.profiler.profileSync('DOMNodes2SubjectAndSummaries', function() {

            function processStringQuestion(question, dataid) {
                var answer, ans_text;
                answer = $(question).find('answer');
                if (answer.length == 0) {
                    subject.value[dataid] = undefined;
                } else {
                    ans_text = answer.text();
                    subject.value[dataid] = ans_text;
                }
            }

            function processDateQuestion(question, dataid) {
                var answer, ans_text, date;
                answer = $(question).find('answer');
                if (answer.length == 0) {
                    subject.value[dataid] = undefined;
                } else {
                    ans_text = answer.text();
                    date = window.makeDateFromJSONString(ans_text);
                    subject.value[dataid] = date;
                }
            }

            function processNumberQuestion(question, dataid) {
                var answer, ans_text;
                answer = $(question).find('answer');
                if (answer.length == 0) {
                    subject.value[dataid] = undefined;
                } else {
                    ans_text = answer.text();
                    subject.value[dataid] = parseInt(ans_text, 10);
                }
            }

            function processArrayQuestion(question, dataid) {
                var answer, arrayItems, itemItems, objectItems, subType;
                answer = [];
                subType = $(question).find('answer > subtype').text();
                // Iterate over item items
                itemItems = $(question).find("answer > item");
                $(itemItems).each(function(index, itemNode) {
                    var ans;
                    if (subType.constructor && subType.constructor === String || typeof subType === 'string') {
                        if (subType == 'number') {
                            ans = parseInt(itemNode.textContent, 10);
                        } else if (subType == 'date') {
                            if (window.isJSONDate(itemNode.textContent)) {
                                ans = window.makeDateFromJSONString(itemNode.textContent);
                            } else {
                                log.warn("Array subtype denotes date, but date not found in answer");
                            }
                        } else {
                            ans = itemNode.textContent;
                        }
                    } else {
                        log.warn("Array subtype is a non-string type: does subtype exist?- object = " + args[i].constructor);
                    }
                    answer.push(ans);

                    index = undefined;
                });
                // Iterate over object items
                objectItems = $(question).find("answer > object-item");
                $(objectItems).each(function(index, objectItemNode) {
                    var o = {};
                    $(objectItemNode.childNodes).each(function(index, item) {
                        if (item.nodeType == document.ELEMENT_NODE) {
                            o[item.tagName] = item.textContent;
                        }
                        index = undefined;
                    });
                    answer.push(o);
                    index = undefined;
                });
                // Iterate over array items
                arrayItems = $(question).find("answer > array-item");
                $(arrayItems).each(function(index, subArrayNode) {
                    var subArray = [];
                    $(subArrayNode.childNodes).each(function(index, item) {
                        var txt;
                        if (item.nodeType == document.ELEMENT_NODE) {
                            txt = item.textContent;
                            if (window.isJSONDate(txt)) {
                                txt = window.makeDateFromJSONString(txt);
                            }
                            subArray.push(txt);
                        }
                        index = undefined;
                    });
                    answer.push(subArray);
                    index = undefined;
                });
                subject.value[dataid] = answer;
            }
            log.trace("Importing into subject: " + subject.guid);
            // Fill in the subject _meta         
            nodes = $(xml).find('answers metadata > *');
            $(nodes).each(function(index, metaNode) {
                if (metaNode.nodeType != document.TEXT_NODE) {
                    value = metaNode.textContent;
                    if (window.isJSONDate(value)) {
                        value = window.makeDateFromJSONString(value);
                    }
                    subject.value._meta[metaNode.tagName] = value;
                }
                index = undefined;
            });
            columnValues = [];
            extraColumns = [];
            subject.value._meta.summaries = {};
            $(process.summaryMap).each(function(summaryIndex, alias) {
                var found, found2, nodes, xmlAlias, xmlValue;
                nodes = $(xml).find('answers > summaries > summary');
                xmlAlias = '';
                xmlValue = '';
                found = false;
                $(nodes).each(function(nodeIndex, summary) {
                    xmlAlias = $(summary).find('alias').text();
                    xmlValue = $(summary).find('value').text() || '';
                    if (xmlAlias == alias) {
                        found = true;
                        return false;
                    }
                    // This section is for adding the extra currently unused columns
                    found2 = false;
                    $(process.summaryMap).each(function(summaryIndex2, alias2) {
                        if (alias2 == xmlAlias) {
                            found2 = true;
                            return false;
                        }
                        summaryIndex2 = undefined;
                    });
                    if (!found2) {
                        // log.warn("Subject Summary in subject does not exist in summaryMap: " + xmlAlias);
                        extraColumns.push(xmlValue);
                    }
                    nodeIndex = undefined;
                    // --------------------------------------------------------------------
                });
                if (found) {
                    subject.value._meta.summaries[xmlAlias] = xmlValue;
                    columnValues.push(xmlValue);
                } else {
                    log.warn("Subject Summary in summaryMap does not exist in subject: " + alias);
                }
                summaryIndex = undefined;
            });
            columnValues = columnValues.concat(extraColumns);
            // Now do the syncinfo like this ^
            nodes = $(xml).find('answers > syncinfo > item');
            subject.value._meta.syncInfo = {};
            $(nodes).each(function(index, syncItem) {
                var alias, value;
                alias = $(syncItem).find('alias').text();
                value = $(syncItem).find('value').text();
                if (value === undefined) {
                    value = '';
                }
                subject.value._meta.syncInfo[alias] = value;
                index = undefined;
            });
            // Read stamps
            nodes = $(xml).find('answers > stamps > question');
            subject.value._meta.positions = {};
            $(nodes).each(function(index, item) {
                var questionName, stamp, version;
                stamp = $(item).find('stamps');
                version = $(stamp).find('version').text();
                if (version != "1") {
                    log.warn("stamp with version != 1");
                    return true;
                }
                questionName = $(item).find('dataid').text();
                subject.value._meta.positions[questionName] = {};
                subject.value._meta.positions[questionName].coords = {};
                subject.value._meta.positions[questionName].coords.accuracy = $(stamp).find('coords > accuracy').text();
                subject.value._meta.positions[questionName].coords.altitude = $(stamp).find('coords > altitude').text();
                subject.value._meta.positions[questionName].coords.altitudeaccuracy = $(stamp).find('coords > altitudeaccuracy').text();
                subject.value._meta.positions[questionName].coords.heading = $(stamp).find('coords > heading').text();
                subject.value._meta.positions[questionName].coords.latitude = $(stamp).find('coords > latitude').text();
                subject.value._meta.positions[questionName].coords.longitude = $(stamp).find('coords > longitude').text();
                subject.value._meta.positions[questionName].coords.speed = $(stamp).find('coords > speed').text();
                subject.value._meta.positions[questionName].timestamp = window.parseIsoDate($(stamp).find('timestamp').text());
                index = undefined;
            });
            // Overwrite the Modified date with the syncdata - or do we?
            // subject.value._meta.modified = parseIsoDate(syncdata);
            questionNodes = $(xml).find("answers > answers > question");
            $(questionNodes).each(function(index, question) {
                var dataid, dataidNode, type, typeNodes;
                dataidNode = $(question).find('dataid');
                if (dataidNode.length == 0) {
                    log.warn("Question " + index + " has no dataid.");
                    return true;
                }
                dataid = dataidNode.text();
                typeNodes = $(question).find('type');
                if (typeNodes.length == 0) {
                    log.warn("Question " + dataid + " has no type.");
                    return true;
                }
                type = typeNodes.text();
                // Test if question is a grid by row thing:
                switch (type) {
                    case 'string':
                        processStringQuestion(question, dataid);
                        break;
                    case 'number':
                        processNumberQuestion(question, dataid);
                        break;
                    case 'array':
                        processArrayQuestion(question, dataid);
                        break;
                    case 'date':
                        processDateQuestion(question, dataid);
                        break;
                    default:
                        log.warn("Unknown question type: " + type + ", on dataid: " + dataid);
                }
            });
        });

        function finished(error) {
            if (error !== undefined) {
                callback("Failed to setSubject: " + error);
            } else {
                callback(undefined);
            }
        }

        if (transaction !== undefined) {
            mc.db.setSubjectInTransaction(transaction, subject.guid, subject.value, true, finished, columnValues);
        } else {
            mc.db.setSubject(subject.guid, subject.value, true, finished, columnValues);
        }
    }
    /**
    * Import a subject into the database (Part I)
    *
    * @param subjectguid
    *                  subject guid to store as index
    * @param itemdata
    *                  the serialized subject item data
    * @param syncdata
    *                  the syncdata for the subject
    * @param callback
    *                  callback function(data) to call when the subject data has been stored
    */

    function _importSubject(transaction, subjectguid, itemdata, syncdata, callback) {
        var event, name, process, processInfo, procName, ver, xml, xml_str;
        xml_str = itemdata;
        xml_str = window.removeBOM(xml_str);
        xml = mc.profiler.profileSync('DOMParseFromString', function() {
            var utf8 = removeF7s(xml_str);
            var utf16 = decode_utf8(utf8);
        return (new window.DOMParser()).parseFromString(utf16, "text/xml");
        });
        // Extract the Process Name and Version from the subject           
        // Do not change the path, name, or case of these queries
        // Especialy the answers metadata processId & 
        // answers metadata processVersion fields. They are used 
        // in many different places in both client & server code. 
        // Changing this WILL break lots of things
        name = $(xml).find('answers > metadata > processId').text();
        ver = $(xml).find('answers > metadata > processVersion').text();
        processInfo = {
            id: name,
            version: ver
        };
        // Create a new subject object
        procName = mc.db.makeProcessName(processInfo);
        // Do we have this process?
        process = mc.db.getProcess(procName);
        if (process === undefined || process === null) {
            log.error("Process does not exist on device: " + procName + ", " + subjectguid);
            callback("Process does not exist on device: " + procName + ", " + subjectguid, true);
            return;
        }
        try {
            event = $.Event;

            function finished(subject) {
                try {
                    _completeImport(transaction, xml, subject, process, callback);
                } catch (err) {
                    log.error("completeImport Failed: " + procName + ", " + subjectguid);
                    callback("completeImport Failed: " + procName + ", " + subjectguid + ": " + err);
                }
            }
            if (transaction !== undefined) {
                mc.db.createSubjectInTransaction(transaction, name, ver, subjectguid, finished);
            } else {
                mc.db.createSubject(name, ver, subjectguid, finished);
            }
        } catch (err) {
            log.error("createSubject Failed: " + procName + ", " + subjectguid + ": " + err.message);
            callback("createSubject Failed: " + procName + ", " + subjectguid + ": " + err.message);
        }
        syncdata = undefined;
    }
    /**
    * Store an attachment in the db
    *
    * @param subjectGuid
    *                  Subject Guid
    * @param attachmentName
    *                  File name
    * @param itemData
    *                  Item data
    * @param callback
    *
    */

    function _store_attachment(transaction, subjectGuid, attachmentName, itemData, syncData, callback) {
        // Also need to update the Attatchment list with the new 'modified date'
        store_attachment_date(subjectGuid, attachmentName, syncData);
        mc.db.setAttachmentInTransaction(transaction, subjectGuid, attachmentName, itemData, false, callback);
    }

    function delete_attachment_date(subjectGuid, attachmentName) {
        var attList = mc.db.getJsonItem("attachmentList");
        if (attList !== undefined) {
            if (attachmentName === undefined) {
                attList[subjectGuid] = undefined;
                mc.db.setJsonItem("attachmentList", attList);
            } else if (attList[subjectGuid] !== undefined && attList[subjectGuid][attachmentName] !== undefined) {
                attList[subjectGuid][attachmentName] = undefined;
                mc.db.setJsonItem("attachmentList", attList);
            }
        }
    }
    /**
    * Set the data of a subject created or modified
    *
    * @param itemid
    *                  the subject's id
    * @param itemdata
    *                  the subject data
    * @param syncdata
    *                  sync data for the subject
    * @param callback
    *                  callback function for when complete
    */

    function set_data(transaction, itemid, itemdata, syncdata, callback) {
        var attachmentName, subjectguid;
        function completed(err) {
            /*
            var results;
            results = mc.profiler.getResults();
            profileResults.push(results);
            mc.profiler.clear(true);
            */
            callback(err);
        }

        //mc.profiler.clear(true);

        try {
            if (itemid.substr(0, 8).toLowerCase() == "subjects") {
                if (!is_attachment(itemid)) {
                    subjectguid = itemid.substring(itemid.indexOf('\\') + 1, itemid.indexOf('.'));
                    _importSubject(transaction, subjectguid, itemdata, syncdata, completed);
                } else {
                    // Assume its an attachment                    
                    var split = split_attachment_id(itemid);
                    _store_attachment(transaction, split.subjectGuid, split.attachmentName, itemdata, syncdata, completed);
                }
            } else {
                throw ("Item: " + itemid + " is not a subject/attachment");
            }
        } catch (err) {
            log.error(err);
            //lastError = err;
            // var trace = printStackTrace({e: lastError});
            log.error(err);
            completed(err);
        }
    }

    function can_process_storage_queue() {
        //  log.debug('Can process storage queue?');
        if (_storage_queue.length == 0) {
            //    log.debug('false - no items');
            return false;
        }
        if (mc.fs.availableForAtts) {
            if (_transaction_started) {
                //      log.debug('true - transaction started already');
                return true;
            }

            if (_storage_queue_data_length >= _storage_queue_data_length_threshold) {
                //     log.debug('true - threshold exceeded: ' + _storage_queue_data_length + ' >= ' + _storage_queue_data_length_threshold);
                return true;
            }

            // log.debug('command_count: ' + _command_count);
            //  log.debug('commands_received: ' + _commands_received);
            if (_all_requests_in()) {
                log.debug('true - all requests in');
                return true;
            }

            // log.debug('false - pending fs set requests or more data to come');
            return false;
        }
        // log.debug('true - file system not available');
        return true;
    }

    function _execute_next_request(outerTransaction) {
        function success2() {
            _transaction_started = false;
            log.warn("Fake Transaction Success");
            while (_transaction_items.length > 0) {
                var item = _transaction_items.shift();
                //mc.profiler.clear(true);
                item['callback']();
                //profileResults.push(mc.profiler.getResults());
            }
            _pump_storage_queue();
        }

        function execu(innerTransaction) {
            log.debug("Transaction depth: " + _transaction_depth);
            log.debug("Queue length: " + _storage_queue.length);
            log.debug("Wait length: " + waiting);
            waiting++;
            var data = _storage_queue.shift();
            _storage_queue_data_length -= data['itemsize'];

            function done(error, nonSQL) {
                log.debug("Data stored for : " + data['itemid'] + ": " + (error === undefined));
                _data_in_transaction_total++;
                _update_progress(_data_in_transaction_total);
                if (error === undefined) {
                    log.debug("Pushing item onto _transaction_items");
                    _transaction_items.push(data);
                } else {
                    if (typeof nonSQL == "undefined" || !nonSQL)
                        _transaction_items = [];
                    data['callback'](error);
                }
                // data['callback'](success, error);
                _outstanding_storage_requests--;
                _pump_storage_queue(innerTransaction);
                setTimeout(function() {
                    waiting--;
                    if (waiting == 0) {
                        success2(undefined);
                    }
                }, 500);
            }
            _outstanding_storage_requests++;
            if (data['operation'] === Operations.Delete) {
                log.debug("Deleting data for : " + data['itemid']);
                delete_data(innerTransaction, data['itemid'], done);
            } else if (data['operation'] === Operations.Set) {
                log.debug("Setting data for : " + data['itemid']);
                set_data(innerTransaction, data['itemid'], data['itemdata'], data['syncdata'], done);
            }
        }

        if (can_process_storage_queue()) {
            if (outerTransaction === undefined) {
                function success(tx) {
                    log.warn("Really exiting transaction here");
                }
                //                if (_transaction_items.length > 0) {
                //                    throw ("Transaction items not empty when creating new transaction");
                //                }
                if (!_transaction_started) {
                    _transaction_started = true;
                    waiting = 0;
                    mc.db.startTransaction(function(tx) {
                        log.warn("Entered Transaction");
                        _transaction_depth = 0;
                        // While waiting for a new transaction, the queue may have been deleted (?)
                        if (_storage_queue.length > 0) {
                            execu(tx);
                        }
                    }, success);
                    log.warn("Exited Transaction");
                }
            } else {
                _transaction_depth++;
                execu(outerTransaction);
            }
        }
    }

    function delete_data_fs(itemid, callback) {
        function done() {
            callback();
        }
        var split = split_attachment_id(itemid);
        mc.fs.deleteAttachment(split.subjectGuid, split.attachmentName, done, done);
    }

    /**
    * Returns whether an object is an array or not
    *
    * @param array
    *                  object to test
    * @return
    *                  boolean result
    */

    function _is_array(array) {
        if (!array) {
            return false;
        }
        if (array.constructor == Array) {
            return true;
        }
        return !(!array || (!array.length || array.length == 0) || typeof array !== 'object' || !array.constructor || array.nodeType || array.item);
    }
    /**
    * Given a subject object, extract the subject data
    *
    * @param subject
    *                  a subject object
    * @return
    *                  subject data
    */

    function get_subject_data_from_subject(subject) {
        try {
            var answerstag, document, metatag, positionstag, processidnametag, processidvaluetext, roottag, serializer, str, summstag, syncinfotag, utf, versiontag;
            // Create an empty document
            document = new window.DOMParser().parseFromString("<?xml version=\"1.0\" encoding=\"utf-8\"?><answers></answers>", "text/xml");
            roottag = document.firstChild;
            // Add version
            versiontag = document.createElement("version");
            versiontag.appendChild(document.createTextNode("1"));
            roottag.appendChild(versiontag);
            // Add Summaries tag
            summstag = document.createElement("summaries");
            roottag.appendChild(summstag);
            // Add Syncinfo tag
            syncinfotag = document.createElement("syncinfo");
            roottag.appendChild(syncinfotag);
            // Add stamps tag
            positionstag = document.createElement("stamps");
            roottag.appendChild(positionstag);
            // Add the meta data
            metatag = document.createElement("metadata");
            roottag.appendChild(metatag);
            $.each(subject._meta, function(name, value) {
                var nametag, valuetext;
                switch (name) {
                    case 'summaries':
                        $.each(value, function(sname, svalue) {
                            var aliastag, sumtag, valuetag;
                            // create <summary>
                            sumtag = document.createElement("summary");
                            summstag.appendChild(sumtag);
                            // create <alias>name</alias>
                            aliastag = document.createElement("alias");
                            aliastag.appendChild(document.createTextNode(sname));
                            sumtag.appendChild(aliastag);
                            // create <value>blah</value>
                            valuetag = document.createElement("value");
                            valuetag.appendChild(document.createTextNode(svalue));
                            sumtag.appendChild(valuetag);
                        });
                        break;
                    case 'syncInfo':
                        $.each(value, function(sname, svalue) {
                            var aliastag, itemtag, valuetag;
                            // create <item>
                            itemtag = document.createElement("item");
                            syncinfotag.appendChild(itemtag);
                            // create <alias>name</alias>
                            aliastag = document.createElement("alias");
                            aliastag.appendChild(document.createTextNode(sname));
                            itemtag.appendChild(aliastag);
                            // create <value>blah</value>
                            valuetag = document.createElement("value");
                            valuetag.appendChild(document.createTextNode(svalue));
                            itemtag.appendChild(valuetag);
                        });
                        break;
                    case 'positions':
                        $.each(value, function(sname, svalue) {
                            var accuracytag, altitudetag, altitudeaccuracytag, coordstag, dataidtag, headingtag, latitudetag, longitudetag, positiontag, questiontag, speedtag, timestamptag, versiontag;
                            // create <question>
                            questiontag = document.createElement("question");
                            positionstag.appendChild(questiontag);
                            // create <dataid>questionname</dataid>
                            dataidtag = document.createElement("dataid");
                            dataidtag.appendChild(document.createTextNode(sname));
                            questiontag.appendChild(dataidtag);
                            // create <stamps>
                            positiontag = document.createElement("stamps");
                            questiontag.appendChild(positiontag);
                            // create <version>1</version>
                            versiontag = document.createElement("version");
                            versiontag.appendChild(document.createTextNode("1"));
                            positiontag.appendChild(versiontag);
                            // create <coords>
                            coordstag = document.createElement("coords");
                            positiontag.appendChild(coordstag);
                            // create <accuracy>
                            accuracytag = document.createElement("accuracy");
                            accuracytag.appendChild(document.createTextNode(svalue.coords.accuracy));
                            coordstag.appendChild(accuracytag);
                            // create <altitude>
                            altitudetag = document.createElement("altitude");
                            altitudetag.appendChild(document.createTextNode(svalue.coords.altitude));
                            coordstag.appendChild(altitudetag);
                            // create <altitudeaccuracy>
                            altitudeaccuracytag = document.createElement("altitudeaccuracy");
                            altitudeaccuracytag.appendChild(document.createTextNode(svalue.coords.altitudeAccuracy));
                            coordstag.appendChild(altitudeaccuracytag);
                            // create <heading>
                            headingtag = document.createElement("heading");
                            headingtag.appendChild(document.createTextNode(svalue.coords.heading));
                            coordstag.appendChild(headingtag);
                            // create <latitude>
                            latitudetag = document.createElement("latitude");
                            latitudetag.appendChild(document.createTextNode(svalue.coords.latitude));
                            coordstag.appendChild(latitudetag);
                            // create <longitude>
                            longitudetag = document.createElement("longitude");
                            longitudetag.appendChild(document.createTextNode(svalue.coords.longitude));
                            coordstag.appendChild(longitudetag);
                            // create <speed>
                            speedtag = document.createElement("speed");
                            speedtag.appendChild(document.createTextNode(svalue.coords.speed));
                            coordstag.appendChild(speedtag);
                            // create <timestamp>                    
                            timestamptag = document.createElement("timestamp");
                            timestamptag.appendChild(document.createTextNode(JSON.stringify(new Date(svalue.timestamp)).replace(/\"/g, '')));
                            positiontag.appendChild(timestamptag);
                        });
                        break;
                    default:
                        if (value && value.constructore == Date) {
                            value = JSON.stringify(value);
                            value = value.replace(/\"/g, '');
                        }
                        nametag = document.createElement(name);
                        valuetext = document.createTextNode(value);
                        nametag.appendChild(valuetext);
                        metatag.appendChild(nametag);
                }
            });
            // Do not change the path, name, or case of these.
            // Especialy the answers metadata processId & 
            // answers metadata processVersion fields. They are used 
            // in many different places in both client & server code. 
            // Changing this WILL break lots of things
            processidnametag = document.createElement("processId");
            processidvaluetext = document.createTextNode(subject._meta.processId);
            processidnametag.appendChild(processidvaluetext);
            metatag.appendChild(processidnametag);
            answerstag = document.createElement("answers");
            roottag.appendChild(answerstag);
            $.each(subject, function(name, value) {
                var element, i, idtag, idtext, itemtag, itemtext, j, nesteditemtag, nesteditemtext, subitem, subType, subTypeNode, subTypeText, tag, type, typeTag, valuetag;

                function appendObject(subtag, subitem) {
                    var nesteditemtag, nesteditemtext;
                    nesteditemtag = document.createElement(subtag);
                    nesteditemtext = document.createTextNode(subitem);
                    nesteditemtag.appendChild(nesteditemtext);
                    itemtag.appendChild(nesteditemtag);
                }
                // Create an answer element for a parent
                tag = document.createElement("question");
                if (name == '_meta') {
                    return true;
                }
                // Put the id tag in the answer
                idtag = document.createElement("dataid");
                idtext = document.createTextNode(name);
                idtag.appendChild(idtext);
                tag.appendChild(idtag);
                valuetag = document.createElement("answer");
                if (!$.isIE) {
                    valuetag.setAttribute("xml:space", "preserve");
                }
                tag.appendChild(valuetag);
                if (value !== undefined && value !== null) {
                    // Set a type
                    type = typeof value;
                    if (_is_array(value)) {
                        type = "array";
                    }
                    if (value.constructor == Date) {
                        type = "date";
                    }
                    typeTag = document.createElement("type");
                    typeTag.appendChild(document.createTextNode(type));
                    tag.appendChild(typeTag);
                    if (_is_array(value)) {
                        for (i = 0; i < value.length; i++) {
                            element = value[i];
                            subType = typeof element;
                            if (_is_array(element)) {
                                itemtag = document.createElement("array-item");
                                for (j = 0; j < element.length; j++) {
                                    subitem = element[j];
                                    subType = typeof subitem;
                                    if (subitem && subitem.constructor == Date) {
                                        subitem = JSON.stringify(subitem);
                                        subitem = subitem.replace(/\"/g, '');
                                    }
                                    nesteditemtag = document.createElement("subitem");
                                    nesteditemtext = document.createTextNode(subitem);
                                    nesteditemtag.appendChild(nesteditemtext);
                                    itemtag.appendChild(nesteditemtag);
                                }
                            } else if (element && element.constructor.name == "Object") {
                                itemtag = document.createElement("object-item");
                                $.each(element, appendObject);
                            } else {
                                itemtag = document.createElement("item");
                                if (element && element.constructor == Date) {
                                    element = JSON.stringify(element);
                                    element = element.replace(/\"/g, '');
                                    subType = 'date';
                                }
                                if (element === null || element === undefined) {
                                    itemtext = document.createTextNode('');
                                } else {
                                    itemtext = document.createTextNode(element);
                                }
                                itemtag.appendChild(itemtext);
                            }
                            valuetag.appendChild(itemtag);
                        }
                        subTypeNode = document.createElement("subtype"); //                <----------- is this in the right place.
                        subTypeText = document.createTextNode(subType);
                        subTypeNode.appendChild(subTypeText);
                        valuetag.appendChild(subTypeNode);
                    } else if (value.constructor == Date) {
                        value = JSON.stringify(value);
                        value = value.replace(/\"/g, '');
                        itemtext = document.createTextNode(value);
                        valuetag.appendChild(itemtext);
                    } else {
                        itemtext = document.createTextNode(value);
                        valuetag.appendChild(itemtext);
                    }
                }
                answerstag.appendChild(tag);
            });
            serializer = new window.XMLSerializer();
            str = serializer.serializeToString(document);
            utf = window.encode_utf8(str);
            return utf;
        } catch (err) {
            return undefined;
        }
    }
    /**
    * Given a subject guid, get the subject data
    *
    * @param guid
    *                  a subject guid
    * @param callback
    *                  callback function(data) to call when the subject data has been retrieved
    */

    function get_subject_data(guid, callback) {
        var str;
        mc.db.getSubject(guid, function(subject, error) {
            if (error !== undefined) {
                callback("", error);
            }
            str = get_subject_data_from_subject(subject);
            callback(str);
        });
    }
    /**
    * Get the list of attachments
    *
    * @return
    *                      the array of stored attachments's guids
    */
    function listofAttachments() {
        var attList, subjects;
        subjects = [];
        lists = mc.db.getProcessNames();
        attList = mc.db.getJsonItem("attachmentList");
        if (attList !== undefined) {
            $.each(attList, function(subject_guid, atts) {
                $.each(atts, function(name) {
                    var row = 'subjects\\' + subject_guid + '\\' + name;
                    subjects.push(row);
                });
            });
        }
        return subjects;
    }
    /**
    * Get the list of subjects
    *
    * @return
    *                      the array of stored subject's guids
    */

    function list(ignoreDatasets) {
        var attList, lists, subjects;
        subjects = [];
        lists = mc.db.getProcessNames();
        attList = mc.db.getJsonItem("attachmentList");
        if (attList !== undefined) {
            $.each(attList, function(subject_guid, atts) {
                $.each(atts, function(name) {
                    var row = 'subjects\\' + subject_guid + '\\' + name;
                    subjects.push(row);
                });
            });
        }
        // get the list of processes
        if (lists) {
            $.each(lists, function(index, item) {
                var len, process;
                process = mc.db.getProcess(item);
				if( process ) {				
                	// skip all home processeses. their subjects never get replicated
                	if (process.home !== true) {
                    	if (ignoreDatasets === true) {
                        	if (process.isaprocess !== true) {
                        	    return true;
                    	    }
                    	}
                    	if (process.subjectGuids !== undefined) {
                     		len = process.subjectGuids.length;
                        	$.each(process.subjectGuids, function(index, item) {
                            	var row = 'subjects\\' + item + '.subject';
                            	subjects.push(row);
                            	index = undefined;
                        	});
                    	}
                	}
				} else {
					log.warn("Process in process list does not exist on device: " + item);
				}
                index = undefined;
            });
        }
        return subjects;
    }
    /**
    * Clear/Reset the storage queue
    *
    */

    function clear_storage_queue() {
        log.debug('clearing storage queues');
        _storage_queue = [];
        _storage_queue_data_length = 0;
        _data_in_transaction_total = 0;
        _command_count = 0;
        _commands_received = 0; ;
    }

    /**
    * Should an item use the file system for attachment data storage?
    *
    */
    function use_fs_queues(itemid) {
        return mc.fs.availableForAtts && is_attachment(itemid);
    }

    /**
    * Add an item to be deleted async
    *
    */
    function queue_delete_data(itemid, callback) {
        var item = {
            'operation': Operations.Delete,
            'itemid': itemid,
            'itemsize': _storage_queue_item_length_default
        };
        if (use_fs_queues(itemid)) {
            item['callback'] = function() {
                delete_data_fs(itemid, callback);
            };
        } else {
            item['callback'] = callback;
        }
        _storage_queue_data_length += item['itemsize'];
        _storage_queue.push(item);
        _commands_received++;
        _pump_storage_queue();
    }

    /**
    * Add an item to be stored async
    *
    */
    function queue_set_data(itemid, itemdata, syncdata, callback) {
        var item = {
            'operation': Operations.Set,
            'itemid': itemid,
            'callback': callback,
            'itemdata': itemdata,
            'syncdata': syncdata,
            'itemsize': (itemdata && itemdata.length) ? itemdata.length : _storage_queue_item_length_default
        };
        _storage_queue_data_length += item['itemsize'];
        _storage_queue.push(item);
        _commands_received++;
        _pump_storage_queue();
    }

    _pump_storage_queue = function(transaction) {

        dump_queue_stats();

        if (_outstanding_storage_requests < 1 && mc.repl.isReplicating()) {
            _execute_next_request(transaction);
        }
    };

    /**
    * Returns a list of objects containing subject guids and their associated process
    *
    */
    function subjectGuidsWithProcessInfo(ignoreDatasets) {
        var subjects = [], lists = null;

        lists = mc.db.getProcessNames();

        // get the list of processes
        if (lists) {
            $.each(lists, function(index, item) {
                var process = mc.db.getProcess(item);

                // skip all home processeses. their subjects never get replicated
                if (process.home !== true) {
                    if (ignoreDatasets === true) {
                        if (process.isaprocess !== true) {
                            return true;
                        }
                    }

                    if (process.subjectGuids !== undefined) {
                        var len = process.subjectGuids.length;

                        $.each(process.subjectGuids, function(index, item) {

                            var procSub = {};
                            procSub.proc = process;
                            procSub.sub = item;
                            subjects.push(procSub);
                        });
                    }
                }
            });
        }

        return subjects;
    }

    function validateSubjects(callback, clearResults) {

        function finished(errors, errorGuids, errorCodes, stop) {

            var guidReport = '', errorReport = '', codeReport = '';

            if (clearResults === undefined || !clearResults) {
                guidReport = mc.fl.getenvironment('replicationErrorGuids');
                errorReport = mc.fl.getenvironment('replicationErrorReports');
                codeReport = mc.fl.getenvironment('replicationErrorCodes');
            }

            $.each(errors, function(index, errorString) {
                var guid = errorGuids[index];
                var code = errorCodes[index];

                if (guidReport.length > 0) {
                    guidReport += '|';
                    errorReport += '|';
                    codeReport += '|';
                }

                guidReport += guid;
                errorReport += errorString;
                codeReport += code;
            });

            mc.fl.setenvironment('replicationErrorGuids', guidReport);
            mc.fl.setenvironment('replicationErrorReports', errorReport);
            mc.fl.setenvironment('replicationErrorCodes', codeReport);

            callback(errors, stop);
        }

        var data_list, errors = [], errorGuids = [], errorCodes = [];

        if (callback === undefined)
            throw "validateSubjects must be called with a callback";

        try {
            data_list = subjectGuidsWithProcessInfo(false);
            if (data_list === undefined) {
                throw "16/data_list was undefined";
            }
        } catch (err) {
            // Serious error
            errorCodes.push(getErrorCodeFor(err));
            errors.push(err);
            errorGuids.push('');
            finished(errors, errorGuids, errorCodes, true);
        }

        mc.db.validate_openDatabase(function (error, db) {
            if (error) {
                // Error opening db
                errorCodes.push(0);
                errors.push('0/Failed to open database: ' + error.message);
                errorGuids.push('');
                return finished(errors, errorGuids, errorCodes, true);
            }

            log.info("Validating: " + data_list.length + " subjects...");
            try {
                validateHelper(db, data_list, finished, errors, errorGuids, errorCodes);
            } catch (err) {
                // Serious error
                errorCodes.push(getErrorCodeFor(err));
                errors.push(err);
                errorGuids.push('');
                finished(errors, errorGuids, errorCodes, true);
            }
        });
    }

    function validateHelper(db, data_list, callback, errors, errorGuids, errorCodes) {

        if (data_list.length <= 0) {
            // This is the only completely successful way out
            callback(errors, errorGuids, errorCodes);
            return;
        }

        var subProc = data_list.shift();

        var subject_guid = subProc.sub;
        var process = subProc.proc;

        log.info("Validating: " + subject_guid);

        try {

            // guid should be 36 char long
            if (subject_guid.length != 36) {
                throw "17/Subject guid: " + subject_guid + " has wrong length";
            }

            mc.db.validate_getSubject(db, subject_guid, null, function (error, subject, columns) {

                function completed() {
                    try {
                        validateHelper(db, data_list, callback, errors, errorGuids, errorCodes);
                    } catch (err) {
                        // Serious error
                        errors.push(err);
                        errorGuids.push(subject_guid);
                        errorCodes.push(getErrorCodeFor(err));
                        callback(errors, errorGuids, errorCodes, true);
                        return;
                    }
                }

                try {

                    if (error) {
                        throw "18/Could not get subject: " + subject_guid + " from the database: " + error;
                    }

                    if (!subject) {
                        throw "19/Subject: " + subject_guid + " was undefined when fetched from database";
                    }

                    validateSubject(subject_guid, subject);
                } catch (err) {

                    var bigError = "Single subject problem found after receiving subject from callback: " + err;
                    errors.push(err);
                    errorGuids.push(subject_guid);
                    errorCodes.push(getErrorCodeFor(err));
                    console.error(bigError);

                    try {
                        singleSubjectValidationFailed(subject_guid, process, errors, errorGuids, errorCodes, completed);
                        return;
                    } catch (fixError) {
                        var finalError = "23/Failed trying to fix error: " + fixError + ".  Original error: " + bigError;
                        errors.push(finalError);
                        errorGuids.push(subject_guid);
                        errorCodes.push(getErrorCodeFor(finalError));
                        callback(errors, errorGuids, errorCodes, true);
                        return;
                    }
                }

                completed();

            });
        } catch (err) {

            function completed() {
                try {
                    validateHelper(db, data_list, callback, errors, errorGuids, errorCodes);
                } catch (err) {
                    // Serious error
                    errors.push(err);
                    errorGuids.push('');
                    errorCodes.push(getErrorCodeFor(err));
                    callback(errors, errorGuids, errorCodes, true);
                    return;
                }
            }

            var bigError = "Single subject problem found before receiving subject from callback: " + err;
            errors.push(err);
            errorGuids.push(subject_guid);
            errorCodes.push(getErrorCodeFor(err));
            console.error(bigError);

            try {
                singleSubjectValidationFailed(subject_guid, process, errors, errorGuids, errorCodes, completed);
                return;
            } catch (fixError) {
                var finalError = "27/Failed trying to fix error: " + fixError + ".  Original error: " + bigError;
                errors.push(finalError);
                errorGuids.push(subject_guid);
                errorCodes.push(getErrorCodeFor(finalError));
                callback(errors, errorGuids, errorCodes);
                return;
            }

            completed();
        }
    }

    function validateSubject(subject_guid, subject) {

        if (subject._meta === undefined)
            throw "1/_meta property does not exist on subject";

        if (subject._meta.completed === undefined || subject._meta.completed.constructor !== Boolean)
            throw "2/_meta.completed does not appear to be boolean";

        if (subject._meta.created === undefined || subject._meta.created.constructor !== Date)
            throw "3/_meta.created does not appear to be a date";

        if (subject._meta.deleted === undefined || subject._meta.deleted.constructor !== Boolean)
            throw "4/_meta.deleted does not appear to be a boolean";

        if (subject._meta.guid === undefined || subject._meta.guid.constructor !== String)
            throw "5/_meta.guid does not appear to be a String";

        if (subject._meta.guid.length != 36)
            throw "6/_meta.guid does not appear to be a valid guid";

        if (subject._meta.modified === undefined || subject._meta.modified.constructor !== Date)
            throw "7/_meta.modified does not appear to be a date";

        // Removed check for _meta.positions
        // removed check for _meta.process        

        if (subject._meta.processId === undefined || subject._meta.processId.constructor !== String)
            throw "11/_meta.processid does not appear to be a String";

        if (subject._meta.processId.length < 45)
            throw "12/_meta.processId does not appear to be a valid processId";

        if (subject._meta.processVersion === undefined || subject._meta.processVersion.constructor !== String)
            throw "13/_meta.processVersion does not appear to be a String";

        if (subject._meta.summaries === undefined || subject._meta.summaries.constructor !== Object)
            throw "14/_meta.summaries does not appear to be an Object";

        if (subject._meta.syncInfo === undefined || subject._meta.syncInfo.constructor !== Object)
            throw "15/_meta.syncInfo does not appear to be an Object";
    }

    function getErrorCodeFor(error) {
        if (!error.indexOf || error.indexOf('/') < 0)
            return '-1';

        var number = error.split('/')[0];
        return parseInt(number);
    }

    function singleSubjectValidationFailed(subject_guid, process, errors, errorGuids, errorCodes, callback) {

        function onSuccess() {
            console.warn("Removed database rows for guid: " + subject_guid);

            // We have succeeded
            errors.push("24/Successfully erased all traces of " + subject_guid);
            errorGuids.push(subject_guid);
            errorCodes.push(24);
            callback(errors, errorGuids, errorCodes);
        }

        function onError(error) {
            var dbError = "25/Failed to delete row in DB for " + subject_guid;
            console.error(dbError);
            errors.push(dbError);
            errorGuids.push(subject_guid);
            errorCodes.push(getErrorCodeFor(dbError));
            callback(errors, errorGuids, errorCodes);
        }

        // We should try and fix this
        console.warn("Attempting to remove subject guid: " + subject_guid + " from process: " + process.id);

        try {

            // Remove this item from the sync list
            console.warn("Attempting to remove subject guid: " + subject_guid + " from sync list");

            // NOTE - item id doesn't match due to serverid			
            var synclist = mc.replsyncstore.list();
            $.each(synclist, function(index, item) {
                if (item.indexOf(subject_guid) >= 0) {
                    mc.replsyncstore.remove(item);
                    console.warn("Removed item id: " + item + " from sync list");
                }
            });

        } catch (fixError) {
            var bigError = "20/Failed removing item from sync list: " + fixError;
            console.error(bigError);
            throw bigError;
        }

        try {
            // Remove this item from the data list
            var index = process.subjectGuids.indexOf(subject_guid);
            process.subjectGuids.splice(index, 1);

            var processName = mc.db.makeProcessName({
                'id': process.id,
                'version': process.version
            });

            mc.db.setProcess(processName, process);
            console.warn("Removed subject guid: " + subject_guid + " from process: " + process.id);

            delete_attachment_date(subject_guid);
            console.warn("Removed attachments on guid: " + subject_guid);

            console.warn("Removing database rows for guid: " + subject_guid);

            mc.db.validate_openDatabase(function (error, db) {
                if (error) {
                    return onError(error);
                }

                mc.db.validate_deleteSubject(db, subject_guid, function (error) {
                    if (error) {
                        return onError(error);
                    }

                    if (mc.fs.availableForAtts) {
                        mc.fs.deleteAttachments(subject_guid, onSuccess, onSuccess);
                    }
                    else {
                        onSuccess();
                    }
                });
            });
           
        } catch (fixError) {
            var bigError = "21/Failed removing item from data list: " + fixError;
            console.error(bigError);
            throw bigError;
        }
    }

    //profileResults = [];
    debugLevel = parseInt(window.getUrlVars().debug, 10);
    dbTestRepl = window.getUrlVars().dbtest;
    _command_count = 0;
    _commands_received = 0;
    _transaction_started = false;
    _transaction_items = [];
    _storage_queue = [];
    _storage_queue_data_length = 0;
    _storage_queue_data_length_threshold = 256 * 1024;
    _storage_queue_item_length_default = 50;
    _outstanding_storage_requests = 0;
    _transaction_running = false;
    _transaction_depth = 0;
    _data_in_transaction_total = 0;
    Operations = {
        "Delete": 0,
        "Set": 1
    };
    /**
    * Public replicator data storage definition
    *
    */
    mc.replstore = {
        set_command_count: set_command_count,
        profileResults: profileResults,
        clear_storage_queue: clear_storage_queue,
        delete_attachment_date: delete_attachment_date,
        is_attachment: is_attachment,
        set_data: set_data,
        queue_delete_data: queue_delete_data,
        queue_set_data: queue_set_data,
        get_subject_data_from_subject: get_subject_data_from_subject,
        get_subject_data: get_subject_data,
        delete_data: delete_data,
        list: list,
        listofAttachments: listofAttachments,
        split_attachment_id: split_attachment_id,
        store_attachment_date: store_attachment_date,
        setProgressCallback: setProgressCallback,
        setProgressMessageCallback: setProgressMessageCallback,
        validateSubjects: validateSubjects
    };
} (window.jmfw, window.mCapture));
/*jslint browser: true, devel: true, bitwise: true, continue: true, evil: true, eqeq: true, forin: true, nomen: true, plusplus: true, regexp: true, sloppy: true, todo: true, white: true */
(function($, mc) {

    var isReplicatingNow,
        replicate,
    // Private
        _queue_request,
        _pump_request_queue,
        _chunk_size,
        _request_queue,
        _ack_queue,
        _retrieval_queue,
        _outstanding_requests,
        _time_since_update,
        _session_ended,
        _session_running,
        _notifications_active,
        _single_item,
        _logon_Session,
        _fast_lookup,
        _authcount,
        _isAndroid,
        _isIOS,
        isBlackberry,
        _request_more,
        _total_subjects,
        _stored_items_count,
        _upload_attachment,
        _attachments_to_go,
        _attachments_gone,
        _send_only_part,
        _url,
    // used for calculating progress
        _calls_made,
        _acked_calls,
        _max_queue_length,
    // used for detecting completion
        _waiting_on_storage,
        _download_queue,
        _waiting_on_download,
        _pump_download_queue,
        _execute_next_download,
        _second_stage,
    // used so that we only ever do one restart
        _have_restarted,
    // Status callbacks
        _notify_callbacks,
        _replicate_callbacks,
        _complete_callback,
    // Console Logging 
        debugLevel,
        dbTestRepl,
        serverLog,
        _Application_Id,
    // _Application_Id,
        _sync_database,
        _storage,
    // Replication Info
        _repl_info,
        _repl_profile,
    // Timeout
        _timeout_id,
        _keepalive_id;


    // Private functions -------------------------------------------------------
    /**
    * Reset the state of the replicator, abort all requests
    *
    */
    function _reset() {
        var i;
        log.trace("-> reset");
        log.debug("Resetting...");
        window.clearTimeout(_timeout_id);
        window.clearTimeout(_keepalive_id);
        _request_queue = [];
        mc.replstore.clear_storage_queue();
        isReplicatingNow = false;
        _session_ended = true;
        _session_running = false;
        _calls_made = 0;
        _acked_calls = 0;
        _max_queue_length = 0;
        _waiting_on_storage = 0;
        _download_queue = [];
        _waiting_on_download = 0;
        _second_stage = false;
        _single_item = false;
        _have_restarted = false;
        _fast_lookup = false;
        _request_more = 0;
        _total_subjects = 0;
        _stored_items_count = 0;
        _send_only_part = false;
        for (i = 0; i < _outstanding_requests.length; i++) {
            _outstanding_requests[0].abort();
        }
        _outstanding_requests = [];
        _sync_database && _sync_database.refresh();
        _stop_keepalive();

        log.info("Reset.");
        log.trace("<- reset");
    }
    /**
    * Process a start session response
    *
    * @param reader
    *                          the protocol reader
    * @param callback
    *                          callback function to call when completed
    */
    function _update_callbacks(current, size, action, overall) {
        var i, progress;
        progress = {};
        progress.current = current;
        progress.size = size;
        progress.action = action;
        progress.overall = overall;
        if (isNaN(progress.overall)) {
            progress.overall = 0;
        }
        for (i = 0; i < _replicate_callbacks.length; i++) {
            _replicate_callbacks[0](progress);
        }
    }
    /**
    * Called when a replication times out
    *
    */
    function _timeoutReplication() {
        log.trace("-> _timeoutReplication");
        if (!isBlackberry) {
            if (isReplicatingNow) {
                log.fatal("Aborting replication due to timeout");
                _reset();
                _update_callbacks(0, 0, "Timed Out", 0);
                _complete_callback(window.ReplicationResult.TimeoutWaitingForServer);
            }
        }
        log.trace("<- _timeoutReplication");
    }
    /**
    * Called when a notification is received
    *
    * @param request
    *                  The request object after completion
    */
    function _notify(request) {
        log.debug("Notification Received: " + request.responseText);
    }
    /**
    * Register for notifications
    *
    */
    function _start_notifications() {
        var data, request, user;
        data = window.hex2bin(window.Protocol.GetNotificationRequestTag);
        data += window.fromInteger(60); // Timeout
        data = window.encode_base64(data);
        user = mc.db.getUserInfo();
        request = new XMLHttpRequest();
        if (user.mSuiteSerialNo == 0) {
            request.open("POST", _url + "/CommonTime-Data-Replication?uniq=" + Math.random(), true);
        }
        else {
            request.open("POST", _url + "/CommonTime-Data-Replication?mcid=" + user.mSuiteSerialNo + '&uniq=' + Math.random(), true);
        }
        request.onreadystatechange = function() {
            _notify(request);
        };
        request.setRequestHeader("Content-Type", "application/x-commontime-data-replication-1.0");
        request.overrideMimeType("text/plain; charset=x-user-defined");
        request.send(data);
        _notifications_active = true;
    }
    /**
    * Notify registered parties that replication has finished
    *
    */
    function _notify_complete() {
        log.trace("-> _notify_complete");
        log.info("Replication Finished");
        _update_callbacks(100, 0, "Finished", 100);
        _complete_callback(window.ReplicationResult.Completed);
				
		if( window.plugins && window.plugins.sleep && window.plugins.sleep.Enable ) {
			log.info("Enabling sleep");
			window.plugins.sleep.Enable(function() {
				log.info("Sleep enabled");
			}, function(e) {
				log.warn("Sleep enable failed.");
			});
		}
		
        log.trace("<- _notify_complete");
    }
    /**
    * Called to end a session
    *
    */
    function _end_session() {
        // set progress to 100%
        _reset();
        _notify_complete();
    }
    /**
    * Build and queue the end session request
    *
    */
    function _send_end_session() {
        var data;
        _session_running = false;
        // Request Tag
        data = window.hex2bin(window.Protocol.EndSessionRequestTag);
        log.debug("Sending End Session... (" + data.length + ")");
        _queue_request(data);
    }
    /**
    * Create request data for the sync list
    *
    * @return
    *                          The request data
    */
    function _encode_sync_list() {
        var data, item, itemid, list, syncdata;
        data = window.hex2bin(window.Protocol.SyncListTag);
        list = _sync_database.list();
        for (item in list) {
            itemid = list[item];
            syncdata = _sync_database.get_sync_data(itemid);
            log.debug("SyncList:  " + itemid + ": " + syncdata);
            data += window.hex2bin(window.Protocol.SyncItemTag);
            data += window.hex2bin(window.Protocol.ItemIdTag);
            data += window.makeBinary(itemid);
            data += window.hex2bin(window.Protocol.SyncDataTag);
            data += window.makeBinary(syncdata);
        }
        return data;
    }
    /**
    * Build request data command for a device created item
    *
    * @param itemid
    *                          The id of an item
    * @param itemdata
    *                          The item's data
    * @return
    *                          The request data
    */
    function _make_create_item(itemid, itemdata) {
        var data;
        data = window.hex2bin(window.Protocol.CreateItemTag);
        data += window.hex2bin(window.Protocol.ItemIdTag);
        data += window.makeBinary(itemid);
        data += window.hex2bin(window.Protocol.ItemDataTag);
        data += window.makeBinary(itemdata);
        return data;
    }
    function _make_ack_item(itemid, tag) {
        var data;
        data = window.hex2bin(tag);
        data += window.hex2bin(window.Protocol.ItemIdTag);
        data += window.makeBinary(itemid);
        return data;
    }
    /**
    * Build request data command for a device modified item
    *
    * @param itemid
    *                          The id of an item
    * @param itemdata
    *                          The item's data
    */
    function _make_modify_item(itemid, itemdata) {
        var data;
        data = window.hex2bin(window.Protocol.ModifyItemTag);
        data += window.hex2bin(window.Protocol.ItemIdTag);
        data += window.makeBinary(itemid);
        data += window.hex2bin(window.Protocol.ItemDataTag);
        data += window.makeBinary(itemdata);
        return data;
    }
    /**
    * Build request data command for a device deleted item
    *
    * @param itemid
    *                          The id of an item
    * @param itemdata
    *                          The item's data
    * @return
    *                          The request data
    */
    function _make_delete_item(itemid) {
        var data;
        data = window.hex2bin(window.Protocol.DeleteItemTag);
        data += window.hex2bin(window.Protocol.ItemIdTag);
        data += window.makeBinary(itemid);
        return data;
    }
    /**
    * Update interested parties with progress information
    *
    * @param sofar
    *                          the amount of data received so far in the current request
    * @param length
    *                          the amount of data we are expected to receive
    * @param state
    *                          string depicting the current operation
    */
    function _update_progress(sofar, length, state) {
        var frac;

        if (_upload_attachment)
            frac = _attachments_gone / _attachments_to_go;
        else
            frac = _stored_items_count / _total_subjects;
        _update_callbacks(Math.ceil(frac * 100), length, state, Math.ceil(frac * 100));
        sofar = undefined;
    }
    /**
    * Restart a replication
    *
    */
    function _restart_replication() {
        log.info("Restarting replication");
        _reset();
        replicate(_complete_callback, _repl_info);
        _have_restarted = true;
    }
    function _authenticate(callback) {
        var fail, success, authenticator;
        authenticator = plugins.authenticator;
        if (authenticator === undefined) authenticator = plugins.authenticate;
        
        success = function() {
            log.debug("authentication success -> _restart_replication()");
            callback(true);
        };
        fail = function() {
            if (callback) {
                log.debug("authentication failed -> callback()");
                callback(false);
            } else {
                log.debug("authentication failed NO callback");
            }
        };
        try {
            log.warn("Using shell authenticator.auth");
            authenticator.auth(success, fail);
        } catch (e) {
            log.error("authentication error : " + e);
            if (callback) {
                log.error("authentication error -> callback()");
                callback();
            } else {
                log.error("authentication error NO callback");
            }
        }
    }
    /**
    * Abort a replication
    *
    */
    function abortReplication() {
        log.trace("-> abortReplication");
        if (isReplicatingNow) {
            log.error("Aborting replication");
            _reset();
            _update_callbacks(0, 0, "Aborted", 0);
            _complete_callback(window.ReplicationResult.Aborted);
        }
        log.trace("<- abortReplication");
    }
    /**
    * Recursive iterator for processing modifications
    *
    * @param processed_count
    *                          iterator index (0)
    * @param to_be_processed
    *                          list of data to process
    * @param datain
    *                          the request data accumulator
    * @param callback
    *                          callback function(data) to call when escaping the iterator, data is the accumulated data
    */
    function _modifications_loop(processed_count, to_be_processed, datain, callback) {
        var attList, attName, d1, d2, data, dataitem, date1, date2, frac, item, subject_guid, sync_data, syncid;
        function fetched(itemdata) {
            _calls_made++;
            data = _make_modify_item(syncid, itemdata) + data;
            log.info("Sending Modify: " + syncid + " (" + data.length + ")");
            _modifications_loop(processed_count, to_be_processed, data, callback);
        }
        function uploadSuccess(syncData) {
            _update_progress(0, 0, 'Storing...');
            _store_ack_item(syncid, syncData);
            _calls_made++;
            _modifications_loop(processed_count, to_be_processed, data, callback);
        }
        function uploadError(error) {
            log.debug('Error Uploading Attachment (Modification): ' + dataitem + ' Error: ' + JSON.stringify(error));
            abortReplication();
        }
        if (processed_count % 50 == 0) {
            log.debug("Searching for client-side modifications (" + processed_count + "/" + to_be_processed.length + ")");
            frac = processed_count / to_be_processed.length;
            _update_callbacks(Math.ceil(frac * 100), to_be_processed.length, "Calculating changes...", Math.ceil(frac * 100));
        }
        data = datain;
        if (processed_count >= to_be_processed.length) {
            callback(data);
        } else {
            item = to_be_processed[processed_count++];
            syncid = item.syncid;
            sync_data = item.syncdata;
            dataitem = item.dataitem;
            subject_guid = dataitem.substr(dataitem.indexOf('\\') + 1, 36);
            if (dataitem.indexOf('.') >= 0) {
                // Sync data is _meta.modified
                mc.db.getSubject(subject_guid, function(subject, error) {
                    var itemdata, new_sync_data;
                    if (error !== undefined || subject === undefined) {
                        log.error("Failed to retreive subject from db: " + dataitem);
                        _modifications_loop(processed_count, to_be_processed, data, callback);
                        return;
                    }
                    mc.db.ensureReplDataPresent(subject);
                    new_sync_data = subject._meta.syncInfo.cseq + ":" + subject._meta.syncInfo.sseq;
                    // if (debugLevel > 3) {
                    //    log.trace("subject._meta.modified = " + JSON.stringify(subject._meta.modified));
                    //    log.trace("subject._meta.syncInfo.cseq = " + subject._meta.syncInfo.cseq );
                    //    log.trace("subject._meta.syncInfo.sseq = " + subject._meta.syncInfo.sseq );
                    //    log.trace("syncid: " + syncid + ", sync data: " + sync_data + ", subj-data: " + new_sync_data);
                    // }
                    if (sync_data != new_sync_data) {
                        itemdata = _storage.get_subject_data_from_subject(subject);

                        // This covers the case that reading the subject data failed
                        // because the subject was corrupted.
                        if (itemdata !== undefined) {

                            _calls_made++;
                            data += _make_modify_item(syncid, itemdata);
                            log.debug("Sending Modify: " + syncid + " (" + data.length + ")");
                        }
                    }
                    _modifications_loop(processed_count, to_be_processed, data, callback);
                });
            } else {
                // Get attachment name
                attName = dataitem.substr(46);
                attList = mc.db.getJsonItem("attachmentList");
                if (attList !== undefined) {
                    date1 = window.parseIsoDate(sync_data);
                    date2 = attList[subject_guid][attName];
                    // if (debugLevel > 3) {
                    //     log.trace("syncid: " + syncid + ", sync data: " + d1 + ", subj-data: " + d2);
                    // }
                    console.log('modloop: ' + dataitem + 'syncdata1: ' + sync_data + ' date1: ' + date1 + ' syncdata2: ' + attList[subject_guid][attName] + ' date2: ' + date2);
                    d1 = date1.getTime();
                    d2 = date2.getTime();
                    if (d1 != d2) {
                        // get attachment data
                        if (mc.fs.availableForAtts) {
                            log.debug("Uploading Attachment (Modified): " + dataitem);
                            _update_progress(0, 0, 'Sending modified attachment... ');
                            mc.fs.uploadAttachment(subject_guid, attName, sync_data, uploadSuccess, uploadError);
                        } else {
                            mc.db.getAttachment(subject_guid, attName, fetched);
                        }
                    } else {
                        _modifications_loop(processed_count, to_be_processed, data, callback);
                    }
                } else {
                    _modifications_loop(processed_count, to_be_processed, data, callback);
                }
            }
        }
    }
    /**
    * Create commands for new subjects created on the device
    *
    * @param datain
    *                          request data already generated (new data is appended)
    * @param callback
    *                          the callback function(data) to call when complete, data is datain with new bits appended
    */
    function _build_device_created(datain, callback) {
        var data, data_list, sync_list, waiting_for;
        log.trace("-> _build_device_created");
        // var data = datain;
        var data = '';
        data_list = _storage.list(true);
        sync_list = _sync_database.list();
        waiting_for = data_list.length;
        log.debug("Searching for client-side creates...");
        if (waiting_for == 0) {
            callback(datain);
        }
        // Find newly created items on the disk
        if (data_list) {
            $.each(data_list, function(index, data_item) {
                // setTimeout(function() {
                var attachment_name, found, subject_guid;
                function fetched(itemdata, prepend) {
                    var itemid;
                    _calls_made++;
                    // This covers the case that reading the subject data failed
                    // because the subject was corrupted.
                    if (itemdata === undefined) {
                        log.warn(1, "Ignoring corrupt subject: " + data_item);

                        if (--waiting_for == 0) {
                            callback(datain + data);
                        }
                        return;
                    }

                    itemid = data_item;
                    if (prepend) {
                        data = _make_create_item(itemid, itemdata) + data;
                    } else {
                        data += _make_create_item(itemid, itemdata);
                    }
                    log.info("Sending Create: " + itemid + " (" + data.length + ")");
                    if (--waiting_for == 0) {
                        callback(datain + data);
                    }
                }
                function fetchedAppend(itemdata) {
                    fetched(itemdata, false);
                }

                function fetchedPrepend(itemdata) {
                    fetched(itemdata, true);
                }
                function uploadSuccess(syncData) {
                    _update_progress(0, 0, 'Storing...');
                    _store_ack_item(data_item, syncData);
                    if (--waiting_for == 0) {
                        callback(datain + data);
                    }
                }
                function uploadError(error) {
                    log.debug('Error Uploading Attachment (Create): ' + data_item + ' Error: ' + JSON.stringify(error));
                    abortReplication();
                }
                // Is this data_item in the sync list?
                found = sync_list.indexOf(data_item) >= 0;

                if (!found) {
                    subject_guid = data_item.substr(data_item.indexOf('\\') + 1, 36);
                    if (data_item.indexOf('.') >= 0) {
                        _storage.get_subject_data(subject_guid, fetchedAppend);
                    } else {
                        attachment_name = data_item.substring(36 + 10, data_item.length);
                        if (mc.fs.availableForAtts) {
                            log.debug("Uploading Attachment (Create): " + data_item);                            
                            _update_progress(0, 0, 'Sending new attachment...');
                            mc.fs.uploadAttachment(subject_guid, attachment_name, null, uploadSuccess, uploadError);
                        } else {
                            mc.db.getAttachment(subject_guid, attachment_name, fetchedPrepend);
                        }
                    }
                    // itemid = _sync_database.make_sync_id(data_item);
                }
                else {
                    if (--waiting_for == 0) {
                        callback(datain + data);
                    }
                }
                index = undefined;
            });
        }
        log.trace("<- _build_device_created");
    }
    /**
    * Create commands for subjects deleted on the device
    *
    * @datain
    *                          request data generated so far
    * @return
    *                          request data + deletions
    */
    function _build_device_deleted(datain, callback) {
        var data, data_list, sync_list, waiting_for;
        data = datain;
        // Find things removed from the disk
        log.debug("Searching for client-side deletes...");
        data_list = _storage.list();
        sync_list = _sync_database.list();
        waiting_for = sync_list.length;
        if (waiting_for == 0) {
            callback(data);
        }
        // For each row in the sync list
        if (sync_list) {
            $.each(sync_list, function(index, syncid) {
                var itemid, found, synced_item;
                synced_item = syncid;
                // synced_item = syncid.substring(syncid.indexOf('\\') + 1, syncid.indexOf('.'));
                // Is this synced_item in the data list?
                found = data_list.indexOf(synced_item) >= 0;
                if (!found) {
                    itemid = syncid;
                    _calls_made++;
                    data += _make_delete_item(itemid);
                    log.info("Sending Delete: " + itemid + " (" + data.length + ")");
                }
                waiting_for--;
                if (waiting_for == 0) {
                    callback(data);
                }
            });
        }
    }
    /**
    * Create commands for subjects modified on the device
    *
    * @param datain
    *                          request data already generated (new data is appended)
    * @param callback
    *                          the callback function(data) to call when complete, data is datain with new bits appended
    */
    function _build_device_modified(datainput, callback) {
        var data_list, sync_list, to_be_processed, waiting_for;
        log.debug("Searching for client-side modifications...");
        data_list = _storage.list(true);
        sync_list = _sync_database.list();
        to_be_processed = [];
        waiting_for = sync_list.length;
        if (waiting_for == 0) {
            callback(datainput);
        }
        // Find things modified on disk
        // For each row in the sync list
        if (sync_list) {
            $.each(sync_list, function(index, syncid) {
                var processed_count, sync_data, synced_item;
                synced_item = syncid;
                sync_data = _sync_database.get_sync_data(syncid);
                var data_item_idx = data_list.indexOf(synced_item);
                if (data_item_idx >= 0) {
                    to_be_processed.push({
                        dataitem: data_list[data_item_idx],
                        syncid: syncid,
                        syncdata: sync_data
                    });
                }
                if (--waiting_for == 0) {
                    processed_count = 0;
                    _modifications_loop(processed_count, to_be_processed, '', function(dataout) {
                        callback(datainput + dataout);
                    });
                }
                index = undefined;
            });
        }
    }
    /**
    * Build request data command list for changes made on the device when replicating a single subject only
    *
    * @param callback
    *                          callback function(data) to call when complete, data is the request data
    */
    function _single_item_replicate(callback) {
        var data, data_item, data_list, nothing_to_do, sync_list;
        _single_item = true;
        data = "";
        data_list = _storage.list();
        sync_list = _sync_database.list();
        data_item = 'subjects\\' + mc.db.getCurrentSubjectGuid() + '.subject';
        nothing_to_do = true;
        mc.db.getSubject(mc.db.getCurrentSubjectGuid(), function(subject, error) {
            var found, itemdata, itemid, new_sync_data, sync_data, sync_id;
            if (error !== undefined) {
                log.error("Failed to retrieve item from database: " + data_item);
            }
            // test for process zero?
            // If its not found in the sync list, then its been created
            found = false;
            $.each(sync_list, function(index, item) {
                // synced_item = this.substring(this.indexOf('\\') + 1, this.indexOf('.'));
                // synced_item = item.substring(0, item.lastIndexOf('\\')+1);
                if (data_item == item) {
                    sync_id = item;
                    found = true;
                    return false;
                }
                index = undefined;
            });
            if (!found) {
                // itemid = _sync_database.make_sync_id(data_item);
                itemid = data_item;
                itemdata = _storage.get_subject_data_from_subject(subject);
                log.debug("Sending Single Item Create: " + itemid);
                _calls_made++;
                callback(_make_create_item(itemid, itemdata));
                nothing_to_do = false;
            }
            // Check deletion - impossible?
            found = false;
            $.each(data_list, function(index, t_data_item) {
                if (data_item == t_data_item) {
                    found = true;
                    return false;
                }
                index = undefined;
            });
            if (!found) {
                itemid = data_item;
                log.debug("Should be sending Single Item Delete, but I won't: " + itemid);
                // _calls_made++;
                // callback(_make_delete_item(itemid));
                // nothing_to_do = false;
            }
            if (nothing_to_do) {
                // Check modify
                // Sync data is _meta.modified
                sync_data = _sync_database.get_sync_data(sync_id);
                if (sync_data !== undefined && sync_data.length > 0) {
                    mc.db.ensureReplDataPresent(subject);
                    new_sync_data = subject._meta.syncInfo.cseq + ":" + subject._meta.syncInfo.sseq;
                    //   if (debugLevel > 3) {
                    //    log.trace("subject._meta.modified = " + JSON.stringify(subject._meta.modified));
                    //    log.trace("subject._meta.syncInfo.cseq = " + subject._meta.syncInfo.cseq );
                    //    log.trace("subject._meta.syncInfo.sseq = " + subject._meta.syncInfo.sseq );
                    //    log.trace("syncid: " + syncid + ", sync data: " + sync_data + ", subj-data: " + new_sync_data);
                    // }
                    if (sync_data != new_sync_data) {
                        itemdata = _storage.get_subject_data_from_subject(subject);
                        log.debug("Sending Single Item Modify: " + sync_id);
                        _calls_made++;
                        callback(_make_modify_item(sync_id, itemdata));
                        nothing_to_do = false;
                    }
                }
            }
            if (nothing_to_do) {
                callback("");
            }
        });
    }
    /**
    * Build request data command list for changes made on the device
    *
    * @param callback
    *                          callback function(data) to call when complete, data is the request data
    */
    function _build_commands(callback) {
        var data;
        _start_keepalive();
        data = window.hex2bin(window.Protocol.CommandsTag);
        if (_repl_profile.type == 'normal') {
            log.debug("Started building commands");
            var before = new Date().getTime();
            _build_device_deleted(data, function(data1) {
                var afterDelete = new Date().getTime();
                log.debug("Completed deleted in " + (afterDelete - before) + "ms");
                _build_device_created(data1, function(data2) {
                    var afterCreate = new Date().getTime();                    
                    log.debug("Completed created in " + (afterCreate - afterDelete) + "ms");
                    _build_device_modified(data2, function(data3) {
                        var after = new Date().getTime();
                        log.debug("Completed modified in " + (after - afterCreate) + "ms");
                        log.debug("Completed all in " + (after - before) + "ms");
                        log.debug("Completed building commands (" + data3.length + ")");
                        callback(data3);
                        _stop_keepalive();
                    });                   
                });
            });
        } else {
            _single_item_replicate(function(dataout) {
                data += dataout;
                callback(data);
                _stop_keepalive();
            });
        }
    }

    function _get_server_changes(callback) {
        _send_only_part = false;

        var data;
        // Request Tag:
        data = window.hex2bin(window.Protocol.ReplicateRequestTag);
        // Replicate options:
        data += window.hex2bin(window.Protocol.GetServerChangesTag);
        data += window.hex2bin(window.Protocol.MaxNumCommandsTag);
        data += window.fromInteger(_chunk_size);
        // Sync List:
        data += _encode_sync_list();
        _queue_request(data);
        log.debug("Sending Get Server Changes... (" + data.length + ")");
        _update_progress(0, 0, "Waiting for server changes...");
        callback();
    }

    /**
    * Build and queue a replication request
    *
    * @param callback
    *                          the callback to call when complete
    */
    function _send_replicate_request(callback) {
        _send_only_part = true;

        var data;
        // Request Tag:
        data = window.hex2bin(window.Protocol.ReplicateRequestTag);
        // Replicate options:
        // data += window.hex2bin(window.Protocol.GetServerChangesTag);
        data += window.hex2bin(window.Protocol.MaxNumCommandsTag);
        data += window.fromInteger(_chunk_size);
        // Sync List:
        data += _encode_sync_list();
        _update_progress(0, 0, "Calculating changes...");
        // Commands to send:
        _build_commands(function(data1) {
            data += data1;
            _queue_request(data);
            log.debug("Sending Replicate Request... (" + data.length + ")");
            _update_progress(0, 0, "Waiting for server...");
            callback();
        });
    }
    /**
    * Count how many attachments need to be uploaded.
    *
    * @param callback
    *                          the callback to call when complete
    */
    function _count_attachments_to_send() {
        var count = 0;
        var data_list = _storage.listofAttachments();
        var sync_list = _sync_database.list();

        $.each(data_list, function(index, data_item) {

            // Is this data_item in the sync list?
            found = false;
            // For each row in the sync list
            if (sync_list) {
                $.each(sync_list, function(index, item) {
                    var synced_item;
                    synced_item = item;

                    if (data_item == synced_item) {
                        found = true;
                        return false;
                    }
                    index = undefined;
                });
            }
            if (!found) {
                count++;
            }
        });

        return count;
    }

    /**
    * Build and queue a replication request that sends attachments
    *
    * @param callback
    *                          the callback to call when complete
    */
    function _send_attachments_replicate_request(callback) {
        var data, found, data_list, sync_list, subject_guid, attachment_name, nothingToDo;

        nothingToDo = true;

        // Request Tag:
        data = window.hex2bin(window.Protocol.ReplicateRequestTag);
        // Dont put server changes Tag

        // Create new commands
        data += window.hex2bin(window.Protocol.CommandsTag);

        data_list = _storage.listofAttachments();
        sync_list = _sync_database.list();

        if (typeof data_list === 'undefined')
            callback();

        $.each(data_list, function(index, data_item) {

            function fetched(itemdata) {
                var itemid;
                _calls_made++;
                // This covers the case that reading the subject data failed
                // because the subject was corrupted.
                if (itemdata === undefined) {
                    // Parameter dictates whether there is more work to do in here
                    return false;
                }

                itemid = data_item;

                data += _make_create_item(itemid, itemdata);

                log.debug(1, "Sending Create (Attachment): " + itemid + " (" + data.length + ")");
                _queue_request(data);

                callback();
                return false;
            }
            
            function uploadSuccess(syncData) {
                _calls_made++; // only ever written to
                _update_progress(0, 0, 'Storing...');
                _store_ack_item(data_item, syncData);
                _attachments_gone++;                                        
                _update_progress(_attachments_gone, _attachments_to_go, "Uploaded " + _attachments_gone + "/" + _attachments_to_go + " attachments");
                _send_attachments_replicate_request(callback);
                return false;
            }
            
            function uploadError(error) {
                log.debug('Error Uploading Attachment (Create): ' + data_item + ' Error: ' + JSON.stringify(error));
                abortReplication();
            }

            // Is this data_item in the sync list?
            found = false;
            // For each row in the sync list
            if (sync_list) {
                $.each(sync_list, function(index, item) {
                    var synced_item;
                    synced_item = item;

                    if (data_item == synced_item) {
                        found = true;
                        return false;
                    }
                    index = undefined;
                });
            }
            if (!found) {
                subject_guid = data_item.substr(data_item.indexOf('\\') + 1, 36);
                attachment_name = data_item.substring(36 + 10, data_item.length);
                
                if (mc.fs.availableForAtts) {
                    log.debug("Uploading Attachment (Create): " + data_item);
                    _update_progress(0, 0, 'Sending attachment ' + (_attachments_gone + 1) + ' of ' + _attachments_to_go + '...');
                    mc.fs.uploadAttachment(subject_guid, attachment_name, null, uploadSuccess, uploadError);
                } else {
                    mc.db.getAttachment(subject_guid, attachment_name, fetched);
                }
                nothingToDo = false;
                return false;
            }
        });

        // Didn't find any new attachments, start the normal replication process
        if (nothingToDo) {
            _upload_attachment = false;
            _send_replicate_request(callback);
        }
    }
    /**
    * Process a start session response
    *
    * @param reader
    *                          the protocol reader
    * @param callback
    *                          callback function to call when completed
    */
    function _read_start_session(reader, callback) {
        var cont, context, err, nodes, tag, xml;
        log.trace("-> _read_start_session");
        tag = reader.readTag();
        if (tag == window.Protocol.ErrorTag) {
            // Read error
            err = reader.readString();
            abortReplication();
            log.error(err);
            return;
        }
        _session_running = true;
        // Read Context
        context = reader.readBinary();
        context = window.removeBOM(context);
        log.trace("Context Read: " + context);
        xml = (new window.DOMParser()).parseFromString(context, "text/xml");
        // cont = $(xml).find('CDRContext continue')[0].textContent;
        cont = $(xml).find('CDRContext continue').text();
        nodes = $(xml).find('CDRContext > *');
        $(nodes).each(function() {
            var node;
            node = this;
            mc.fl.setenvironment(node.tagName, node.textContent);
        });
        if (_logon_Session === true) {
            // call callback to ensure outstanding requests are cleared
            _send_end_session();
            _logon_Session = false;
            callback();
            return;
        }

        _attachments_to_go = _count_attachments_to_send();
        _attachments_gone = 0;

        _upload_attachment = true;
        _send_attachments_replicate_request(callback);

        // Graham - put this code in _send_attachments_replicate_request
        // _send_replicate_request(callback);

        log.trace("<- _read_start_session");
    }
    /**
    * Process a deletion acknowledgement
    *
    * @param reader
    *                          the protocol data reader object
    */
    function _ack_delete_item(reader) {
        var itemid, itemidtag, str, tag;
        log.trace("-> _ack_delete_item");
        itemidtag = reader.readTag(); // 54
        itemid = reader.readBinary();
        log.debug("Delete of " + itemid + " acknowledged:");
        _acked_calls++;
        tag = reader.peekTag();
        if (tag == window.Protocol.ErrorTag) {
            reader.readTag();
            str = reader.readString();
            log.error("Server has failed to delete: " + str);
            return false;
        }
        _sync_database.remove(itemid);
        //if( mc.replstore.is_attachment(itemid) ) {
        //    subjectGuid = mc.replstore.split_attachment_id(itemid).subjectGuid;
        //    attName = mc.replstore.split_attachment_id(itemid).attachmentName;
        //    mc.replstore.delete_attachment_date(subjectGuid, attName);
        //}
        log.debug("Server has removed:  " + itemid);
        return false;
        log.trace("<- _ack_delete_item");
    }
    /**
    * Process a modification acknowledgement
    *
    * @param reader
    *                          the protocol data reader object
    */
    function _ack_modify_item(reader) {
        var itemid, itemidtag, str, syncdata, tag;
        log.trace("-> _ack_modify_item");
        itemidtag = reader.readTag(); // 54
        itemid = reader.readBinary();
        log.debug("Modification of " + itemid + " acknowledged:");
        _acked_calls++;
        tag = reader.peekTag();
        if (tag == window.Protocol.ErrorTag) {
            reader.readTag();
            str = reader.readString();
            log.error("Server has failed to modify: " + str);
            return false;
        }
        if (tag == window.Protocol.SyncDataTag) {
            reader.readTag();
            syncdata = reader.readBinary();
            _store_ack_item(itemid, syncdata);
            log.debug("Server has modified:  " + itemid + ": " + syncdata);
        }
        log.trace("<- _ack_modify_item");
        return false;
    }
    /**
    * Process a creation acknowledgement
    *
    * @param reader
    *                          the protocol data reader object
    */
    function _ack_create_item(reader) {
        var itemid, itemidtag, str, syncdata, tag;
        log.trace("-> _ack_create_item");
        itemidtag = reader.readTag(); // 54
        itemid = reader.readBinary();
        log.debug("Creation of " + itemid + " acknowledged:");
        _acked_calls++;
        tag = reader.peekTag();
        if (tag == window.Protocol.ErrorTag) {
            reader.readTag();
            str = reader.readString();
            log.error("Server has failed to create: " + str);
            return false;
        }
        if (tag == window.Protocol.SyncDataTag) {
            reader.readTag();
            syncdata = reader.readBinary();
            _store_ack_item(itemid, syncdata);
            log.debug("Server has created:  " + itemid + ": " + syncdata);
        }
        log.trace("<- _ack_create_item");
        return false;
    }
    /**
    * Stores an item acknowledgement
    *
    * @param itemid
    *                          the item id 
    * @param syncdata
    *                          the sync data 
    */
    function _store_ack_item(itemid, syncdata) {
        log.trace('-> _store_ack_item: ' + JSON.stringify([itemid, syncdata]));
        var split;
        _sync_database.add(itemid, syncdata);
        if (mc.replstore.is_attachment(itemid)) {
            split = mc.replstore.split_attachment_id(itemid);
            mc.replstore.store_attachment_date(split.subjectGuid, split.attachmentName, syncdata);
        }
    }
    /**
    * Process acknowledgements from the server
    *
    * @param reader
    *                          the protocol data reader object
    */
    function _read_acks(reader) {
        var stop, tag;
        log.trace("-> _read_acks");
        reader.readTag(); // Acks tag (ignore) 20
        stop = false;
        while (!stop) {
            tag = reader.peekTag();
            switch (tag) {
                case window.Protocol.ItemCreatedTag:
                    reader.readTag();
                    stop = _ack_create_item(reader);
                    break;
                case window.Protocol.ItemModifiedTag:
                    reader.readTag();
                    stop = _ack_modify_item(reader);
                    break;
                case window.Protocol.ItemDeletedTag:
                    reader.readTag();
                    stop = _ack_delete_item(reader);
                    break;
                default:
                    stop = true;
                    break;
            }
        }
        log.trace("<- _read_acks");
    }
    /**
    * queue an acknowledgement for the server
    *
    * @param itemid
    *                          the id of the item to ack
    * @param tag
    *                          the type of request we are acknowleging (create/mod/del)
    */
    function _queue_ack(itemid, tag) {
        var data, item;
        data = {};
        data.itemid = itemid;
        data.tag = tag;
        _ack_queue.push(data);
        if ((_request_queue.length === 0) && (_ack_queue.length > 50)) {
            data = window.hex2bin(window.Protocol.ReplicateRequestTag);
            data += window.hex2bin(window.Protocol.AcknowledgementsTag);
            while (_ack_queue.length > 0) {
                item = _ack_queue.shift();
                data += _make_ack_item(item.itemid, item.tag);
            }
            _queue_request(data, true);
        }
        _pump_request_queue();
    }
    /**
    * Send an failed acknowledgement to the server
    *
    * @param itemid
    *                          the id of the item to ack
    * @param tag
    *                          the type of request we are acknowleging (create/mod/del)
    * @param message
    *                          error message to send to the server
    */
    function _send_fail_ack(itemid, tag, message) {
        var data;
        data = window.hex2bin(window.Protocol.ReplicateRequestTag);
        data += window.hex2bin(window.Protocol.AcknowledgementsTag);
        data += window.hex2bin(tag);
        data += window.hex2bin(window.Protocol.ItemIdTag);
        data += window.makeBinary(itemid);
        data += window.hex2bin(window.Protocol.ErrorTag);
        data += window.makeBinary(window.encode_utf8(message));
        log.debug("Sending failed ack for " + itemid);
        _queue_request(data);
    }
    /**
    * Process a deletion request
    *
    * @param reader
    *                          the protocol data reader object
    */
    function _delete_item(reader) {
        var itemid, itemidtag;
        log.trace("-> _delete_item");
        itemidtag = reader.readTag(); // 54
        itemid = reader.readBinary();
        log.info("Server wants to delete: " + itemid);
        _waiting_on_storage++;
        _storage.queue_delete_data(itemid, function(error) {
            _waiting_on_storage--;
            if (error === undefined) {
                _sync_database.remove(itemid);
                _queue_ack(itemid, window.Protocol.ItemDeletedTag);
                log.info("Deleted: " + itemid);
            } else {
                log.error("Failed to delete: " + itemid + " : " + error);
                _send_fail_ack(itemid, window.Protocol.ItemDeletedTag, error);
                if (_single_item == true) {
                    abortReplication();
                }
            }
        });
        return false;
    }
    /**
    * Send an request for subject data to the server
    *
    * @param itemid
    *                          the id of the item to ack
    * @param tag
    *                          the reason we are requesting the data (create/mod)
    */
    function _send_request_data(itemid, tag) {
        var data;
        if (mc.replstore.is_attachment(itemid) && mc.fs.availableForAtts) {
            _download_queue.push({itemid: itemid, tag: tag});
            _pump_download_queue();
        } else {
            _retrieval_queue[itemid] = tag;
            // Request Tag
            data = window.hex2bin(window.Protocol.RetrieveRequestTag);
            data += window.hex2bin(window.Protocol.ItemIdTag);
            data += window.makeBinary(itemid);
            log.debug("Sending data request for " + itemid);
            _calls_made++;
            _queue_request(data);
        }        
    }
    /**
    * Process a creation request
    *
    * @param reader
    *                          the protocol data reader object
    */
    function _create_item(reader) {
        var itemdata, itemid, itemidtag, syncdata, tag;
        log.trace("-> _create_item");
        itemidtag = reader.readTag(); // 54
        itemid = reader.readBinary();
        syncdata = "";
        itemdata = "";
        log.info("Server wants to create: " + itemid);
        tag = reader.peekTag();
        if (tag == window.Protocol.SyncDataTag) {
            reader.readTag();
            syncdata = reader.readBinary();
            reader.readTag();
            itemdata = reader.readBinary();
            _acked_calls++;
            _waiting_on_storage++;
            _storage.queue_set_data(itemid, itemdata, syncdata, function(error) {
                _waiting_on_storage--;
                if (error === undefined) {
                    _sync_database.add(itemid, syncdata);
                    _queue_ack(itemid, window.Protocol.ItemCreatedTag);
                    log.info("Created: " + itemid);
                } else {
                    log.error("Failed to create: " + itemid + " : " + error);
                    _send_fail_ack(itemid, window.Protocol.ItemCreatedTag, error);
                    // Need to get rid of this subject, if it is on the device.
                    // TODO
                    if (_single_item == true) {
                        abortReplication();
                    }
                }
            });
        }
        else {
            _send_request_data(itemid, window.Protocol.ItemCreatedTag);
            return false;
        }
    }
    /**
    * Process a modification request
    *
    * @param reader
    *                          the protocol data reader object
    */
    function _modify_item(reader) {
        var itemdata, itemid, itemidtag, syncdata, tag;
        log.trace("-> _modify_item");
        itemidtag = reader.readTag(); // 54
        itemid = reader.readBinary();
        syncdata = "";
        itemdata = "";
        log.info("Server wants to modify: " + itemid);
        tag = reader.peekTag();
        if (tag == window.Protocol.SyncDataTag) {
            reader.readTag();
            syncdata = reader.readBinary();
            reader.readTag();
            itemdata = reader.readBinary();
            _acked_calls++;
            _waiting_on_storage++;
            _storage.queue_set_data(itemid, itemdata, syncdata, function(error) {
                _waiting_on_storage--;
                if (error === undefined) {
                    _sync_database.add(itemid, syncdata);
                    _queue_ack(itemid, window.Protocol.ItemCreatedTag);
                    log.info("Modified: " + itemid);
                } else {
                    log.error("Failed to modify: " + itemid + " : " + error);
                    _send_fail_ack(itemid, window.Protocol.ItemCreatedTag, error);
                    if (_single_item == true) {
                        abortReplication();
                    }
                }
            });
        }
        else {
            _send_request_data(itemid, window.Protocol.ItemModifiedTag);
            return false;
        }
    }
    /**
    * Process commands from the server
    *
    * @param reader
    *                          the protocol data reader object
    */
    function _read_commands(reader) {
        var commandCount, stop, tag;
        log.trace("-> _read_commands");
        commandCount = 0; 
        _storage.set_command_count(0);
        reader.readTag(); // Comms tag (ignore)
        stop = false;
        while (!stop) {
            tag = reader.peekTag();
            switch (tag) {
                case window.Protocol.CreateItemTag:
                    reader.readTag();
                    stop = _create_item(reader);
                    break;
                case window.Protocol.ModifyItemTag:
                    reader.readTag();
                    stop = _modify_item(reader);
                    break;
                case window.Protocol.DeleteItemTag:
                    reader.readTag();
                    stop = _delete_item(reader);
                    break;
                default:
                    stop = true;
                    break;
            }
            commandCount++;
        }
        _storage.set_command_count(commandCount - 1); // command count - 1 because of additional increment in switch loop above
        log.trace("<- _read_commands");
        return commandCount;
    }
    /**
    * Called when a request to start a replication session successfully completes
    *
    * @param reader
    *                          the protocol data reader object
    * @param callback
    *                          callback function() to call when complete
    */
    function _read_replicate_response(reader, callback) {
        var commandCount, dataLeft, str, tag;
        log.trace("-> _read_replicate_response");
        tag = reader.peekTag();
        log.debug("Reading replicate response:" + tag);
        if (tag == window.Protocol.ErrorTag) {
            reader.readTag();
            str = reader.readString();
            abortReplication();
            log.error("Error reading replicate response: " + str);
            return;
        }
        if (tag == window.Protocol.AcknowledgementsTag) {
            log.trace("Reading acks...");
            _read_acks(reader);

            // If we are in upload attachment mode then go back and try to send the next attachment.
            if (_upload_attachment) {
                _attachments_gone++;
                _update_progress(_attachments_gone, _attachments_to_go, "Uploaded " + _attachments_gone + "/" + _attachments_to_go + " attachments");
                _send_attachments_replicate_request(callback);
                return;
            }

            // If we are in send only mode then start the get server changes replication
            if (_send_only_part) {
                _get_server_changes(callback);
                return;
            }
        }
        tag = reader.peekTag();
        if (tag == window.Protocol.EndSessionRequestTag) {
            if (_send_only_part) {
                _get_server_changes(callback);
                return;
            }
        }
        tag = reader.peekTag();
        commandCount = 0;
        if (tag == window.Protocol.CommandsTag) {
            log.trace("Reading commands...");
            commandCount = _read_commands(reader);
        }

        tag = reader.peekTag();
        if (tag == window.Protocol.MoreAvailableTag) {
            _request_more = 0;
            reader.readTag();
            dataLeft = reader.readInteger();
            log.debug("There are more subjects to retrieve: " + dataLeft);
            _request_more = dataLeft;
            if (_total_subjects == 0) {
                _total_subjects = dataLeft + _chunk_size;
            }
        }
        if (_total_subjects == 0) {
            _total_subjects = commandCount;
        }
        callback();
        log.trace("<- _read_replicate_response");
    }

    /**
    * Called when a request to retrieve a subject successfully completes
    *
    * @param reader
    *                          the protocol data reader object
    * @param callback
    *                          callback function() to call when complete
    */
    function _read_retrieve_response(reader, callback) {
        var err, itemdata, itemdatalength, itemdatatag, itemid, itemidtag, syncdata, syncdatatag, tag;
        itemidtag = reader.readTag(); // 54
        itemid = reader.readBinary();
        tag = reader.peekTag();
        if (tag == window.Protocol.ErrorTag) {
            // Read error
            reader.readTag();
            err = reader.readString();
            abortReplication();
            log.error("Error reading retrieve response: " + err);
        }
        else {
            syncdatatag = reader.readTag(); // 56
            syncdata = reader.readBinary();
            itemdatatag = reader.readTag(); // 53
            itemdata = reader.readBinary();
            itemdatalength = itemdata.length;
            log.debug("Retrieved: " + itemid + ": " + syncdata);
            _acked_calls++;
            _waiting_on_storage++;
            _storage.queue_set_data(itemid, itemdata, syncdata, function(error) {
                _waiting_on_storage--;
                _update_progress(0, 0, "Stored");
                if (error === undefined) {
                    _sync_database.add(itemid, syncdata);
                    _queue_ack(itemid, _retrieval_queue[itemid]);
                    log.debug("Created: " + itemid + ": " + syncdata);
                }
                else {
                    _send_fail_ack(itemid, _retrieval_queue[itemid], error);
                    //                    if( _single_item == true ) {
                    //                        abortReplication();
                    //                    }
                }
            });
            callback();
        }
        log.trace("<- _read_retrieve_response");
    }
    function _read_fast_lookup_response(reader, callback) {
        var itemdata, itemdataTag, itemid, str, syncdata, tag;
        log.debug("Reading fast lookup response...");
        tag = reader.readTag(); // 54
        itemid = reader.readBinary();
        if (tag == window.Protocol.ErrorTag) {
            reader.readTag();
            str = reader.readString();
            abortReplication();
            log.error("Error reading fast lookup response: " + str);
            return;
        }
        syncdata = "";
        itemdata = "";
        log.info("Server wants to modify: " + itemid);
        itemdataTag = reader.readTag();
        itemdata = reader.readBinary();
        _acked_calls++;
        _waiting_on_storage++;
        _storage.set_data(undefined, itemid, itemdata, '', function(error) {
            _waiting_on_storage--;
            if (error === undefined) {
                log.info("Fast lookup finished: " + itemid);
                callback();
            } else {
                log.error("Failed to fast lookup: " + itemid + " : " + error);
                _end_session();
                callback();
            }
        });
    }
    /**
    * Process the contents of a request reponse
    *
    * @param request
    *                          The request event
    * @param callback
    *                          callback function() to call when complete
    */
    function _receive_message(request, callback) {
        var reader, response, tag;
        // log.trace("-> _receive_message");
        if (!isReplicatingNow) {
            return;
        }
        try {
            if (request.status != 200) {
                if (isReplicatingNow) {
                    log.error("Request Response: " + request.status);
                    if (request.status == 409 && !_have_restarted) {
                        _restart_replication();
                    } else if (request.status == 401) {
                        _authenticate(function(success) {
                            if (success)
                                _restart_replication();
                            else
                                callback();
                        });
                    } else if (request.status == 403) {
                        _authenticate(function(success) {
                            if (success)
                                _restart_replication();
                            else
                                callback();
                        });
                    } else {
                        log.error("status: " + request.status);
                        log.error("responseText: " + request.responseText);
                        if (!_have_restarted) {
                            _restart_replication();
                        }
                    }
                    return;
                }
                callback();
                return;
            }
            response = request.responseText;
            if (response.length === 0) {
                if (_session_running == true) {
                    callback();
                }
                return;
            }

            // Add this in for WP8            
            if (request.getResponseHeader('Transfer-Encoding') === 'base64') {
                response = atob(response);
            }

            log.trace("Response length: " + response.length);

            reader = new window.CTBinaryReader(response);
            tag = reader.readTag();
            switch (tag) {
                case window.Protocol.EndSessionResponseTag:
                    _end_session();
                    _session_running = false;
                    callback();
                    break;
                case window.Protocol.StartSessionResponseTag:
                    _read_start_session(reader, callback);
                    break;
                case window.Protocol.ReplicateResponseTag:
                    _read_replicate_response(reader, callback);
                    break;
                case window.Protocol.RetrieveResponseTag:
                    _read_retrieve_response(reader, callback);
                    break;
                case window.Protocol.KeepAliveResponseTag:
                    log.info("Ignoring Keep-alive Response");
                    // callback();
                    break;
                case window.Protocol.FastLookupResponseTag:
                    _read_fast_lookup_response(reader, callback);
                    break;
                default:
                    throw ("Unknown Tag: " + tag);
                    //break;
            }
        }
        catch (e) {
            abortReplication();
            log.error("Failed Receiving Response: " + e);
        }
        log.trace("<- _receive_message");
    }
    /**
    * Callback function for receiving http responses
    *
    * @param evt
    *                          The request event
    */
    function _reset_timeout() {
        log.trace("-> _reset_timeout");
        window.clearTimeout(_timeout_id);
        _timeout_id = window.setTimeout(function() {
            log.error("Replication timeout reached (" + _repl_info.timeout + ")");
            _timeoutReplication();
        }, _repl_info.timeout * 1000 );
    }
    function _receive_response(request) {
        log.trace("-> _receive_response");
        log.debug("Response Received.  Outstanding requests: " + _outstanding_requests.length);
        // reset timeout
        _reset_timeout();

        var req;
        req = _outstanding_requests.indexOf(request);
        _outstanding_requests.splice(req, 1);

        _receive_message(request, function() {
            req = null;
            _pump_request_queue();
        });
        log.trace("<- _receive_response");
    }
    /**
    * Sends a request
    *
    * @param data
    *                          The request data
    */
    function _receive_state_change(req) {
        var state;
        log.trace("-> _receive_state_change");
        //log.trace( "State: " + evt.target.readyState);
        //log.info(evt.target.getAllResponseHeaders());

        state = "?";
        switch (req.readyState) {
            case 0:
                state = "Initialising";
                break;
            case 1:
                state = "Sending";
                break;
            case 2:
                state = "Sent";
                break;
            default:
                return;
        }
        //_update_progress(0, 0, state);
        log.trace("<- _receive_state_change");
    }
    /**
    * Sends a request
    *
    * @param data
    *                          The request data
    */
    function _send_request(input) {
        var _profile_complete;
        var encodedData;
        var finished = false;
        var time = new Date().getTime();

        var _dloaded = 0;
        var _dltotal = 0;

        function loaded() {
            //log.trace( "Loaded.  State: " + evt.target.readyState);
            //log.trace( "Headers: " + evt.target.getAllResponseHeaders());			
            finished = true;
            if (_dltotal < 4096) {
                _update_progress(_dltotal, _dltotal, "Downloaded");
            } else {
                _update_progress(_dltotal, _dltotal, "Downloaded... (" + Math.ceil(_dltotal / 1024) + "k of " + Math.ceil(_dltotal / 1024) + "k)");
            }
            if (_profile_complete) {
                _profile_complete();
                _profile_complete = undefined;
            }
            _receive_response(this);
        }
        function progress(evt) {
            _dloaded = evt.loaded;
            _dltotal = evt.total;
        }
        function readyStateChange() {
            _receive_state_change(this);
        }
        function onError() {
            log.error("Aborted replication due to error connection: ");
            finished = true;
            abortReplication();
        }
        function onTimeout(evt) {
            log.error("XHR Timeout");
        }

        function onProgressTimeout() {
            if (!finished) {
                setTimeout(onProgressTimeout, 500);

                if (_dloaded == 0) {
                    if (!_upload_attachment)
                        _update_progress(_dloaded, _dltotal, "Waiting for server..");
                } else if ((new Date().getTime()) - time > 500) {
                    _update_progress(_dloaded, _dltotal, "Downloading... (" + Math.ceil(_dloaded / 1024) + "k of " + Math.ceil(_dltotal / 1024) + "k)");
                } else {
                    _update_progress(_dloaded, _dltotal, "Downloading...");
                }
            }
        }

        function send() {
            var request, user;
            try {
                user = mc.db.getUserInfo();
                request = new XMLHttpRequest();
                if (user.mSuiteSerialNo == 0) {
                    request.open("POST", _url + "/CommonTime-Data-Replication?uniq=" + Math.random(), true);
                } else {
                    request.open("POST", _url + "/CommonTime-Data-Replication?mcid=" + user.mSuiteSerialNo + '&uniq=' + Math.random(), true);
                }
                request.onprogress = progress;
                request.onload = loaded;
                request.onreadystatechange = readyStateChange;
                request.onerror = onError;
                request.ontimeout = onTimeout;
                request.setRequestHeader("Content-Type", "application/x-commontime-data-replication-1.0");
                if ($.isIE) {
                    request.setRequestHeader("X-Accept-Encoding", "base64");
                } else {
                request.overrideMimeType("text/plain; charset=x-user-defined");
                }
                _outstanding_requests.push(request);
                log.debug("Sending request, outstanding requests: " + _outstanding_requests.length + ", storage requests outstanding: " + _waiting_on_storage);
                request.send(encodedData);
                setTimeout(onProgressTimeout, 100);				
            }
            catch (e) {
                abortReplication();
                log.error("Failed during send_request: " + e);
            }
        }
        encodedData = window.encode_base64(input);
        mc.profiler.profileAsync('replicator server request', function(profileComplete) {
            _profile_complete = profileComplete;
            send(encodedData);
        });
    }
    /**
    * Send the next request in the queue, or send end session if there is nothing to do
    *
    */
    function _execute_next_request() {
        var data, item;
        log.trace("-> _execute_next_request");
        if (debugLevel > 3) {
            log.trace('isReplicatingNow: ' + isReplicatingNow);
            log.trace('_session_ended: ' + _session_ended);
            log.trace('_request_queue.length: ' + _request_queue.length);
            log.trace('_outstanding_requests.length: ' + _outstanding_requests.length);
            log.trace('_waiting_on_download: ' + _waiting_on_download);
            log.trace('_waiting_on_storage: ' + _waiting_on_storage);
        }
        if (isReplicatingNow && !_session_ended && _request_queue.length == 0 && _outstanding_requests.length == 0 && _waiting_on_download == 0 && _waiting_on_storage == 0) {
            if (_request_more > 0) {
                log.debug("Continuing replication of " + _request_more + " more subjects");
                _request_more = 0;
                data = window.hex2bin(window.Protocol.ReplicateRequestTag);
                data += window.hex2bin(window.Protocol.ShouldContinueTag);
                _queue_request(data, true);
            } else if (_fast_lookup) {
                _end_session();
            } else if (_second_stage) {
                _send_end_session();
            } else {
                _second_stage = true;

                log.info("Re-validating");
                _update_progress(0, 0, "Validating subjects...");

                var startedValidating = new Date();
                _storage.validateSubjects(function(errors, stop) {
                    var finishedValidating = new Date();

                    var timeDifference = (finishedValidating.getTime() - startedValidating.getTime()) / 1000;
                    log.info("Time taken to validate: " + timeDifference);
                    localStorage.timeTakenToValidate = timeDifference;

                    if (stop !== undefined && stop === true) {
                        abortReplication(ReplicationResult.UnrecoverableError);
                        return;
                    }

                    log.debug("Starting secondary replication...");
                    // Start the 'second replication' to fix the server side inadequacy
                    data = window.hex2bin(window.Protocol.ReplicateRequestTag);
                    data += window.hex2bin(window.Protocol.GetServerChangesTag);
                    data += _encode_sync_list();
                    data += window.hex2bin(window.Protocol.AcknowledgementsTag);
                    while (_ack_queue.length > 0) {
                        item = _ack_queue.shift();
                        data += _make_ack_item(item.itemid, item.tag);
                    }
                    _queue_request(data, true);
                    if (!_upload_attachment)
                        _update_progress(0, 0, "Waiting for server....");
                }, false);
            }
        }
        if (_request_queue.length > 0) {
            data = _request_queue.shift();
            _send_request(data);
        }
        log.trace("<- _execute_next_request");
    }
    /**
    * Start keepalive
    *
    */
    function _start_keepalive() {
        log.debug("Starting Keepalive");
        window.clearTimeout(_keepalive_id);
        _keepalive_id = window.setTimeout(function() {
            var data;
            log.debug("Sending Keepalive");
            data = window.hex2bin(window.Protocol.KeepAliveRequestTag);
            _queue_request(data, true);
            _pump_request_queue();
            _start_keepalive();
        }, 30 * 1000);
    }
    function _stop_keepalive() {
        log.debug("Stopping Keepalive");
        window.clearTimeout(_keepalive_id);
    }
    function _createInternalContext() {
        var contextXml;
        // Create the internal context 
        contextXml = "<context>";
        $.each(_repl_profile.context, function(name, value) {
            contextXml += '<' + name + '>';
            if (value.substr(0, 1) == '$') {
                value = mc.fl.getenvironment(value.substr(1));
            }
            contextXml += value;
            contextXml += '</' + name + '>';
        });
        contextXml += "</context>";
        return contextXml;
    }
    function _send_fast_lookup_request() {
        var Application_Id_Guid_data, contextXml, data, item_id, user, binaryFileSystem;
        // Frig the app_id
        Application_Id_Guid_data = window.hex2bin(_Application_Id.replace(/-/g, ""));
        // Request Tag
        data = window.hex2bin(window.Protocol.FastLookupRequestTag);
        // Application Id
        data += window.hex2bin(window.Protocol.ApplicationIdTag);
        data += Application_Id_Guid_data;
        user = mc.db.getUserInfo();
        binaryFileSystem = mc.fs.availableForAtts ? 'true' : 'false';
        contextXml = _createInternalContext();
        seclog.trace("Internal context to send: " + contextXml);
        item_id = 'subjects\\' + mc.db.getCurrentSubjectGuid() + '.subject';
        mc.db.getSubject(mc.db.getCurrentSubjectGuid(), function(subject, error) {
            var context, context_raw, dataitem, itemdata;
            if (error !== undefined) {
                log.error("Failed to retreive subject from db: " + dataitem);
                abortReplication();
                return;
            }
            // Context
            context_raw = "<?xml version=\"1.0\" encoding=\"utf-8\"?><CDRContext>";
            context_raw += "<DefaultUserName>" + user.mSuiteUserName + "</DefaultUserName>";
            context_raw += "<ReplicationType>" + _repl_profile.type + "</ReplicationType>";
            context_raw += "<Capabilities><clienttype>html</clienttype><CapabilityFlags><binaryfilesystem>" + binaryFileSystem + "</binaryfilesystem></CapabilityFlags></Capabilities>";
            context_raw += "<CDRReplicationProfileContext>";
            context_raw += window.encode_base64(contextXml);
            context_raw += "</CDRReplicationProfileContext>";
            context_raw += "</CDRContext>";
            seclog.trace("External context to send: " + context_raw);
            context = window.encode_utf8(context_raw);
            data += window.hex2bin(window.Protocol.ContextTag);
            data += window.fromInteger(context.length);
            data += context;
            itemdata = _storage.get_subject_data_from_subject(subject);
            data += window.hex2bin(window.Protocol.ItemIdTag);
            data += window.makeBinary(item_id);
            data += window.hex2bin(window.Protocol.ItemDataTag);
            data += window.makeBinary(itemdata);
            log.debug("Sending fast lookup... (" + data.length + ")");
            _queue_request(data);
        });
    }
    /**
    * Build and queue the start session request
    *
    */
    function _send_start_session() {
        var Application_Id_Guid_data, context, context_raw, contextXml, data, user, binaryFileSystem;
        // Frig the app_id
        Application_Id_Guid_data = window.hex2bin(_Application_Id.replace(/-/g, ""));
        // Request Tag
        data = window.hex2bin(window.Protocol.StartSessionRequestTag);
        // Application Id
        data += window.hex2bin(window.Protocol.ApplicationIdTag);
        data += Application_Id_Guid_data;
        user = mc.db.getUserInfo();
        binaryFileSystem = mc.fs.availableForAtts ? 'true' : 'false';
        contextXml = _createInternalContext();
        seclog.trace("Internal context to send: " + contextXml);
        // Context
        context_raw = "<?xml version=\"1.0\" encoding=\"utf-8\"?><CDRContext>";
        context_raw += "<DefaultUserName>" + user.mSuiteUserName + "</DefaultUserName>";
        context_raw += "<ReplicationType>" + _repl_profile.type + "</ReplicationType>";
        context_raw += "<Capabilities><clienttype>html</clienttype><CapabilityFlags><binaryfilesystem>" + binaryFileSystem + "</binaryfilesystem></CapabilityFlags></Capabilities>";
        context_raw += "<CDRReplicationProfileContext>";
        context_raw += window.encode_base64(contextXml);
        context_raw += "</CDRReplicationProfileContext>";
        context_raw += "</CDRContext>";
        seclog.trace("External context to send: " + context_raw);
        context = window.encode_utf8(context_raw);
        data += window.hex2bin(window.Protocol.ContextTag);
        data += window.fromInteger(context.length);
        data += context;
        if (_repl_profile.type === 'login') {
            _logon_Session = true;
        }
        log.debug("Sending start session... (" + data.length + ")");

        // Clear session		
        mc.db.setCookie("session-id", null);

        _queue_request(data);
    }
    // Public functions --------------------------------------------------------------
    /**
    * Return true if replicating
    *
    *
    */
    function isReplicating() {
        return isReplicatingNow;
    }
    /**
    * Subscribe to notifications coming from the server (experimental)
    *
    * @param notify_callback
    *                  callback function to receive notification on
    */
    function subscribeNotify(notify_callback) {
        if (typeof notify_callback != "function") {
            throw "Callback must be a function: function( status, progress )";
        }
        _notify_callbacks.push(notify_callback);
        if (!_notifications_active) {
            _start_notifications();
        }
    }
    /**
    * Subscribe to receiving status updates for replication progress
    *
    * @param replicate_callback
    *                      callback function( progress )
    *
    */
    function subscribeStatus(replicate_callback) {
        if (typeof replicate_callback != "function") {
            throw "Callback must be a function: function( progress )";
        }
        _replicate_callbacks.push(replicate_callback);
    }
    /**
    * Start a replication
    *
    * @param complete_callback
    *                    callback function( bool ), called when replication finishes
    * @param replInfo
    *                    data required for replication
    *
    */
    replicate = function(complete_callback, replInfo) {
        var ctxbldr, d, startReplicating, auth;
        function done(p) {
            /*
            var i, prop, s, totals;
            d = (new Date() - d) / 1000;
            localStorage.replicationDuration = d;
			
			mc.profiler.clear(false);
            mc.db.setJsonItem('replicationProfileResults', mc.replstore.profileResults);
			
			totals = {};
            for (i = 0; i < mc.replstore.profileResults.length; i += 1) {
            for (prop in mc.replstore.profileResults[i]) {
            if (mc.replstore.profileResults[i].hasOwnProperty(prop)) {
            if (totals.hasOwnProperty(prop)) {
            totals[prop] += mc.replstore.profileResults[i][prop];
            } else {
            totals[prop] = mc.replstore.profileResults[i][prop];
            }
            }
            }
            }
            s = '';
            for (prop in totals) {
            if (totals.hasOwnProperty) {
            s += 'Total time in ' + prop + ': ' + totals[prop] + '\n';
            }
            }
            localStorage.replicationProfileTotals = s;
			
			mc.replstore.profileResults.splice(0);
            */
            complete_callback(p);
        }
        /*
        d = new Date();
        mc.replstore.profileResults.splice(0);
        */

        log.trace("-> replicate");
        if (dbTestRepl > 0) {
            mc.db.dbTest(complete_callback, dbTestRepl);
            return;
        }
        log.trace("Device: " + navigator.appName + " " + navigator.appVersion + ")");
        if (typeof complete_callback != "function") {
            throw "Callback must be a function: function( bool )";
        }
        if (isReplicatingNow) {
            complete_callback(window.ReplicationResult.FailedToStartSession);
            throw "Already Syncing";
        }
		_reset();
        isReplicatingNow = true;
        _session_ended = false;
				
		if( window.plugins && window.plugins.sleep && window.plugins.sleep.Disable ) {
			log.info("Disabling sleep");
			window.plugins.sleep.Disable(function() {
				log.info("Sleep disabled");
			}, function(e) {
				log.warn("Sleep failed.");
			});
		}		

		_complete_callback = done; //complete_callback;
		
        startReplicating = function(url) {

            _url = url;

            _update_progress(0, 0, "Validating subjects...");
            mc.replstore.validateSubjects(function(errors, stop) {

                if (stop !== undefined && stop === true) {
                    abortReplication();
                    return;
                }
                
                _sync_database = mc.replsyncstore;
                _storage = mc.replstore;
                _storage.setProgressCallback(function(done) {
                    _stored_items_count = done;
                    _update_progress(0, 0, "Storing...");
                });
                _storage.setProgressMessageCallback(function(message) {                    
                    _update_progress(0, 0, "Storing...");
                });
                _repl_info = replInfo;
                if (replInfo === undefined || replInfo.profileAlias === undefined) {
                    _repl_info = {
                        processId: 'all',
                        profileAlias: 'defaultRepProfile',
                        title: 'Syncing',
                        url: '',
                        timeout: 600
                    };
                }
                // Fetch out the repl type from the
                ctxbldr = "replContext_" + _repl_info.profileAlias;
                ctxbldr = ctxbldr.replace(/-/g, "_");
                _repl_profile = mc.fl[ctxbldr];
                log.debug("Starting replication...");
                log.trace("processId:    " + _repl_info.processId);
                log.trace("profileAlias: " + _repl_info.profileAlias);
                log.trace("title:        " + _repl_info.title);
                log.trace("url:          " + _repl_info.url);
                log.trace("timeout:      " + _repl_info.timeout);
                
                // handle timeout
                _timeout_id = window.setTimeout(function() {
                    log.error("Replication timeout reached (" + _repl_info.timeout + ")");
                    _timeoutReplication();
                }, _repl_info.timeout * 1000);
                if (_repl_profile.type === 'fastlookup') {
                    _fast_lookup = true;
                    _send_fast_lookup_request();
                } else {
                    _fast_lookup = false;
                    _send_start_session();
                }
                _update_progress(0, 0, "Starting session");
                log.trace("<- replicate");
            });
        };

        auth = function() {
            mc.fl.isreachable(function(reachable) {
                if (reachable) {
                    log.debug('Server is reachable - authenticating...');
                    _authenticate(function(success) {
                        setTimeout(function() {
                            if (success) {
                                log.debug('Authenticated - starting retrieving username...');
                                window.plugins.settings.getUsername(function(username) {
                                    log.debug('Received username: ' + username);
                                    var userInfo = mc.db.getUserInfo();
                                    userInfo.mSuiteUserName = username;
                                    mc.db.setUserInfo(userInfo);
                                    log.debug('Stored username. Replicating...');
                                    window.plugins.settings.getURL(startReplicating, function () { log.debug('Unable to get server url'); startReplicating("") });
                                }); // getUsername
                            } else {
                                log.debug('Authentication failed - retrying...');
                                auth();
                            }
                        }, 0);
                    }); // _authenticate
                } else {
                    log.debug('Server is unreachable - no replication...');
                    complete_callback(window.ReplicationResult.ConnectionFailure);
                }
            }, undefined); // isreachable
        };

        if (window.locationUtils.isPPA()) {
            auth();
        } else if (typeof(cordova) != 'undefined' && typeof(cordova.exec) != 'undefined' && typeof(window.plugins) != 'undefined' && typeof(window.plugins.settings) != 'undefined') {
        	window.plugins.settings.getURL(startReplicating, function () { log.debug('Unable to get server url'); startReplicating("") });
        } else {
            startReplicating("");
        }
    };
    /**
    * Queue a request for sending
    *
    * @param data
    *                          The request data
    * @param front
    *                    Whether to push in at the front of the queue
    */
    _queue_request = function(data, front) {
        log.trace("-> _queue_request");
        if (isReplicatingNow) {
            if (front) {
                _request_queue.splice(0, 0, data);
            }
            else {
                _request_queue.push(data);
            }
            _pump_request_queue();
        }
        log.trace("<- _queue_request");
    };
    /**
    * Execute the next request in the queue, if there is not one running
    *
    */
    _pump_request_queue = function() {
        log.trace("-> _pump_request_queue");
        if (_outstanding_requests.length < 1) {
            _execute_next_request();
        }
        log.trace("<- _pump_request_queue");
    };
    
    /**
    * Execute the next download in the queue, if there is not one running
    *
    */
    _pump_download_queue = function() {
        log.trace("-> _pump_download_queue");
        if (_waiting_on_download < 1) {
            _execute_next_download();
        }
        log.trace("<- _pump_download_queue");
    };
    
    _execute_next_download = function() {
        var item, split;
        function downloadSuccess(syncdata) {
						// reset timeout for attachments
						_reset_timeout();

            _waiting_on_storage++;
            _storage.queue_set_data(item.itemid, '', syncdata, function(error) {
                _waiting_on_storage--;
                if (error === undefined) {
                    _sync_database.add(item.itemid, syncdata);
                    _queue_ack(item.itemid, window.Protocol.ItemCreatedTag);
                    log.info("Created: " + item.itemid);
                } else {
                    log.error("Failed to create: " + item.itemid + " : " + error);
                    _send_fail_ack(item.itemid, window.Protocol.ItemCreatedTag, error);
                    // Need to get rid of this subject, if it is on the device.
                    // TODO
                    if (_single_item == true) {
                        abortReplication();
                    }
                }
            });
            _waiting_on_download--;
            _pump_download_queue();
        }
        function downloadError(error) {
            log.debug('Error Downloading Attachment: ' + item.itemid + ' Error: ' + JSON.stringify(error));
            abortReplication();
        }        
        log.trace("-> _execute_next_download");
        item = _download_queue.shift();
        if (item) {
            log.debug('Downloading next attachment: ' + JSON.stringify(item));
            _waiting_on_download++;
            split = _storage.split_attachment_id(item.itemid);
            _update_callbacks(0, 0, "Downloading attachments...");
            mc.fs.downloadAttachment(split.subjectGuid, split.attachmentName, downloadSuccess, downloadError);
        }
        log.trace("<- _execute_next_download");
    }
    

    isReplicatingNow = false;
    // Private
    _chunk_size = 100;
    _request_queue = [];
    _ack_queue = [];
    _retrieval_queue = [];
    _outstanding_requests = [];
    _time_since_update = new Date().getTime();
    _session_ended = false;
    _session_running = false;
    _notifications_active = false;
    _single_item = false;
    _logon_Session = false;
    _fast_lookup = false;
    _authcount = 0;
    _isAndroid = (/android/gi).test(window.navigator.appVersion);
    _isIOS = (/iphone|ipad/gi).test(navigator.appVersion);
    isBlackberry = (/blackberry/gi).test(window.navigator.appVersion);
    _request_more = 0;
    _total_subjects = 0;
    _stored_items_count = 0;
    // used for calculating progress
    _calls_made = 0;
    _acked_calls = 0;
    _max_queue_length = 0;
    // used for detecting completion
    _waiting_on_storage = 0;
    _download_queue = [];
    _waiting_on_download = 0;
    _second_stage = false;
    // used so that we only ever do one restart
    _have_restarted = false;
    // Status callbacks
    _notify_callbacks = [];
    _replicate_callbacks = [];
    _complete_callback = null;
    // Console Logging
    debugLevel = parseInt(window.getUrlVars().debug, 10);
    dbTestRepl = window.getUrlVars().dbtest;
    serverLog = window.getUrlVars().serverlog;
    _Application_Id = "b6e9d230-897c-654a-b291-d05e4c11fed8";
    // _Application_Id = "c08c3dd3-4d89-0c45-9cd1-4133611f0239";

    /**
    * Public replicator definition
    *
    */
    mc.repl = {
        abortReplication: abortReplication,
        isReplicating: isReplicating,
        replicate: replicate,
        subscribeNotify: subscribeNotify,
        subscribeStatus: subscribeStatus,
        store: undefined,
        syncstore: undefined
    };

} (window.jmfw, window.mCapture));

﻿(function($, mc) {
	var batteryLevel = -1;
	var ac = undefined;
	var registered = false;
	
	var lastBatteryLevel = 'lastBatteryLevel';
	var lastBatteryTime = 'lastBatteryTime';
   
	function startMonitoring() {
		if( registered )
			return;

		if( localStorage[lastBatteryTime] ) {
			var diff =  (new Date()).getTime() - localStorage[lastBatteryTime];
			if( diff < 60 * 60 * 1000 ) {
				batteryLevel = localStorage[lastBatteryLevel];
			}
		}
			
		log.debug("Registering for Battery status"); 
		registered = true;
		window.addEventListener("batterystatus", onBatteryStatus, false);
		window.addEventListener("beforeunload", stopMonitoring, false);
	}
	
	function stopMonitoring() {
		if( !registered )
			return;
	
		registered = false;
		log.debug("Stopping battery monitoring");
		window.removeEventListener("batterystatus", onBatteryStatus, false);
		log.debug("Stopped battery monitoring");
	}
	
	function onBatteryStatus(info) {
		log.debug("Battery level: " + info.level + ", plugged in: " + info.isPlugged); 
		batteryLevel = info.level;
		ac = info.isPlugged;

		localStorage[lastBatteryLevel] = batteryLevel;
		localStorage[lastBatteryTime] = (new Date()).getTime();
	}
	
	function getLevel() {
		log.debug("Current Level is " + batteryLevel);
		return batteryLevel;
	}
	
	function getPluggedIn() {
		return ac;
	}
   
    mc.battery = {
        getLevel: getLevel,
		getPluggedIn: getPluggedIn
    };
	
	log.debug("Registering for Device ready"); 
	document.addEventListener("deviceready", startMonitoring, false);

} (window.jmfw, window.mCapture));
/*
** END OF MC2.BATTERY.JS
*/
/*
 Copyright 2011-2013 Abdulla Abdurakhmanov
 Original sources are available at https://code.google.com/p/x2js/

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

function X2JS(config) {
	'use strict';
		
	var VERSION = "1.1.0";
	
	config = config || {};
	initConfigDefaults();
	
	function initConfigDefaults() {
		if(config.escapeMode === undefined)
			config.escapeMode = true;
		if(config.attributePrefix === undefined)
			config.attributePrefix = "_";
		if(config.arrayAccessForm === undefined)
			config.arrayAccessForm = "none";
	}

	var DOMNodeTypes = {
		ELEMENT_NODE 	   : 1,
		TEXT_NODE    	   : 3,
		CDATA_SECTION_NODE : 4,
		DOCUMENT_NODE 	   : 9
	};
	
	function getNodeLocalName( node ) {
		var nodeLocalName = node.localName;			
		if(nodeLocalName == null) // Yeah, this is IE!! 
			nodeLocalName = node.baseName;
		if(nodeLocalName == null || nodeLocalName=="") // =="" is IE too
			nodeLocalName = node.nodeName;
		return nodeLocalName;
	}
	
	function getNodePrefix(node) {
		return node.prefix;
	}
		
	function escapeXmlChars(str) {
		if(typeof(str) == "string")
			return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g, '&#x2F;');
		else
			return str;
	}

	function unescapeXmlChars(str) {
		return str.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&#x2F;/g, '\/');
	}
	
	function toArrayAccessForm(obj, childName) {
		switch(config.arrayAccessForm) {
		case "property":
			if(!(obj[childName] instanceof Array))
				obj[childName+"_asArray"] = [obj[childName]];
			else
				obj[childName+"_asArray"] = obj[childName];
			break;		
		/*case "none":
			break;*/
		}
	}

	function parseDOMChildren( node ) {
		if(node.nodeType == DOMNodeTypes.DOCUMENT_NODE) {
			var result = new Object;
			var child = node.firstChild; 
			var childName = getNodeLocalName(child);
			result[childName] = parseDOMChildren(child);
			return result;
		}
		else
		if(node.nodeType == DOMNodeTypes.ELEMENT_NODE) {
			var result = new Object;
			result.__cnt=0;
			
			var nodeChildren = node.childNodes;
			
			// Children nodes
			for(var cidx=0; cidx <nodeChildren.length; cidx++) {
				var child = nodeChildren.item(cidx); // nodeChildren[cidx];
				var childName = getNodeLocalName(child);
				
				result.__cnt++;
				if(result[childName] == null) {
					result[childName] = parseDOMChildren(child);
					toArrayAccessForm(result, childName);					
				}
				else {
					if(result[childName] != null) {
						if( !(result[childName] instanceof Array)) {
							var tmpObj = result[childName];
							result[childName] = new Array();
							result[childName][0] = tmpObj;
							toArrayAccessForm(result, childName);
						}
					}
					var aridx = 0;
					while(result[childName][aridx]!=null) aridx++;
					(result[childName])[aridx] = parseDOMChildren(child);
				}			
			}
			
			// Attributes
			for(var aidx=0; aidx <node.attributes.length; aidx++) {
				var attr = node.attributes.item(aidx); // [aidx];
				result.__cnt++;
				result[config.attributePrefix+attr.name]=attr.value;
			}
			
			// Node namespace prefix
			var nodePrefix = getNodePrefix(node);
			if(nodePrefix!=null && nodePrefix!="") {
				result.__cnt++;
				result.__prefix=nodePrefix;
			}
			
			if( result.__cnt == 1 && result["#text"]!=null  ) {
				result = result["#text"];
			} 
			
			if(result["#text"]!=null) {				
				result.__text = result["#text"];
				if(result.__text instanceof Array) {
					result.__text = result.__text.join("\n");
				}
				if(config.escapeMode)
					result.__text = unescapeXmlChars(result.__text);
				delete result["#text"];
				delete result["#text_asArray"];
			}
			if(result["#cdata-section"]!=null) {
				result.__cdata = result["#cdata-section"];
				delete result["#cdata-section"];
				delete result["#cdata-section_asArray"];
			}
			
			if(result.__cnt!= undefined) {
				delete result.__cnt;
			}
			
			if(result.__text!=null || result.__cdata!=null) {
				result.toString = function() {
					return (this.__text!=null? this.__text:'')+( this.__cdata!=null ? this.__cdata:'');
				};
			}
			return result;
		}
		else
		if(node.nodeType == DOMNodeTypes.TEXT_NODE || node.nodeType == DOMNodeTypes.CDATA_SECTION_NODE) {
			return node.nodeValue;
		}	
	}
	
	function startTag(jsonObj, element, attrList, closed) {
		var resultStr = "<"+ ( (jsonObj!=null && jsonObj.__prefix!=null)? (jsonObj.__prefix+":"):"") + element;
		if(attrList!=null) {
			for(var aidx = 0; aidx < attrList.length; aidx++) {
				var attrName = attrList[aidx];
				var attrVal = jsonObj[attrName];
				resultStr+=" "+attrName.substr(1)+"='"+attrVal+"'";
			}
		}
		if(!closed)
			resultStr+=">";
		else
			resultStr+="/>";
		return resultStr;
	}
	
	function endTag(jsonObj,elementName) {
		return "</"+ (jsonObj.__prefix!=null? (jsonObj.__prefix+":"):"")+elementName+">";
	}
	
	function endsWith(str, suffix) {
	    return str.indexOf(suffix, str.length - suffix.length) !== -1;
	}
	
	function jsonXmlSpecialElem ( jsonObj, jsonObjField ) {
		if((config.arrayAccessForm=="property" && endsWith(jsonObjField.toString(),("_asArray"))) 
				|| jsonObjField.toString().indexOf(config.attributePrefix)==0 
				|| jsonObjField.toString().indexOf("__")==0
				|| (jsonObj[jsonObjField] instanceof Function) )
			return true;
		else
			return false;
	}
	
	function jsonXmlElemCount ( jsonObj ) {
		var elementsCnt = 0;
		if(jsonObj instanceof Object ) {
			for( var it in jsonObj  ) {
				if(jsonXmlSpecialElem ( jsonObj, it) )
					continue;			
				elementsCnt++;
			}
		}
		return elementsCnt;
	}
	
	function parseJSONAttributes ( jsonObj ) {
		var attrList = [];
		if(jsonObj instanceof Object ) {
			for( var ait in jsonObj  ) {
				if(ait.toString().indexOf("__")== -1 && ait.toString().indexOf(config.attributePrefix)==0) {
					attrList.push(ait);
				}
			}
		}
		return attrList;
	}
	
	function parseJSONTextAttrs ( jsonTxtObj ) {
		var result ="";
		
		if(jsonTxtObj.__cdata!=null) {										
			result+="<![CDATA["+jsonTxtObj.__cdata+"]]>";					
		}
		
		if(jsonTxtObj.__text!=null) {			
			if(config.escapeMode)
				result+=escapeXmlChars(jsonTxtObj.__text);
			else
				result+=jsonTxtObj.__text;
		}
		return result;
	}
	
	function parseJSONTextObject ( jsonTxtObj ) {
		var result ="";

		if( jsonTxtObj instanceof Object ) {
			result+=parseJSONTextAttrs ( jsonTxtObj );
		}
		else
			if(jsonTxtObj!=null) {
				if(config.escapeMode)
					result+=escapeXmlChars(jsonTxtObj);
				else
					result+=jsonTxtObj;
			}
		
		return result;
	}
	
	function parseJSONArray ( jsonArrRoot, jsonArrObj, attrList ) {
		var result = ""; 
		if(jsonArrRoot.length == 0) {
			result+=startTag(jsonArrRoot, jsonArrObj, attrList, true);
		}
		else {
			for(var arIdx = 0; arIdx < jsonArrRoot.length; arIdx++) {
				result+=startTag(jsonArrRoot[arIdx], jsonArrObj, parseJSONAttributes(jsonArrRoot[arIdx]), false);
				result+=parseJSONObject(jsonArrRoot[arIdx]);
				result+=endTag(jsonArrRoot[arIdx],jsonArrObj);						
			}
		}
		return result;
	}
	
	function parseJSONObject ( jsonObj ) {
		var result = "";	

		var elementsCnt = jsonXmlElemCount ( jsonObj );
		
		if(elementsCnt > 0) {
			for( var it in jsonObj ) {
				
				if(jsonXmlSpecialElem ( jsonObj, it) )
					continue;			
				
				var subObj = jsonObj[it];						
				
				var attrList = parseJSONAttributes( subObj )
				
				if(subObj == null || subObj == undefined) {
					result+=startTag(subObj, it, attrList, true);
				}
				else
				if(subObj instanceof Object) {
					
					if(subObj instanceof Array) {					
						result+=parseJSONArray( subObj, it, attrList );					
					}
					else {
						var subObjElementsCnt = jsonXmlElemCount ( subObj );
						if(subObjElementsCnt > 0 || subObj.__text!=null || subObj.__cdata!=null) {
							result+=startTag(subObj, it, attrList, false);
							result+=parseJSONObject(subObj);
							result+=endTag(subObj,it);
						}
						else {
							result+=startTag(subObj, it, attrList, true);
						}
					}
				}
				else {
					result+=startTag(subObj, it, attrList, false);
					result+=parseJSONTextObject(subObj);
					result+=endTag(subObj,it);
				}
			}
		}
		result+=parseJSONTextObject(jsonObj);
		
		return result;
	}
	
	this.parseXmlString = function(xmlDocStr) {
		if (xmlDocStr === undefined) {
			return null;
		}
		var xmlDoc;
		if (window.DOMParser) {
			var parser=new window.DOMParser();			
			xmlDoc = parser.parseFromString( xmlDocStr, "text/xml" );
		}
		else {
			// IE :(
			if(xmlDocStr.indexOf("<?")==0) {
				xmlDocStr = xmlDocStr.substr( xmlDocStr.indexOf("?>") + 2 );
			}
			xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
			xmlDoc.async="false";
			xmlDoc.loadXML(xmlDocStr);
		}
		return xmlDoc;
	};
	
	this.asArray = function(prop) {
		if(prop instanceof Array)
			return prop;
		else
			return [prop];
	}

	this.xml2json = function (xmlDoc) {
		return parseDOMChildren ( xmlDoc );
	};
	
	this.xml_str2json = function (xmlDocStr) {
		var xmlDoc = this.parseXmlString(xmlDocStr);	
		return this.xml2json(xmlDoc);
	};

	this.json2xml_str = function (jsonObj) {
		return parseJSONObject ( jsonObj );
	};

	this.json2xml = function (jsonObj) {
		var xmlDocStr = this.json2xml_str (jsonObj);
		return this.parseXmlString(xmlDocStr);
	};
	
	this.getVersion = function () {
		return VERSION;
	};
	
}
﻿(function ($, mc) {
    var progressMax, progressCurrent;

    function dataLoadRequired(ppaRelativePath, callback) {
        var el = document.createElement('script');
        el.src = ppaRelativePath + 'data.js';
        el.type = 'text/javascript';
        document.getElementsByTagName('head')[0].appendChild(el);

        window.ppaLoadDataCallback = function (ppaData) {
            var oldVersion, newVersion;
            delete window.ppaLoadDataCallback;
            window.ppaData = ppaData;
            if (!window.ppaData) {
                return callback(false);
            }
            oldVersion = window.localStorage.getItem('ppaDataVersion');
            newVersion = window.ppaData.version;
            return callback(oldVersion !== newVersion);
        };
    }

    // mode should be 'pza' or 'ppa'
    function loadData(mode, ppaRelativePath, updateProgress, complete) {
        var ppaData;
        function loadDataComplete() {
            window.localStorage.setItem('ppaDataVersion', window.ppaData.version);
            log.info('PPA: data load complete');
            complete();
        }
        log.info('PPA: data load starting...');
        ppaData = window.ppaData;
        progressCurrent = 0;
        progressMax = ppaData.attachments.length + ppaData.subjects.length;
        loadAttachments(mode, ppaRelativePath, ppaData.attachments, updateProgress, function () {
            loadSubjects(ppaData.subjects, ppaRelativePath, updateProgress, loadDataComplete);
        });
    }

    function loadAttachments(mode, ppaRelativePath, attachments, updateProgress, complete) {
        var current, copyAsset;

        function loadCurrent() {
            var parts, subjectGuid, name, src;

            function importSuccess() {
                log.info('PPA: attachment loaded: ' + src);
                mc.db.setAttachment(subjectGuid, name, '', false, next);
            }

            function importError(e) {
                log.error('PPA: error importing attachment file: ' + JSON.stringify(e));
            }

            function resolvePath(dir, rel) {
                var dirParts = dir.split(/[\\\/]/),
					relParts = rel.split(/[\\\/]/);
                relParts.forEach(function (relPart) {
                    switch (relPart) {
                        case '.':
                            break;
                        case '..':
                            dirParts.pop();
                            break;
                        default:
                            dirParts.push(relPart);
                            break;
                    }
                });
                return dirParts.join('/').match(/\/(mdesign\/\d+\/.*)/i)[1];
            }

            function gotAttachmentPath(dest) {
                var src;
                switch (mode) {
                    case 'pza':
                        src = resolvePath(new URI().directory(), ppaRelativePath + 'attachments/' + subjectGuid + '/' + name);
                        window.plugins.resource.copyAssetFromAppCache(src, dest, importSuccess, importError);
                        break;
                    default:
                        src = 'data/attachments/' + subjectGuid + '/' + name;
                        window.plugins.resource.copyAssetFromWWWFolder
                        break;
                }
            }

            parts = current.itemid.split('\\');
            subjectGuid = parts[1];
            name = parts[2];

            log.debug('PPA: loading attachment: ' + current.itemid);
            mc.fs.getAttachmentPath(subjectGuid, name, gotAttachmentPath, importError);
        }

        function next() {
            updateProgress(progressCurrent++ / progressMax * 100);
            current = attachments.shift();
            if (current) {
                loadCurrent();
            } else {
                complete();
            }
        }

        log.info('PPA: loading ' + attachments.length + ' attachment(s)...');
        next();
    }

    function loadSubjects(subjects, relativePath, updateProgress, complete) {
        var current;
        function loadCurrent() {
            function gotItemData(itemdata) {
                mc.db.startTransaction(function (tx) {
                    mc.replstore.set_data(tx, current.itemid, itemdata, current.syncdata, function () { });
                }, function () {
                    log.info('PPA: subject loaded: ' + current.itemid);
                    setTimeout(next);
                });
            }
            log.debug('PPA: loading subject: ' + current.itemid);
            var path = relativePath + current.itemid.replace(/\\/g, '/');
            downloadSubject(path, gotItemData);
        }
        function next() {
            updateProgress(progressCurrent++ / progressMax * 100);
            current = subjects.shift();
            if (current) {
                loadCurrent();
            } else {
                complete();
            }
        }
        log.info('PPA: loading ' + subjects.length + ' subject(s)...');
        next();
    }

    function downloadSubject(uri, success) {
        console.log('PPA: downloading : ' + uri);
        window.ppaLoadSubjectCallback = function (content) {
            console.log('PPA: downloaded : ' + uri);
            success(content);
            delete window.ppaLoadSubjectCallback;
        };
        var el = document.createElement('script');
        el.type = 'text/javascript';
        el.src = uri;
        document.getElementsByTagName('head')[0].appendChild(el);
    }

    mc.ppa = {
        dataLoadRequired: dataLoadRequired,
        loadData: loadData
    };

})(window.jmfw, window.mCapture);
﻿(function($, mc) {

	var mcversion = 'jenkins-8.1.492';

	var cordovaready = false;
	var shellcalled = false;

	var versionInfo = {
		device: 'not reported',
		framework: 'not reported',
		logging: 'not reported',
		idb: 'not reported'
	};

	function tellShell() {
		function success() {
			log.info("versionInfo reported to shell");
		}
		function error(e) {
			log.error("Unable to report versionInfo to shell reason: " + e);
		}
		if (cordovaready) {
			//Tell the shell if it's present what the current version state is
			if (typeof (window.plugins) !== 'undefined') {
			    if (typeof (window.plugins.settings) !== 'undefined') {
				    if (typeof (window.plugins.settings.setVersions) === 'function') {
					    try {
						    window.plugins.settings.setVersions(success, error, versionInfo)
						    shellcalled = true;
					    } catch (e) {
						    error(e);
					    }
					    return;
				    }
				    log.debug("typeof(window.plugins.settings.setVersions) = " + typeof (window.plugins.settings.setVersions));
				  }
    			log.debug("plugins.settings not ready: " + typeof (window.plugins) + " - " + typeof (window.plugins.settings));
			}
			log.debug("plugins not ready: " + typeof (window.plugins));
		}
		log.debug("Unable to report versionInfo to shell reason: cordova not ready");
	}

	function logVersion(component) {
		var comp = component.toLowerCase();
		var ver = versionInfo[comp];
		log.info("Component : " + comp + " Version : " + ver);
		tellShell();
	}

	function logInfo() {
		$.each(versionInfo, function(index, item) { logVersion(item); });
	}

	function setVersion(component, version) {
		versionInfo[component.toLowerCase()] = version;
		logVersion(component);
	}


	function getInfo() {
		return versionInfo;
	}

	function getVersion(component) {
		return versionInfo[component];
	}

	function ready() {
		// Use the "ready" function to set the code version
		//debugger;
		mc = mCapture;
		mc.version.setversion('framework', mcversion);
	}

	function phonegapReady() {
		// Use the "phonegapReady" function to allow the shell to be notified of version changes
		//debugger;
		cordovaready = true;
		if (!shellcalled)
			tellShell();
	}


	// Listen for the mcready event
	window.document.addEventListener('mcready', ready, false);
	// Listen for phonegap ready
	window.document.addEventListener("deviceready", phonegapReady, false);

	mc.version = {
		setversion: setVersion,
		getversion: getVersion,
		getinfo: getInfo,
		logversion: logVersion,
		loginfo: logInfo
	};

} (window.jmfw, window.mCapture));
/*
** END OF VERSION.MC2.JS
*/
